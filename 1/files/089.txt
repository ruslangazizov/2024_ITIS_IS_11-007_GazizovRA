Типы коллекций - SwiftBook
 
Учебник
Курсы
Онлайн-курс «iOS-разработчик»
Курсы по подписке
Копошилка
Статьи
Видео
Войти
Вход
Сброс пароля
 
Найти:
 
Учебник
Курсы
Онлайн-курс «iOS-разработчик»
Курсы по подписке
Копошилка
Статьи
Видео
Войти
Вход
Сброс пароля
 
Найти:
Документация
 
 
Развернуть
Свернуть
              
        Документация		
		  
		  
        
              
        Знакомство со Swift		
		  
		  
        
 О языке Swift
 Совместимость версий Swift
 Тур по Swift
 
              
        Руководство Swift		
		  
		  
        
 Основы
 Базовые операторы
 Строки и символы
 Типы коллекций
 Управление потоком
 Функции
 Замыкания
 Перечисления
 Структуры и классы
 Свойства
 Методы
 Сабскрипты
 Наследование
 Инициализация
 Деинициализация
 Опциональная последовательность
 Обработка ошибок
 Согласованность
 Приведение типов
 Вложенные типы
 Расширения
 Непрозрачные типы
 Протоколы
 Универсальные шаблоны
 Автоматический подсчет ссылок (ARC)
 Безопасность хранения
 Контроль доступа
 Продвинутые операторы
 
              
        Справочник языка		
		  
		  
        
 Лексическая структура
 Типы
 Выражения
 Инструкции
 Объявления
 Атрибуты
 Шаблоны
 Параметры и аргументы универсального типа
 Резюме по грамматике
 
 
		Типы коллекций		
        
Типы коллекций
Swift обеспечивает три основных типа коллекций - это Массивы, Множества и Словари для хранения коллекций значений. Массивы - это упорядоченные коллекции значений. Множества - это неупорядоченные коллекции уникальных значений. Словари - это неупорядоченные коллекции, хранящие пары "ключ-значение".
￼
Массивам, множествам и словарям в Swift всегда понятно, какие типы значений и ключи они могут хранить. Это означает, что вы не можете по ошибке вставить неверное значение в коллекцию. Это также означает, что вы можете быть уверены в типах значений, которые вы получите из коллекции.
Заметка
Забегая вперед, скажем, что Массив, Словарь и Множество в Swift реализованы как универсальные коллекции. Более подробную информацию об универсальных типах и коллекциях можно получить в главе "Универсальные шаблоны".
Изменчивость коллекций
Когда вы создаете массив, словарь или множество и присваиваете его переменной, то созданная коллекция будет изменяемой. Это означает, что вы можете изменить коллекцию после ее создания путем добавления, удаления, или изменения элементов этой коллекции. И наоборот, когда вы присвоите массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено.
Заметка
Хорошей практикой является создание неизменяемых коллекций во всех случаях, когда коллекцию не нужно менять. Делая это, мы позволяем компилятору Swift оптимизировать производительность наших коллекций.
Массивы
Массивы хранят значения одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях.
Заметка
Массив в Swift связан с классом Foundation  NSArray. Для более подробной информации об использовании Array с Foundation и Cocoa, см. Bridging Between Array and NSArray.
Сокращённый синтаксис массивов
Полная форма записи массива в Swift пишется Array<Element>, где Element это тип значения, который может хранить массив.
Вы можете также написать массив в сокращенной форме как [Element].
Хотя две формы функционально идентичны, краткая форма является предпочтительной и используется в данном руководстве при обращении к типу массива.
Создание пустого массива
Вы можете создать пустой массив определенного типа с помощью синтаксиса инициализатора:
var someInts = [Int]()
print("someInts is of type [Int] with \(someInts.count) items.")
// Выведет "someInts is of type [Int] with 0 items."
Обратите внимание, что тип переменной someInts выводится как [Int] от типа инициализатора.
В качестве альтернативы, если контекст уже содержит информацию о типе, например, аргумент функции или уже типизированную переменную или константу, вы можете создать пустой массив с помощью пустого литерала массива, который записывается в виде [] (пустой пары квадратных скобок):
someInts.append(3)
// массив someInts теперь содержит одно значение типа Int
someInts = []
// массив someInts теперь пуст, но все равно имеет тип [Int]
Создание массива с дефолтным значением
Тип массива в Swift также обеспечивает инициализатор для создания массива определенного размера со всеми его значениями, установленными на одно и то же дефолтное значение. Вы передаете этому инициализатору дефолтное значение соответствующего типа (называемое repeating): и сколько раз это значение повторяется в новом массиве (так называемый count):
var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles имеет тип [Double] и равен [0.0, 0.0, 0.0]
Создание массива, путем объединения двух массивов
Вы можете создать новый массив, объединив два существующих массива с совместимыми типами с оператором сложения (+). Новый тип массива выводится из типа двух массивов, которые вы объединяете вместе:
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles имеет тип [Double] и равен [2.5, 2.5, 2.5]
 
var sixDoubles = threeDoubles + anotherThreeDoubles
// тип sixDoubles выведен как [Double] и равен [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
Создание массива через литералы массива
Вы можете инициализировать массив с помощью литерала массива, который является быстрым способом писать одно или несколько значений как набор значений массива.
Литерал массива пишется в виде списка значений, разделенных запятыми и окруженными парой (квадратных) скобок:
[значение 1, значение 2, значение 3]
В приведенном ниже примере создается массив под названием shoppingList для хранения String значений:
var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList был инициализирован с двумя элементами
Переменная shoppingList объявлена как "массив из String значений", который записывается как [String]. Поскольку для этого массива указан тип значения String, ему разрешено хранить только String значения. Здесь, массив shoppingList инициализирован двумя String значениями ("Eggs" и "Milk"), написанными внутри литерала массива.
Заметка
Массив shoppingList объявлен как переменная ( с помощью var ), а не константа ( с помощью let ), поскольку много элементов добавляются в список покупок в примерах ниже.
В данном случае литерал массива содержит два String значения и больше ничего. Это подходит типу, который мы присвоили при объявлении переменной shoppingList ( массив который может хранить только String значения), и поэтому присвоение литерала массива разрешено как способ инициализации shoppingList двумя начальными элементами.
Благодаря выводу типов Swift, вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа. Вместо этого, инициализация shoppingList может быть записана в сокращенной форме:
var shoppingList = ["Eggs", "Milk"]
Поскольку все значения внутри литерала массива одинакового типа, Swift может вывести, что [String] является правильным типом для переменной shoppingList.
Доступ и изменение массива
Вы можете получить доступ к массиву и изменять его либо через его методы и свойства, либо используя синтаксис сабскриптов.
Чтобы узнать количество элементов в массиве, проверьте его read-only свойство count:
print("The shopping list contains \(shoppingList.count) items.")
// Выведет "The shopping list contains 2 items."
Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0:
if shoppingList.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list is not empty.")
}
// Выведет "The shopping list is not empty."
Вы можете добавить новый элемент в конец массива через вызов метода append:
shoppingList.append("Flour")
​// shoppingList теперь содержит 3 элемента, а кое-кто делает блины
Кроме того, добавить массив с одним или несколькими совместимыми элементами можно с помощью оператора сложения и присвоения (+=):
shoppingList += ["Baking Powder"]
​// shoppingList теперь хранит 4 элемента
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
​// shoppingList теперь хранит 7 элементов
Можно извлечь значение из массива с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива.
var firstItem = shoppingList[0]
// firstItem равен "Eggs"
Заметка
Первый элемент в этом массиве имеет индекс  0, а не 1. Массивы в Swift всегда начинаются с 0.
Вы можете использовать синтаксис сабскриптов для изменения существующего значения данного индекса:
shoppingList[0] = "Six eggs"
​// первый элемент в списке теперь равен "Six eggs", а не "Eggs"
Вы также можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяющих значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Следующий пример заменяет "Chocolate Spread", "Cheese", и "Butter" на "Bananas" и "Apples":
shoppingList[4...6] = ["Bananas", "Apples"]
​// shoppingList теперь содержит 6 элементов
Для вставки элемента по заданному индексу внутрь массива, вызовите его метод insert(_:at:) :
shoppingList.insert("Maple Syrup", at: 0)
​// shoppingList теперь содержит 7 элементов
​// "Maple Syrup" теперь первый элемент списка
Вызвав этот insert(_:at:) метод, мы вставили новый элемент со значением "Maple Syrup" в самое начало списка покупок, то есть в элемент с индексом 0.
Аналогичным образом можно удалить элемент из массива с помощью метода remove(at:). Этот метод удаляет элемент с указанным индексом и возвращает удалённый элемент (хотя вы можете игнорировать возвращаемое значение, если оно вам не нужно):
let mapleSyrup = shoppingList.remove(at: 0)
​// элемент который имел индекс 0 был удален
// shoppingList теперь содержит 6 элементов, и нет Maple Syrup
​// константа mapleSyrup теперь равна удаленной строке "Maple Syrup"
Заметка
Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива, у вас будет ошибка исполнения. Вы можете проверить, действителен ли индекс, прежде чем его использовать, сравнив его с свойством count массива. За исключением случаев, когда count равен 0 (то есть массив пуст), самый большой валидный индекс в массиве всегда будет count - 1, так как массивы индексируются c нуля.
Любые пробелы внутри массива закрываются когда удаляется элемент, и поэтому значение с индексом 0 опять равно "Six eggs":
firstItem = shoppingList[0]
​// firstItem теперь равен "Six eggs"
Если вы хотите удалить последний элемент из массива, то можно использовать метод removeLast() вместо remove(at:), чтобы избежать необходимости запроса свойства count для массива. Также как и метод remove(at:), removeLast() возвращает удаленный элемент:
let​ ​apples​ = ​shoppingList​.​removeLast​()
// последний элемент массива был удален
// shoppingList теперь содержит 5 элементов, и нет яблок
// константа apples теперь равна удаленной строке "Apples"
Итерация по массиву
Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла for-in :
for item in shoppingList {
  print(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
Если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте вместо этого глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента. Вы можете разложить кортеж во временные константы или переменные в рамках итерации:
for (index, value) in shoppingList.enumerated() {
  print("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
Чтобы получить подробную информацию про цикл for-in, смотрите главу Циклы For-in.
Множества
Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.
Заметка
Тип Swift Set связан с классом Foundation NSSet.
Получить больше информации об использовании множества с фреймворками Foundation и Cocoa можно в Bridging Between Set and NSSet.
Хеш значения для типа Set
Тип должен быть хешируемым для того, чтобы мог храниться в множестве, таким образом тип должен предоставлять возможность для вычисления собственного значения хеша. Тип значения хеша Int должен быть для всех объектов одинаковым, чтобы можно было провести сравнение что если a == b, то и a.hashValue == b.hashValue.
Все базовые типы Swift (Int, String, Double, Bool) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений (что описано в главе Перечисления) так же являются хешируемыми по умолчанию.
Заметка
Вы можете использовать ваш собственный тип в качестве типа значения множества или типа ключа словаря, подписав его под протокол Hashable из стандартной библиотеки Swift. Типы, которые подписаны под протокол Hashable должны обеспечивать gettable свойство hashValue. Значение, которое возвращает hashValue не обязательно должно иметь одно и то же значение при выполнении одной и той же программы или разных программ.
Так как протокол Hashable подписан под протокол Equatable, то подписанные под него типы так же должны предоставлять реализацию оператора равенства ==. Протокол Equatable требует любую реализацию оператора равенства для реализации возможности сравнения. Таким образом, реализация оператора == должна удовлетворять следующим трем условиям, для всех трех значений a, b, c.
a == a (Рефлексивность)
a == b, значит b == a (Симметрия)
b == a && b == c, значит a == c (Транзитивность)
Для более подробной информации читайте главу "Протоколы".
Синтаксис типа множества
Тип множества Swift записывается как Set<Element>, Element является типом, который хранится в множестве. В отличии от массивов множества не имеют сокращенной формы записи.
Создание и инициализация пустого множества
Вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора:
var letters = Set<Character>()
print("letters имеет тип Set<Character> с \(letters.count) элементами.")
// Выведет "letters имеет тип Set<Character> с 0 элементами."
Заметка
Тип переменной letters выведен из типа инициализатора как Set<Character>.
Альтернативно, если контекст предоставляет информацию о типе, например как аргумент функции или просто явное указание типа переменной или константы, то вы можете создать пустое множество при помощи пустого литерала массива:
letters.insert("a")
// letters теперь содержит 1 элемент типа Character
letters = []
// letters теперь является пустым множеством, но все еще имеет тип Set<Character>
Создание множества при помощи литерала массива
Вы так же можете инициализировать множество при помощи литерала массива, чтобы использовать его в качестве сокращенной записи нескольких элементов в качестве коллекции множества.
Пример ниже создает множество favoriteGenres для хранения String.
var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
// favoriteGenres был инициализирован при помощи трех начальных элементов
Переменная favoriteGenres объявлена как множество значений типа String, который записывается как Set<String>. Так как это множество имеет определенный тип String, то этому множеству позволено хранить только значения типа String. Поэтому здесь мы инициализируем favoriteGenres тремя значениями типа String, записанными в виде литерала массива.
Заметка
Множество favoriteGenres объявлен как переменная (ключевое слово var), но не константа (ключевое слово let), так как мы добавляем и удаляем элементы в примере ниже.
Так как тип множества не может быть выведен только из литерала, то его тип должен быть указан явно. Однако из-за вывода типа в Swift вы не должны писать тип множества, если вы инициализируете его при помощи литерала массива, который содержит элементы одного типа. Вместо этого инициализация favoriteGenres может быть записана и в более короткой форме:
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
Так как все элементы литерала массива одного типа, то Swift может вывести, что Set<String> является корректным типом для переменной favoriteGenres.
Доступ и изменение множества
Получить доступ и модифицировать множества можно через свойства и методы.
Для того, чтобы выяснить количество элементов в множестве вам нужно использовать свойство count:
print("У меня есть \(favoriteGenres.count) любимых музыкальных жанра.")
// Выведет "У меня есть 3 любимых музыкальных жанра."
Используйте булево свойство isEmpty в качестве сокращенной проверки наличия элементов во множестве или другими словами равно ли свойство count 0:
if favoriteGenres.isEmpty {
    print("Мне все равно какая музыка играет. Я не придирчив.")
} else {
    print("У меня есть свои музыкальные предпочтения.")
}
// Выведет "У меня есть свои музыкальные предпочтения."
Вы можете добавить новый элемент во множество, используя метод insert(_:):
favoriteGenres.insert("Jazz")
// теперь в favoriteGenres находится 4 элемента
Вы так же можете удалить элемент из множества, используя метод remove(_:), который удаляет элемент, который является членом множества и возвращает удаленное значение или nil, если удаляемого элемента нет. Так же все объекты множества могут быть удалены единовременно при помощи метода removeAll().
if let removedGenre = favoriteGenres.remove("Rock") {
    print("\(removedGenre)? С меня хватит.")
} else {
    print("Меня это не сильно заботит.")
}
// Выведет "Rock? С меня хватит."
Можно проверить наличие определенного элемента во множестве, используя метод contains(_:):
if favoriteGenres.contains("Funk") {
    print("О! Да я встал с правильной ноги!")
} else {
    print("Слишком много Funk'а тут.")
}
// Выведет "Слишком много Funk'а тут."
Итерация по множеству
Вы можете совершать итерации по множеству при помощи цикла for-in.
for genre in favoriteGenres {
    print("\(genre)")
}
// Classical
// Jazz
// Hip hop
Для более подробной информации по циклу for-in читайте в главе Циклы For-in.
Множества в Swift не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке, вам нужно использовать метод sorted(), который возвращает вам элементы коллекции в виде отсортированного массива, по умолчанию используя оператор <.
for genre in favoriteGenres.sorted() {
    print("\(genre)")
}
// Classical
// Hip hop
// Jazz
Выполнение операций с множествами
Вы можете очень эффективно использовать базовые операции множеств, например, комбинирование двух множеств, определение общих значений двух множеств, определять содержат ли множества несколько, все или ни одного одинаковых значения.
Базовые операции множеств
Иллюстрации внизу изображают два множества a и b в результате применения различных методов.
￼
Используйте метод union (_:) для создания нового множества состоящего из всех значений обоих множеств.
Используйте метод intersection(_:) для создания нового множества из общих значений двух входных множеств.
Используйте метод subtracting (_:) для создания множества со значениями не принадлежащих указанному множеству из двух входных.
Используйте метод symmetricDifference(_:) для создания нового множества из значений, которые не повторяются в двух входных множествах.
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
 
oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
Взаимосвязь и равенство множеств
Иллюстрация ниже отображает три множества a, b и c. Множество a является надмножеством множества b, так как содержит все его элементы, соответственно множество b является подмножеством множества a, опять таки потому, что все его элементы находятся в a. Множества b и c называются разделенными, так как у них нет общих элементов.
￼
Используйте оператор равенства (==) для определения все ли значения двух множеств одинаковы.
Используйте метод isSubset(of:) для определения все ли значения множества содержатся в указанном множестве.
Используйте метод isSuperset(of:), чтобы определить содержит ли множество все значения указанного множества.
Используйте методы isStrictSubset(of:) или isStrictSuperset(of:) для определения является ли множество подмножеством или надмножеством, но не равным указанному сету.
Используйте метод isDisjoint(with:) для определения того, отсутствуют ли общие значения в двух множествах или нет.
let houseAnimals: Set = ["собака", "кошка"]
let farmAnimals: Set = ["корова", "курица", "баран", "собака", "кошка"]
let cityAnimals: Set = ["ворона", "мышь"]
 
houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
Словари
Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа. Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря. В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка. Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так же как в реальном мире словарь используется для поиска определения конкретного слова.
Заметка
Тип словаря в Swift имеет связь с классом Foundation NSDictionary. Более подробно об использовании словаря в  Foundation и Cocoa, см. Bridging Between Dictionary and NSDictionary.
Сокращенный синтаксис словаря
В Swift тип словаря в полной форме пишется как Dictionary<Key, Value>, где Key это тип значения который используется как ключ словаря, а Value это тип значения который словарь может хранить для этих ключей.
Заметка
Тип словаря Key должен подчиняться протоколу Hashable, как тип значения множества.
Вы можете также написать словарь в сокращенной форме как [Key: Value]. Хотя две формы функционально идентичны, краткая форма является предпочтительной и используется в данном руководстве при обращении к типу словаря.
Создание пустого словаря
Подобно массивам вы можете создать пустой словарь определенного типа с помощью синтаксиса инициализатора:
var namesOfIntegers = [Int: String]()
// namesOfIntegers является пустым [Int: String] словарем
В этом примере создается пустой словарь с типом [Int: String] для хранения удобных для восприятия имен числовых значений. Его ключи имеют тип Int, а значения - String.
Если контекст уже предоставляет информацию о типе, вы можете создать пустой словарь с помощью литерала пустого словаря, который пишется как [:] ( двоеточие внутри пары квадратных скобок):
namesOfIntegers[16] = "sixteen"
// namesOfIntegers теперь содержит 1 пару ключ-значение
namesOfIntegers = [:]
// namesOfIntegers теперь опять пустой словарь с типом [Int: String]
Создание словаря с литералом словаря
Вы можете инициализировать словарь с помощью литерала словаря, который имеет схожий синтаксис с литералом массива, рассмотренного ранее. Литерал словаря это краткий способ написать одну или несколько пар ключ-значение в виде коллекций словаря.
Пара ключ-значение является комбинацией ключа и значения. В литерале словаря, ключ и значение в каждой паре ключ-значение разделено двоеточием. Пары ключ-значение написаны как список, разделенный запятыми и окруженный парой квадратных скобок:
[ключ 1: значение 1, ключ 2: значение 2, ключ 3: значение 3]
В примере ниже создается словарь, который хранит имена международных аэропортов. В этом словаре ключи являются трехбуквенным кодом международной ассоциации воздушного транспорта, а значения - названия аэропортов:
var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
Словарь airports объявлен с типом [​String​: ​String​], что означает "словарь ключи которого имеют тип String и значения которого также имеют тип String".
Заметка
Словарь airports объявлен как переменная ( с помощью var ), а не константа ( с помощью let ), поскольку много аэропортов будет добавляться к словарю в примерах ниже.
Словарь airports инициализирован с помощью литерала словаря, содержащего две пары ключ-значение. Первая пара имеет ключ "YYZ" и значение "Toronto Pearson". Вторая пара имеет ключ "DUB" и значение "Dublin".
Этот словарь содержит две пары String: String. Этот тип ключ-значение подходит типу который мы присвоили переменной airports ( словарь содержащий только String ключи, и только String значения), и поэтому присвоение литерала словаря допустимо в качестве способа инициализации словаря airports двумя начальным элементами.
Подобно массивам, вы можете не писать тип словаря если вы инициализируете его с помощью литерала словаря, чьи ключи и значения имеют соответствующие типы. Инициализация airports может быть записана в более краткой форме:
var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
Поскольку все ключи в литерале имеют одинаковый тип, и точно так же все значения имеют одинаковый тип, то Swift может вывести, что [String: String] является правильным типом для использования в словаре airports.
Доступ и изменение словаря
Вы можете получить доступ к словарю и изменять его либо через его методы и свойства, либо используя синтаксис индексов. Подобно массивам, вы можете узнать количество элементов в словаре через его read-only свойство count:
print("The airports dictionary contains \(airports.count) items.")
// Выведет "The airports dictionary contains 2 items."
Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0:
if airports.isEmpty {
  print("The airports dictionary is empty.")
} else {
  print("The airports dictionary is not empty.")
}
// Выведет "The airports dictionary is not empty."
Вы можете добавить новый элемент в словарь с помощью синтаксиса индексов. Используйте новый ключ соответствующего типа в качестве индекса, а затем присвойте новое значение соответствующего типа:
airports["LHR"] = "London"
// словарь airports теперь содержит 3 элемента
Вы также можете использовать синтаксис индексов для изменения значения связанного с определенным ключом:
airports["LHR"] = "London Heathrow"
// значение для "LHR" поменялось на "London Heathrow"
В качестве альтернативы индексам, можно использовать метод словаря updateValue(_:forKey:), чтобы установить или обновить значение для определенного ключа. Подобно примерам с индексами вверху, метод updateValue(_:forKey:) устанавливает значение для ключа если оно не существует, или обновляет значение, если этот ключ уже существует. Однако, в отличие от индексов, метод updateValue(_:forKey:) возвращает старое значение после выполнения обновления. Это позволяет вам проверить состоялось ли обновление или нет.
Метод updateValue(_:forKey:) возвращает опциональное значение соответствующее типу значения словаря. Например, для словаря, который хранит String значения, метод возвратит String? тип, или "опциональный String". Это опциональное значение содержит старое значение для этого ключа, если оно существовало до обновления, либо nil если значение не существовало.
if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") {
  print("The old value for DUB was \(oldValue).")
}
// Выведет "The old value for DUB was Dublin."
Вы также можете использовать синтаксис индексов чтобы получить значение из словаря для конкретного ключа. Поскольку есть вероятность запросить ключ для несуществующего значения, индекс словаря возвращает опциональное значение соответствующее типу значений словаря. Если словарь содержит значение для запрошенного ключа, индекс возвращает опциональное значение, содержащее существующее значение для этого ключа. В противном случае индекс возвращает nil:
if let airportName = airports["DUB"] {
  print("The name of the airport is \(airportName).")
} else {
  print("That airport is not in the airports dictionary.")
}
// Выведет "The name of the airport is Dublin Airport."
Вы можете использовать синтаксис индексов для удаления пары ключ-значение из словаря путем присвоения nil значению для этого ключа:
airports["APL"] = "Apple International"
// "Apple International" несуществующий аэропорт для APL, так что удалим его
airports["APL"] = nil
// APL теперь был удален из словаря
Кроме того, можно удалить пару ключ-значение из словаря с помощью метода  removeValue(forKey:). Этот метод удаляет пару ключ-значение если она существует и затем возвращает значение , либо возвращает  nil если значения не существует:
if let removedValue = airports.removeValue(forKey: "DUB") {
  print("The removed airport's name is \(removedValue).")
} else {
  print("The airports dictionary does not contain a value for DUB.")
}
// Выведет "The removed airport's name is Dublin Airport."
Итерация по словарю
Вы можете сделать итерацию по парам ключ-значение в словаре с помощью for-in цикла. Каждое значение в словаре возвращается как кортеж (ключ, значение),и вы можете разложить части кортежа по временным константам или переменным в рамках итерации:
for (airportCode, airportName) in airports {
  print("\(airportCode): \(airportName)")
}
// LHR: London Heathrow
// YYZ: Toronto Pearson
Чтобы подробнее узнать про цикл for-in, смотрите главу Цикл for-in.
Вы также можете получить коллекцию ключей или значений словаря через обращение к его свойствам keys и values:
for airportCode in airports.keys {
  print("Airport code: \(airportCode)")
}
// Airport code: LHR
// Airport code: YYZ
for airportName in airports.values {
  print("Airport name: \(airportName)")
}
// Airport name: London Heathrow
// Airport name: Toronto Pearson
Если вам нужно использовать ключи или значения словаря вместе с каким-либо API, которое принимает объект Array, то можно инициализировать новый массив с помощью свойств keys и values:
let airportCodes = [String](airports.keys)
// airportCodes теперь ["YYZ", "LHR"]
let airportNames = [String](airports.values)
// airportNames теперь ["Toronto Pearson", "London Heathrow"]
Тип словаря в Swift является неупорядоченной коллекцией. Для итерации по ключам или значениям словаря в определенной последовательности, используйте метод sorted() для свойств keys или values словаря.
Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите Ctrl+Enter.
Строки и символы
Управление потоком
 
SwiftBook Самое крупное сообщество iOS разработчиков на языке Swift
О нас
Мы в социальных сетяхYouTubeVKontakteFacebookЧат_Telegram
instagramПолезноеPodlodka
Подпишись на новости 
   Политика конфиденциальности
Пользовательское соглашение
Найти:
  © Акулов И.Б., 2014-2021      
 
Сообщить об опечатке
Текст, который будет отправлен нашим редакторам:
Ваш комментарий (необязательно):
Отправить
Отмена