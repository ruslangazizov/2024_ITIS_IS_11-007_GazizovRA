Документация — SwiftBook
https://swiftbook.ru
	Обучение программированию на Swift
Wed, 15 Nov 2023 11:44:23 +0300
ru-RU
	hourly	
	1	
https://wordpress.org/?v=5.2.5
Согласованность
https://swiftbook.ru/content/languageguide/concurrency/
				https://swiftbook.ru/content/languageguide/concurrency/#respond
Tue, 29 Jun 2021 11:35:26 +0000
swiftbook
https://swiftbook.ru/?post_type=manual_documentation&p=27030
<p>Swift имеет встроенную поддержку для структурированного написания асинхронного и параллельного кода. Асинхронный код можно приостановить и возобновить позже, хотя одновременно выполняется только одна часть программы. Приостановка и возобновление кода в вашей программе позволяет ей продолжать выполнять краткосрочные операции, такие как обновление пользовательского интерфейса, при этом продолжая работать над длительными операциями, такими как выборка данных по [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/concurrency/">Согласованность</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p>Swift имеет встроенную поддержку для структурированного написания асинхронного и параллельного кода. Асинхронный код можно приостановить и возобновить позже, хотя одновременно выполняется только одна часть программы. Приостановка и возобновление кода в вашей программе позволяет ей продолжать выполнять краткосрочные операции, такие как обновление пользовательского интерфейса, при этом продолжая работать над длительными операциями, такими как выборка данных по сети или анализ файлов. Параллельный код означает одновременное выполнение нескольких фрагментов кода - например, компьютер с четырехъядерным процессором может одновременно запускать четыре фрагмента кода, при этом каждое ядро ​​выполняет одну из задач. Программа, использующая параллельный и асинхронный код, одновременно выполняет несколько операций; он приостанавливает операции, ожидающие выполнения внешней системой, и упрощает написание этого кода безопасным для памяти способом.</p>
<p>Дополнительная гибкость планирования за счет параллельного или асинхронного кода также связана с увеличением сложности. Swift позволяет вам выразить свое намерение таким образом, чтобы включить некоторые проверки во время компиляции - например, вы можете использовать акторы для безопасного доступа к изменяемому состоянию. Однако добавление параллелизма к медленному или ошибочному коду не является гарантией того, что он станет быстрым или правильным. Фактически, добавление параллелизма может даже затруднить отладку вашего кода. Однако использование поддержки Swift на уровне языка для параллелизма в коде, который должен быть параллельным, означает, что Swift может помочь вам выявить проблемы во время компиляции.</p>
<p>В остальной части этой главы термин параллелизм используется для обозначения этой общей комбинации асинхронного и параллельного кода.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Если вы раньше писали параллельный код, возможно, вы привыкли работать с потоками. Модель параллелизма в Swift построена на основе потоков, но вы не взаимодействуете с ними напрямую. Асинхронная функция в Swift может отказаться от потока, в котором она выполняется, что позволяет другой асинхронной функции работать в этом потоке, пока первая функция заблокирована.</p>
</div>
<p>Хотя можно писать параллельный код без использования языковой поддержки Swift, этот код, как правило, труднее читать. Например, следующий код загружает список имен фотографий, загружает первую фотографию в этом списке и показывает эту фотографию пользователю:</p>
<pre><code class="language-swift">listPhotos(inGallery: "Summer Vacation") { photoNames in
    let sortedNames = photoNames.sorted()
    let name = sortedNames[1]
    downloadPhoto(named: name) { photo in
        show(photo)
    }
}</code></pre>
<p>Даже в этом простом случае, из-за того, что код должен быть написан в виде последовательности завершающих обработчиков, вы в конечном итоге пишете вложенные замыкания. В этом стиле более сложный код с глубокой вложенностью может быстро стать громоздким.</p>
<h2>Определение и вызов асинхронных функций</h2>
<p><em>Асинхронная функция</em> или <em>асинхронный метод</em> - это особый вид функции или метода, которые можно приостановить на полпути выполнения. Это отличается от обычных синхронных функций и методов, которые либо выполняются до завершения, либо вызывают ошибку, либо никогда не возвращаются. Асинхронная функция или метод по-прежнему выполняет одно из этих трех действий, но может также останавливаться посередине, когда чего-то ожидает. Внутри тела асинхронной функции или метода вы отмечаете каждое из этих мест, где выполнение может быть приостановлено.</p>
<p>Чтобы указать, что функция или метод является асинхронным, вы пишете ключевое слово <span class="inline-pre">async</span> в его объявлении после его параметров, аналогично тому, как вы используете <span class="inline-pre">throws</span> для отметки функции с исключением. Если функция или метод возвращает значение, вы пишете async перед стрелкой возврата (<span class="inline-pre">-&gt;</span>). Например, вот как можно получить имена фотографий в галерее:</p>
<pre><code class="language-swift">func listPhotos(inGallery name: String) async -&gt; [String] {
    let result = // ... some asynchronous networking code ...
    return result
}</code></pre>
<p>Для функции или метода, которые одновременно являются как асинхронными, так и исключающими (<span class="inline-pre">throws</span>), вы пишете <span class="inline-pre">async</span> перед <span class="inline-pre">throws</span>.</p>
<p>При вызове асинхронного метода выполнение приостанавливается до тех пор, пока этот метод не вернется. Вы пишете <span class="inline-pre">await</span> перед вызовом, чтобы отметить возможную точку приостановки. Это похоже на запись try при вызове бросающей функции, чтобы отметить возможное изменение потока программы в случае ошибки. Внутри асинхронного метода поток выполнения приостанавливается только тогда, когда вы вызываете другой асинхронный метод - приостановка никогда не бывает неявной или упреждающей - это означает, что каждая возможная точка приостановки помечается с помощью <span class="inline-pre">await</span>.</p>
<p>Например, приведенный ниже код извлекает имена всех изображений в галерее, а затем показывает первое изображение:</p>
<pre><code class="language-swift">let photoNames = await listPhotos(inGallery: "Summer Vacation")
let sortedNames = photoNames.sorted()
let name = sortedNames[1]
let photo = await downloadPhoto(named: name)
show(photo)</code></pre>
<p>Поскольку обе функции <span class="inline-pre">listPhotos(inGallery :)</span> и <span class="inline-pre">downloadPhoto(named :)</span> должны выполнять сетевые запросы, их выполнение может занять относительно много времени. Делая их асинхронными, записывая async перед стрелкой возврата, позволяет остальной части кода приложения продолжать работу, пока этот код ожидает завершения.</p>
<p>Чтобы понять параллельный характер приведенного выше примера, вот один из возможных порядков выполнения:</p>
<ol>
<li>Код запускается с первой строки и доходит до первого await. Он вызывает функцию<span class="inline-pre"> listPhotos(inGallery :)</span> и приостанавливает выполнение, пока ожидает возврата этой функции.</li>
<li>Пока выполнение этого кода приостановлено, выполняется другой параллельный код в той же программе. Например, может быть, длительная фоновая задача продолжает обновлять список новых фото. Этот код также выполняется до следующей точки приостановки, отмеченной как <span class="inline-pre">await</span>, или до ее завершения.</li>
<li>После возврата из<span class="inline-pre"> listPhotos(inGallery :)</span> этот код продолжает выполнение, начиная с этой точки. Он присваивает значение, которое было возвращено <span class="inline-pre">photoNames</span>.</li>
<li>Строки, определяющие <span class="inline-pre">sortedNames</span> и <span class="inline-pre">name</span>, представляют собой обычный синхронный код. Поскольку на этих строках ничего не отмечено ожиданием, нет никаких возможных точек приостановки.</li>
<li>Следующее ожидание отмечает вызов функции <span class="inline-pre">downloadPhoto(named :)</span>. Этот код снова приостанавливает выполнение до тех пор, пока функция не вернется, давая возможность другому параллельному коду работать.</li>
<li>После возврата<span class="inline-pre"> downloadPhoto(named :) </span>его возвращаемое значение присваивается фото и затем передается в качестве аргумента при вызове <span class="inline-pre">show(_ :)</span>.</li>
</ol>
<p>Возможные точки приостановки в вашем коде, отмеченные значком <span class="inline-pre">await</span>, указывают на то, что текущий фрагмент кода может приостановить выполнение, ожидая возврата асинхронной функции или метода. Это также называется уступкой потока, потому что за кулисами Swift приостанавливает выполнение вашего кода в текущем потоке и вместо этого запускает другой код в этом потоке. Поскольку код с <span class="inline-pre">await</span> должен иметь возможность приостанавливать выполнение, только определенные места в вашей программе могут вызывать асинхронные функции или методы:</p>
<ul>
<li>Код в теле асинхронной функции, метода или свойства.</li>
<li>Код в статическом методе <span class="inline-pre">main()</span> структуры, класса или перечисления, помеченных <span class="inline-pre">@main</span>.</li>
<li>Код в отдельной дочерней задаче, как показано в разделе «<a href="#unscturcted-concurrency">Неструктурированный параллелизм</a>» ниже.</li>
</ul>
<div class="tip">
<h4>Заметка</h4>
<p>Метод <a href="https://developer.apple.com/documentation/swift/task/3814836-sleep">Task.sleep(_ :)</a> полезен при написании простого кода, чтобы узнать, как работает параллелизм. Этот метод ничего не делает, но ждет, по крайней мере, заданное количество наносекунд, прежде чем он вернется. Вот версия функции <span class="inline-pre">listPhotos(inGallery :)</span>, которая использует <span class="inline-pre">sleep()</span> для имитации ожидания сетевой операции:</p>
<pre><code class="language-swift">func listPhotos(inGallery name: String) async -&gt; [String] {
    await Task.sleep(2 * 1_000_000_000)  // Two seconds
    return ["IMG001", "IMG99", "IMG0404"]
}</code></pre>
</div>
<h2>Асинхронные последовательности</h2>
<p>Функция<span class="inline-pre"> listPhotos(inGallery :) </span>в предыдущем разделе асинхронно возвращает весь массив сразу после того, как все элементы массива готовы. Другой подход - дождаться одного элемента коллекции за раз, используя асинхронную последовательность. Вот как выглядит итерация асинхронной последовательности:</p>
<pre><code class="language-swift">import Foundation
let handle = FileHandle.standardInput
for try await line in handle.bytes.lines {
    print(line)
}</code></pre>
<p>Вместо использования обычного цикла <span class="inline-pre">for</span>-<span class="inline-pre">in</span> в приведенном выше примере записывается <span class="inline-pre">for</span> с <span class="inline-pre">await</span> после него. Как и при вызове асинхронной функции или метода, запись <span class="inline-pre">await</span> указывает на возможную точку приостановки. Цикл <span class="inline-pre">for</span>-<span class="inline-pre">await</span>-<span class="inline-pre">in</span> потенциально приостанавливает выполнение в начале каждой итерации, когда он ожидает, когда будет доступен следующий элемент.</p>
<p>Точно так же, как вы можете использовать свои собственные типы в цикле <span class="inline-pre">for</span>-<span class="inline-pre">in</span>, добавив соответствие протоколу <a href="https://developer.apple.com/documentation/swift/sequence"><span class="inline-pre">Sequence</span></a>, вы можете использовать свои собственные типы в цикле <span class="inline-pre">for</span>-<span class="inline-pre">await</span>-<span class="inline-pre">in</span>, добавив соответствие протоколу <a href="https://developer.apple.com/documentation/swift/asyncsequence"><span class="inline-pre">AsyncSequence</span></a>.</p>
<h2>Параллельный вызов асинхронных функций</h2>
<p>Вызов асинхронной функции с помощью <span class="inline-pre">await</span> запускает только один фрагмент кода за раз. Пока выполняется асинхронный код, вызывающая сторона ожидает завершения этого кода, прежде чем перейти к выполнению следующей строки кода. Например, чтобы получить первые три фотографии из галереи, вы можете дождаться трех вызовов функции <span class="inline-pre">downloadPhoto(named :)</span> следующим образом:</p>
<pre><code class="language-swift">let firstPhoto = await downloadPhoto(named: photoNames[0])
let secondPhoto = await downloadPhoto(named: photoNames[1])
let thirdPhoto = await downloadPhoto(named: photoNames[2])
let photos = [firstPhoto, secondPhoto, thirdPhoto]
show(photos)</code></pre>
<p>У этого подхода есть важный недостаток: несмотря на то, что загрузка является асинхронной и позволяет выполнять другую работу во время ее выполнения, одновременно выполняется только один вызов функции <span class="inline-pre">downloadPhoto(named :)</span>. Каждая фотография полностью загружается до начала загрузки следующей. Однако этим операциям не нужно ждать - каждую фотографию можно загружать независимо или даже одновременно.</p>
<p>Чтобы вызвать асинхронную функцию и позволить ей работать параллельно с кодом вокруг нее, напишите <span class="inline-pre">async</span> перед <span class="inline-pre">let</span> при определении константы, а затем напишите <span class="inline-pre">await</span> каждый раз, когда вы используете константу.</p>
<pre><code class="language-swift">async let firstPhoto = downloadPhoto(named: photoNames[0])
async let secondPhoto = downloadPhoto(named: photoNames[1])
async let thirdPhoto = downloadPhoto(named: photoNames[2])
let photos = await [firstPhoto, secondPhoto, thirdPhoto]
show(photos)</code></pre>
<p>В этом примере все три вызова <span class="inline-pre">downloadPhoto(named :)</span> запускаются без ожидания завершения предыдущего. Если доступно достаточно системных ресурсов, они могут работать одновременно. Ни один из этих вызовов функций не помечен как <span class="inline-pre">await</span>, потому что код не приостанавливается в ожидании результата функции. Вместо этого выполнение продолжается до тех пор, пока не будет определена строка, в которой определены фотографии - в этот момент программе требуются результаты этих асинхронных вызовов, поэтому вы пишете <span class="inline-pre">await</span>, чтобы приостановить выполнение, пока не завершится загрузка всех трех фотографий.</p>
<p>Вот как вы можете подумать о различиях между этими двумя подходами:</p>
<ul>
<li>Вызов асинхронных функций с помощью <span class="inline-pre">await</span>, когда код в следующих строках зависит от результата этой функции. Это создает работу, которая выполняется последовательно.</li>
<li>Вызывайте асинхронные функции с помощью <span class="inline-pre">async</span>-<span class="inline-pre">let</span>, если вам не нужен результат до тех пор, пока не появится код. Это создает работу, которую можно выполнять параллельно.</li>
<li>Оба <span class="inline-pre">await</span> и <span class="inline-pre">async</span>-<span class="inline-pre">let</span> позволяют запускать другой код, пока они приостановлены.</li>
<li>В обоих случаях вы отмечаете возможную точку приостановки с помощью <span class="inline-pre">await</span>, чтобы указать, что выполнение будет приостановлено, если необходимо, до тех пор, пока асинхронная функция не вернется.</li>
</ul>
<p>Вы также можете смешать оба этих подхода в одном коде.</p>
<h2>Задачи и группы задач</h2>
<p>Задача - это единица работы, которая может выполняться асинхронно как часть вашей программы. Весь асинхронный код выполняется как часть некоторой задачи. Синтаксис <span class="inline-pre">async</span>-<span class="inline-pre">let</span>, описанный в предыдущем разделе, создает для вас дочернюю задачу. Вы также можете создать группу задач и добавить в нее дочерние задачи, что дает вам больше контроля над приоритетом и отменой, а также позволяет создавать динамическое количество задач.</p>
<p>Задачи расположены в иерархии. Каждая задача в группе задач имеет одну и ту же родительскую задачу, и каждая задача может иметь дочерние задачи. Из-за явной взаимосвязи между задачами и группами задач этот подход называется структурированным параллелизмом. Хотя вы берете на себя часть ответственности за правильность, явные родительско-дочерние отношения между задачами позволяют Swift обрабатывать некоторые действия, такие как распространение отмены, и позволяет Swift обнаруживать некоторые ошибки во время компиляции.</p>
<pre><code class="language-swift">await withTaskGroup(of: Data.self) { taskGroup in
    let photoNames = await listPhotos(inGallery: "Summer Vacation")
    for name in photoNames {
        taskGroup.async { await downloadPhoto(named: name) }
    }
}</code></pre>
<p>Дополнительные сведения о группах задач см. в разделе <a href="https://developer.apple.com/documentation/swift/taskgroup">TaskGroup</a>.</p>
<h2>Неструктурированный параллелизм</h2>
<p>В дополнение к структурированным подходам к параллелизму, описанным в предыдущих разделах, Swift также поддерживает неструктурированный параллелизм. В отличие от задач, которые являются частью группы задач, неструктурированная задача не имеет родительской задачи. У вас есть полная гибкость для управления неструктурированными задачами любым способом, который требуется вашей программе, но вы также несете полную ответственность за их правильность. Чтобы создать неструктурированную задачу, выполняемую текущим актором, вызовите функцию <a href="https://developer.apple.com/documentation/swift/3816404-async"><span class="inline-pre">async(priority: operation :)</span></a>. Чтобы создать неструктурированную задачу, которая не является частью текущего актора, более конкретно называемую отдельной задачей, вызовите <a href="https://developer.apple.com/documentation/swift/3816406-asyncdetached"><span class="inline-pre">asyncDetached(priority: operation :)</span></a>. Обе эти функции возвращают дескриптор задачи, который позволяет вам взаимодействовать с задачей, например, дождаться ее результата или отменить его.</p>
<pre><code class="language-swift">let newPhoto = // ... какие-то данные по фото ...
let handle = async {
    return await add(newPhoto, toGalleryNamed: "Spring Adventures")
}
let result = await handle.get()</code></pre>
<p>Дополнительные сведения об управлении отключенными задачами см. в разделе <a href="https://developer.apple.com/documentation/swift/task/handle">Task.Handle</a>.</p>
<h2>Отмена задачи</h2>
<p>Параллелизм в Swift использует кооперативную модель отмены. Каждая задача проверяет, была ли она отменена в соответствующие моменты ее выполнения, и реагирует на отмену любым подходящим способом. В зависимости от выполняемой вами работы это обычно означает одно из следующего:</p>
<ul>
<li>Выдает ошибку, например <span class="inline-pre">CancellationError</span></li>
<li>Возврат nil или пустой коллекции</li>
<li>Возврат частично выполненной работы</li>
</ul>
<p>Чтобы проверить отмену, либо вызовите <a href="https://developer.apple.com/documentation/swift/task/3814826-checkcancellation">Task.checkCancellation()</a>, который выбрасывает <span class="inline-pre">CancellationError</span>, если задача была отменена, либо проверьте значение <a href="https://developer.apple.com/documentation/swift/task/3814832-iscancelled">Task.isCancelled</a> и обработайте отмену в своем собственном коде. Например, для задачи загрузки фотографий из галереи может потребоваться удалить частичные загрузки и закрыть сетевые подключения.</p>
<p>Чтобы распространить отмену вручную, вызовите <a href="https://developer.apple.com/documentation/swift/task/handle/3814781-cancel">Task.Handle.cancel()</a>.</p>
<h2>Акторы</h2>
<p>Как и классы, акторы являются ссылочными типами, поэтому сравнение типов значений и ссылочных типов в разделе «<a href="https://swiftbook.ru/content/languageguide/classes-and-structures/#classes-are-reference-types">Классы являются ссылочными типами</a>» применяется как к акторам, так и к классам. В отличие от классов, акторы позволяют только одной задаче получать доступ к своему изменяемому состоянию за раз, что делает безопасным взаимодействие кода в нескольких задачах с одним и тем же экземпляром актора. Например, вот актор, который записывает температуру:</p>
<pre><code class="language-swift">actor TemperatureLogger {
    let label: String
    var measurements: [Int]
    private(set) var max: Int
    init(label: String, measurement: Int) {
        self.label = label
        self.measurements = [measurement]
        self.max = measurement
    }
}</code></pre>
<p>Вы вводите актора с ключевым словом <span class="inline-pre">actor</span>, за которым следует его определение в фигурных скобках. Актор <span class="inline-pre">TemperatureLogger</span> имеет свойства, к которым может получить доступ другой код за пределами актора, и ограничивает свойство <span class="inline-pre">max</span>, поэтому только код внутри актора может обновлять максимальное значение.</p>
<p>Вы создаете экземпляр актора, используя тот же синтаксис инициализатора, что и структуры и классы. Когда вы обращаетесь к свойству или методу актора, вы используете <span class="inline-pre">await</span>, чтобы отметить потенциальную точку приостановки, например:</p>
<pre><code class="language-swift">let logger = TemperatureLogger(label: "Outdoors", measurement: 25)
print(await logger.max)
// Выведет "25"</code></pre>
<p>В этом примере доступ к <span class="inline-pre">logger.max</span> является возможной точкой приостановки. Поскольку субъект позволяет только одной задаче одновременно получать доступ к своему изменяемому состоянию, если код из другой задачи уже взаимодействует с регистратором, этот код приостанавливается, пока он ожидает доступа к свойству.</p>
<p>Напротив, код, который является частью актора, не записывает ожидание при доступе к свойствам актора. Например, вот метод, который обновляет <span class="inline-pre">TemperatureLogger</span> с новой температурой:</p>
<pre><code class="language-swift">extension TemperatureLogger {
    func update(with measurement: Int) {
        measurements.append(measurement)
        if measurement &gt; max {
            max = measurement
        }
    }
}</code></pre>
<p>Метод <span class="inline-pre">update(with :)</span> уже запущен для актора, поэтому он не отмечает его доступ к таким свойствам, как max, с помощью <span class="inline-pre">await</span>. Этот метод также показывает одну из причин, по которой акторы позволяют одновременно взаимодействовать со своим изменяемым состоянием только одной задаче: некоторые обновления состояния актора временно нарушают инварианты. Актор <span class="inline-pre">TemperatureLogger</span> отслеживает список температур и максимальную температуру, а также обновляет максимальную температуру при записи нового измерения. В середине обновления, после добавления нового измерения, но перед обновлением max, регистратор температуры находится во временном несогласованном состоянии. Предотвращение одновременного взаимодействия нескольких задач с одним и тем же экземпляром предотвращает такие проблемы, как следующая последовательность событий:</p>
<p>Ваш код вызывает метод <span class="inline-pre">update(with :)</span>. Сначала он обновляет массив измерений.<br />
Прежде чем ваш код сможет обновить <span class="inline-pre">max</span>, код в другом месте считывает максимальное значение и массив температур.<br />
Ваш код завершает обновление, изменяя max.<br />
В этом случае код, запущенный в другом месте, будет читать неверную информацию, потому что его доступ к актору чередовался в середине вызова <span class="inline-pre">update(with :)</span>, в то время как данные были временно недействительными. Вы можете предотвратить эту проблему при использовании акторов Swift, потому что они разрешают только одну операцию над своим состоянием за раз и потому, что этот код может быть прерван только в тех местах, где ожидание отмечает точку приостановки. Поскольку <span class="inline-pre">update(with :)</span> не содержит точек приостановки, никакой другой код не может получить доступ к данным в середине обновления.</p>
<p>Если вы попытаетесь получить доступ к этим свойствам извне актора, как в случае с экземпляром класса, вы получите ошибку компиляции. Например:</p>
<pre><code class="language-swift">print(logger.max)  // Ошибка</code></pre>
<p>Доступ к <span class="inline-pre">logger.max</span> без записи <span class="inline-pre">await</span> завершается ошибкой, поскольку свойства субъекта являются частью изолированного локального состояния этого субъекта. Swift гарантирует, что только код внутри актора может получить доступ к локальному состоянию актора. Эта гарантия известна как изоляция актора.</p>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/error-handling" rel="8812">Обработка ошибок</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/type-casting" rel="8813">Приведение типов</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/concurrency/">Согласованность</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
https://swiftbook.ru/content/languageguide/concurrency/feed/
0
Непрозрачные типы
https://swiftbook.ru/content/languageguide/opaque-types/
				https://swiftbook.ru/content/languageguide/opaque-types/#respond
Mon, 28 Jun 2021 11:39:14 +0000
swiftbook
https://swiftbook.ru/?post_type=manual_documentation&p=26999
<p>Функция или метод с непрозрачным типом возвращаемого значения скрывает информацию о типе своего возвращаемого значения. Вместо того, чтобы указывать конкретный тип в качестве типа возвращаемого значения функции, возвращаемое значение описывается в терминах поддерживаемых им протоколов. Сокрытие информации о типе полезно на границах между модулем и кодом, который вызывает модуль, поскольку базовый тип возвращаемого значения может [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/opaque-types/">Непрозрачные типы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p>Функция или метод с непрозрачным типом возвращаемого значения скрывает информацию о типе своего возвращаемого значения. Вместо того, чтобы указывать конкретный тип в качестве типа возвращаемого значения функции, возвращаемое значение описывается в терминах поддерживаемых им протоколов. Сокрытие информации о типе полезно на границах между модулем и кодом, который вызывает модуль, поскольку базовый тип возвращаемого значения может оставаться закрытым. В отличие от возврата значения, тип которого является типом протокола, непрозрачные типы сохраняют идентичность типа - компилятор имеет доступ к информации о типе, но клиенты модуля - нет.</p>
<h2>Проблема, которую решают непрозрачные типы</h2>
<p>Предположим, что вы пишете модуль, который рисует фигуры в формате ASCII. Основной характеристикой фигуры ASCII art является функция <span class="inline-pre">draw()</span>, которая возвращает строковое представление этой фигуры, которое вы можете использовать в качестве требования для протокола <span class="inline-pre">Shape</span>:</p>
<pre><code class="language-swift">protocol Shape {
    func draw() -&gt; String
}
struct Triangle: Shape {
    var size: Int
    func draw() -&gt; String {
        var result: [String] = []
        for length in 1...size {
            result.append(String(repeating: "*", count: length))
        }
        return result.joined(separator: "\n")
    }
}
let smallTriangle = Triangle(size: 3)
print(smallTriangle.draw())
// *
// **
// ***</code></pre>
<p>Вы можете использовать универсальные шаблоны для реализации таких операций, как вертикальное переворачивание фигуры, как показано в приведенном ниже коде. Однако у этого подхода есть важное ограничение: перевернутый результат показывает точные универсальные типы, которые использовались для его создания.</p>
<pre><code class="language-swift">struct FlippedShape&lt;T: Shape&gt;: Shape {
    var shape: T
    func draw() -&gt; String {
        let lines = shape.draw().split(separator: "\n")
        return lines.reversed().joined(separator: "\n")
    }
}
let flippedTriangle = FlippedShape(shape: smallTriangle)
print(flippedTriangle.draw())
// ***
// **
// *</code></pre>
<p>Этот подход к определению структуры <span class="inline-pre">JoinedShape&lt;T: Shape, U: Shape&gt;</span>, которая объединяет две фигуры вместе по вертикали, как показано в приведенном ниже коде, приводит к таким типам, как <span class="inline-pre">JoinedShape&lt;FlippedShape &lt;Triangle&gt;, Triangle&gt;</span>, от соединения перевернутого треугольника с другим треугольником.</p>
<pre><code class="language-swift"><span class="k">struct</span> <span class="nv">JoinedShape</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>, <span class="nv">U</span>: <span class="nc">Shape</span>&gt;: <span class="nc">Shape</span> {
    var top: T
    var bottom: U
    func draw() -&gt; String {
        return top.draw() + "\n" + bottom.draw()
    }
}
let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)
print(joinedTriangles.draw())
// *
// **
// ***
// ***
// **
// *</code></pre>
<p>Предоставление подробной информации о создании формы позволяет типам, которые не предназначены для использования в общедоступном интерфейсе художественного модуля ASCII, просачиваться наружу из-за необходимости указывать полный тип возвращаемого значения. Код внутри модуля может создавать одну и ту же форму различными способами, и другой код вне модуля, который использует эту форму, не должен учитывать детали реализации списка преобразований. Оберточные типы, такие как <span class="inline-pre">JoinedShape</span> и <span class="inline-pre">FlippedShape</span>, не имеют значения для пользователей модуля и не должны быть видны. Открытый интерфейс модуля состоит из таких операций, как соединение и отражение фигуры, и эти операции возвращают другое значение <span class="inline-pre">Shape</span>.</p>
<h2>Возвращение непрозрачного типа</h2>
<p>Вы можете думать о непрозрачном типе как о противоположности универсального типа. Универсальные типы позволяют коду, вызывающему функцию, выбирать тип для параметров этой функции и возвращать значение таким образом, чтобы абстрагироваться от реализации функции. Например, функция в следующем коде возвращает тип, зависящий от вызывающего ее кода:</p>
<pre><code class="language-swift">func max(_ x: T, _ y: T) -&gt; T where T: Comparable { ... }</code></pre>
<p>Код, вызывающий <span class="inline-pre">max(_: _ :)</span>, выбирает значения для <span class="inline-pre">x</span> и <span class="inline-pre">y</span>, и тип этих значений определяет конкретный тип <span class="inline-pre">T</span>. Вызывающий код может использовать любой тип, соответствующий протоколу <span class="inline-pre">Comparable</span>. Код внутри функции написан в общем виде, поэтому он может обрабатывать любой тип, который предоставляет вызывающий. Реализация <span class="inline-pre">max(_: _ :)</span> использует только функциональные возможности, общие для всех типов <span class="inline-pre">Comparable</span>.</p>
<p>Эти роли меняются местами для функции с непрозрачным возвращаемым типом. Непрозрачный тип позволяет реализации функции выбирать тип для возвращаемого значения таким образом, чтобы абстрагироваться от кода, вызывающего функцию. Например, функция в следующем примере возвращает трапецию, не раскрывая базовый тип этой формы.</p>
<pre><code class="language-swift">struct Square: Shape {
    var size: Int
    func draw() -&gt; String {
        let line = String(repeating: "*", count: size)
        let result = Array(repeating: line, count: size)
        return result.joined(separator: "\n")
    }
}
func makeTrapezoid() -&gt; some Shape {
    let top = Triangle(size: 2)
    let middle = Square(size: 2)
    let bottom = FlippedShape(shape: top)
    let trapezoid = JoinedShape(
        top: top,
        bottom: JoinedShape(top: middle, bottom: bottom)
    )
    return trapezoid
}
let trapezoid = makeTrapezoid()
print(trapezoid.draw())
// *
// **
// **
// **
// **
// *</code></pre>
<p>Функция <span class="inline-pre">makeTrapezoid()</span> в этом примере объявляет свой возвращаемый тип как некоторую форму; в результате функция возвращает значение некоторого заданного типа, которое соответствует протоколу <span class="inline-pre">Shape</span>, без указания какого-либо конкретного типа. Такой способ написания <span class="inline-pre">makeTrapezoid()</span> позволяет выразить фундаментальный аспект своего публичного интерфейса - значение, которое оно возвращает, является формой - без создания конкретных типов, которые создаются на основе части публичного интерфейса. В этой реализации используются два треугольника и квадрат, но функцию можно переписать для рисования трапеции множеством других способов без изменения ее возвращаемого типа.</p>
<p>В этом примере показано, как непрозрачный возвращаемый тип похож на обратный тип универсального типа. Код внутри <span class="inline-pre">makeTrapezoid()</span> может возвращать любой тип, который ему нужен, если этот тип соответствует протоколу <span class="inline-pre">Shape</span>, как вызывающий код для универсальной функции. Код, вызывающий функцию, должен быть написан в общем виде, как реализация универсальной функции, чтобы он мог работать с любым значением <span class="inline-pre">Shape</span>, возвращаемым <span class="inline-pre">makeTrapezoid()</span>.</p>
<p>Вы также можете комбинировать непрозрачные возвращаемые типы с универсальными. Обе функции в следующем коде возвращают значение некоторого типа, соответствующего протоколу <span class="inline-pre">Shape</span>.</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">flip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
    return FlippedShape(shape: shape)
}
func join(_ top: T, _ bottom: U) -&gt; some Shape {
    JoinedShape(top: top, bottom: bottom)
}
let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))
print(opaqueJoinedTriangles.draw())
// *
// **
// ***
// ***
// **
// *</code></pre>
<p>Значение <span class="inline-pre">opaqueJoinedTriangles</span> в этом примере такое же, как и <span class="inline-pre">connectedTriangles</span> в примере универсальных шаблонов в разделе «Проблема, которую решают непрозрачные типы» ранее в этой главе. Однако, в отличие от значения в этом примере, функции <span class="inline-pre">flip(_ :)</span> и <span class="inline-pre">join(_: _ :)</span> заключают в оболочку базовые типы, возвращаемые операциями универсальной формы, в непрозрачный тип возвращаемого значения, что предотвращает отображение этих типов. Обе функции являются универсальными, поскольку типы, на которые они опираются, являются универсальными, а параметры типа функции передают информацию о типе, необходимую для <span class="inline-pre">FlippedShape</span> и <span class="inline-pre">JoinedShape</span>.</p>
<p>Если функция с возвращаемым непрозрачным типом возвращается из нескольких мест, все возможные возвращаемые значения должны иметь один и тот же тип. Для универсальной функции этот возвращаемый тип может использовать параметры универсального типа функции, но он все равно должен быть одного типа. Например, вот недопустимая версия функции переворота формы, которая включает специальный случай для квадратов:</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">invalidFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
    if shape is Square {
        return shape // Ошибка: несоответсвующий возвращаемый тип
    }
    return FlippedShape(shape: shape) // Ошибка: несоответсвующий возвращаемый тип
}</code></pre>
<p>Если вы вызываете эту функцию с помощью <span class="inline-pre">Square</span>, она возвращает <span class="inline-pre">Square</span>; в противном случае она возвращает <span class="inline-pre">FlippedShape</span>. Это нарушает требование возвращать значения только одного типа и делает код <span class="inline-pre">invalidFlip(_ :)</span> недопустимым. Один из способов исправить<span class="inline-pre"> invalidFlip(_ :) </span>- переместить специальный случай для квадратов в реализацию<span class="inline-pre"> FlippedShape</span>, которая позволяет этой функции всегда возвращать значение <span class="inline-pre">FlippedShape</span>:</p>
<pre><code class="language-swift">struct FlippedShape&lt;T: Shape&gt;: Shape
    var shape: T
    func draw() -&gt; String {
        if shape is Square {
            return shape.draw()
        }
        let lines = shape.draw().split(separator: "\n")
        return lines.reversed().joined(separator: "\n")
    }
}</code></pre>
<p>Требование всегда возвращать один тип не мешает вам использовать универсальные шаблоны в непрозрачном возвращаемом типе. Вот пример функции, которая включает параметр типа в базовый тип возвращаемого значения:</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">`repeat`</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="nv">shape</span>: <span class="nc">T</span>, <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">some</span> <span class="nv">Collection</span> {
    return Array(repeating: shape, count: count)
}</code></pre>
<p>В этом случае базовый тип возвращаемого значения зависит от <span class="inline-pre">T</span>: какая бы фигура ни была передана, <span class="inline-pre">repeat(shape: count :)</span> создает и возвращает массив этой формы. Тем не менее, возвращаемое значение всегда имеет один и тот же базовый тип <span class="inline-pre">[T]</span>, поэтому следует требование, чтобы функции с непрозрачными типами возврата должны возвращать значения только одного типа.</p>
<h2>Различия между типом протокола и непрозрачным типом</h2>
<p>Возврат непрозрачного типа очень похож на использование типа протокола в качестве типа возвращаемого значения функции, но эти два вида возвращаемого типа различаются тем, что по-разному работают с идентичностью типа. Непрозрачный тип относится к одному конкретному типу, хотя вызывающая функция не может видеть конкретно что это за тип. Тип протокола может относиться к любому типу, который соответствует протоколу. Вообще говоря, типы протоколов дают вам больше гибкости в отношении базовых типов значений, которые они хранят, а непрозрачные типы позволяют вам делать более строгие гарантии в отношении этих базовых типов.</p>
<p>Например, вот версия <span class="inline-pre">protoFlip(_ :)</span>, которая использует тип протокола в качестве возвращаемого типа вместо непрозрачного типа возврата:</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">protoFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">Shape</span> {
    return FlippedShape(shape: shape)
}</code></pre>
<p>Эта версия <span class="inline-pre">protoFlip(_ :)</span> имеет то же тело, что и <span class="inline-pre">flip(_ :)</span>, и всегда возвращает значение того же типа. В отличие от <span class="inline-pre">flip(_ :)</span>, значение, которое возвращает <span class="inline-pre">protoFlip(_ :)</span>, не обязательно должно всегда иметь один и тот же тип - оно просто должно соответствовать протоколу <span class="inline-pre">Shape</span>. Другими словами, <span class="inline-pre">protoFlip(_ :)</span> делает гораздо более свободный контракт API со своим вызывающим, чем <span class="inline-pre">flip(_ :)</span>. Эта функция оставляет за собой возможность возвращать значения нескольких типов:</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">protoFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">Shape</span> {
    if shape is Square {
        return shape
    }
    return FlippedShape(shape: shape)
}</code></pre>
<p>Обновленная версия кода возвращает экземпляр <span class="inline-pre">Square</span> или экземпляр <span class="inline-pre">FlippedShape</span>, в зависимости от того, какая фигура передана. Две перевернутые фигуры, возвращаемые этой функцией, могут иметь совершенно разные типы. Другие допустимые версии этой функции могут возвращать значения разных типов при отражении нескольких экземпляров одной и той же формы. Менее конкретная информация о типе возвращаемого значения из <span class="inline-pre">protoFlip(_ :)</span> означает, что многие операции, зависящие от информации о типе, недоступны для возвращаемого значения. Например, невозможно написать оператор <span class="inline-pre">==</span> для сравнения результатов, возвращаемых этой функцией.</p>
<pre><code class="language-swift">let protoFlippedTriangle = protoFlip(smallTriangle)
let sameThing = protoFlip(smallTriangle)
protoFlippedTriangle == sameThing  // Ошибка</code></pre>
<p>Ошибка в последней строке примера возникает по нескольким причинам. Непосредственная проблема заключается в том, что <span class="inline-pre">Shape</span> не включает оператор <span class="inline-pre">==</span> как часть требований протокола. Если вы попытаетесь добавить его, то следующая проблема, с которой вы столкнетесь, заключается в том, что оператору <span class="inline-pre">==</span> необходимо знать типы своих левых и правых аргументов. Операторы такого типа обычно принимают аргументы типа <span class="inline-pre">Self</span>, соответствующие любому конкретному типу, принимающему протокол, но добавление к протоколу требования <span class="inline-pre">Self</span> не допускает "стирание" типа, которое происходит, когда вы используете протокол как тип.</p>
<p>Использование типа протокола в качестве типа возвращаемого значения для функции дает вам возможность возвращать любой тип, соответствующий протоколу. Однако цена такой гибкости заключается в том, что некоторые операции с возвращаемыми значениями невозможны. В примере показано, что оператор <span class="inline-pre">==</span> недоступен - это зависит от конкретной информации о типе, которая не сохраняется при использовании типа протокола.</p>
<p>Еще одна проблема с этим подходом заключается в том, что преобразования формы не вкладываются. Результатом переворота треугольника является значение типа <span class="inline-pre">Shape</span>, а функция <span class="inline-pre">protoFlip(_ :)</span> принимает аргумент некоторого типа, который соответствует протоколу Shape. Однако значение типа протокола не соответствует этому протоколу; значение, возвращаемое <span class="inline-pre">protoFlip(_ :)</span>, не соответствует <span class="inline-pre">Shape</span>. Это означает, что такой код, как <span class="inline-pre">protoFlip(protoFlip (smallTriange))</span>, который применяет несколько преобразований, недействителен, поскольку перевернутая форма не является допустимым аргументом для <span class="inline-pre">protoFlip(_ :)</span>.</p>
<p>Напротив, непрозрачные типы сохраняют идентичность базового типа. Swift может определять связанные типы, что позволяет использовать непрозрачное возвращаемое значение в тех местах, где тип протокола не может использоваться в качестве возвращаемого значения. Например, вот версия протокола контейнера из раздела "<a href="https://swiftbook.ru/content/languageguide/generics-in-swift/">Универсальные шаблоны</a>":</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}
extension Array: Container { }</code></pre>
<p>Вы не можете использовать <span class="inline-pre">Container</span> в качестве возвращаемого типа функции, потому что у этого протокола есть связанный тип. Вы также не можете использовать его в качестве ограничения в универсальном возвращаемом типе, потому что за пределами тела функции недостаточно информации, чтобы сделать вывод, каким должен быть универсальный тип.</p>
<pre><code class="language-swift">Ошибка: Протоколы со связанными типами не могут быть использованы в качестве возвращаемого типа.
func makeProtocolContainer(item: T) -&gt; Container {
    return [item]
}
// Ошибка: Не достаточно информации для определения типа C.
func makeProtocolContainer&lt;T, C: Container&gt;(item: T) -&gt; C {
    return [item]
}</code></pre>
<p>Использование непрозрачного типа <span class="inline-pre">some Container</span> в качестве возвращаемого типа выражает желаемый контракт API - функцию возвращающую контейнер, но не указывающую его тип:</p>
<pre><code class="language-swift"><span class="k">func</span> <span class="nv">makeOpaqueContainer</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">item</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Container</span> {
    return [item]
}
let opaqueContainer = makeOpaqueContainer(item: 12)
let twelve = opaqueContainer[0]
print(type(of: twelve))
// Выведет "Int"</code></pre>
<p>Тип значения <span class="inline-pre">twelve</span> считается <span class="inline-pre">Int</span>, что иллюстрирует тот факт, что вывод типа работает с непрозрачными типами. В реализации <span class="inline-pre">makeOpaqueContainer(item :)</span> базовый тип непрозрачного контейнера - <span class="inline-pre">[T]</span>. В этом случае <span class="inline-pre">T</span> - это <span class="inline-pre">Int</span>, поэтому возвращаемое значение представляет собой массив целых чисел, а связанный с Item тип выводится как <span class="inline-pre">Int</span>. Нижний индекс в Container возвращает <span class="inline-pre">Item</span>, что означает, что тип <span class="inline-pre">twelve</span> также определяется как <span class="inline-pre">Int</span>.</p>
<div class="mistape_caption">Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/extensions" rel="6985">Расширения</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/protocols" rel="8815">Протоколы</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/opaque-types/">Непрозрачные типы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
https://swiftbook.ru/content/languageguide/opaque-types/feed/
0
Документация
https://swiftbook.ru/content/docs/
				https://swiftbook.ru/content/docs/#respond
Fri, 31 Aug 2018 20:59:03 +0000
unanimity@list.ru
https://swiftbook.ru/?post_type=manual_documentation&p=8979
<p>Данная документация является переводом официальной книги "Swift Programming Language" от Apple. Работа была проделана профессионалами, но в связи с огромным объемом текста и постоянным обновлением книги, мы не исключаем незначительных ошибок. Если вы вдруг обнаружили то, что на ваш взгляд нуждается в корректировке, то напишите нам об этом либо в комментариях, либо на почту и [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/docs/">Документация</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p>Данная документация является переводом официальной книги "Swift Programming Language" от Apple. Работа была проделана профессионалами, но в связи с огромным объемом текста и постоянным обновлением книги, мы не исключаем незначительных ошибок. Если вы вдруг обнаружили то, что на ваш взгляд нуждается в корректировке, то напишите нам об этом либо в комментариях, либо на почту и мы обязательно примем это во внимание. Кроме того, мы стараемся постоянно обновлять документацию, как только выходят официальные правки английского варианта книги. В конечном итоге, нашей целью является создание качественного и постоянно обновляемого источника информации о языке Swift.</p>
<p>Мы хотим помочь начинающим разработчикам, сделать уверенные шаги на пути изучения Swift. Мы считаем, что языковой барьер не должен быть препятствием для изучения. Мы искренне верим, что такой мощный, быстрый и современный язык программирования как Swift, должен быть доступен каждому.</p>
<p>Если вам нужно быстро пройтись по возможностям языка, то начните с главы "Знакомство со Swift". Если же требуется углубиться в Swift, пропустите главу "Знакомство со Swift" и сразу начинайте читать с главы "Основы".</p>
<div style="text-align: center!important; margin: auto; width: 100%;">
<div style="text-align: center!important; margin: auto;"><a class="custom-botton vc-custom-btm-hover-0697" style="text-transform: none; height: auto!important; color: #ffffff!important; text-shadow: none; border-radius: 10px; font-size: 18px; padding: 10px 30px;" href="https://drive.google.com/file/d/1wUi08qCEDor-rrb28VTCLwrxTHENXeII/view?usp=share_link" target="_parent" rel="noopener noreferrer">Страница, где можно скачать книгу</a></div>
</div>
<p>&nbsp;</p>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/docs/">Документация</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
https://swiftbook.ru/content/docs/feed/
0
Резюме по грамматике
https://swiftbook.ru/content/language-reference/%d1%80%d0%b5%d0%b7%d1%8e%d0%bc%d0%b5-%d0%bf%d0%be-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b5/
				Sat, 04 Aug 2018 07:48:27 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=7068
<p>Лексическая структура Грамматика пустого пространства whitespace → whitespace-item whitespace opt whitespace-item → line-break whitespace-item → comment whitespace-item → multiline-comment whitespace-item → U+0000, U+0009, U+000B, U+000C, or U+0020 line-break → U+000A line-break → U+000D line-break → U+000D followed by U+000A comment → // comment-text line-break multiline-comment → /* multiline-comment-text */ comment-text → comment-text-item comment-text opt comment-text-item [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/language-reference/%d1%80%d0%b5%d0%b7%d1%8e%d0%bc%d0%b5-%d0%bf%d0%be-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b5/">Резюме по грамматике</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<h2>Лексическая структура</h2>
<h3>Грамматика пустого пространства</h3>
<pre><code class="language-swift">whitespace → whitespace-item whitespace opt
whitespace-item → line-break
whitespace-item → comment
whitespace-item → multiline-comment
whitespace-item → U+0000, U+0009, U+000B, U+000C, or U+0020
line-break → U+000A
line-break → U+000D
line-break → U+000D followed by U+000A
comment → // comment-text line-break
multiline-comment → /* multiline-comment-text */
comment-text → comment-text-item comment-text opt
comment-text-item → Any Unicode scalar value except U+000A or U+000D
multiline-comment-text → multiline-comment-text-item multiline-comment-text opt
multiline-comment-text-item → multiline-comment
multiline-comment-text-item → comment-text-item
multiline-comment-text-item → Any Unicode scalar value except /* or */</code></pre>
<h3>Грамматика идентификатора</h3>
<pre><code class="language-swift"><i>identifier </i>→ <i>identifier-head­ identifier-characters­</i><i><sub>opt</sub></i>­
<i>identifier </i>→ <b>`­</b><i>identifier-head­ identifier-characters­</i><i><sub>opt</sub></i>­<b>`­</b>
<i>identifier </i>→ <i>implicit-parameter-name­</i>
<i>identifier-list </i>→ <i>identifier­</i> <i>identifier­</i><b>,­</b><i>identifier-list­</i>
<i>identifier-head </i>→ Upper- or lowercase letter A through Z
<i>identifier-head </i>→ <b>_­</b>
<i>identifier-head </i>→ U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or U+00B7–U+00BA
<i>identifier-head </i>→ U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or U+00F8–U+00FF
<i>identifier-head </i>→ U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or U+180F–U+1DBF
<i>identifier-head </i>→ U+1E00–U+1FFF
<i>identifier-head </i>→ U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, or U+2060–U+206F
<i>identifier-head </i>→ U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or U+2776–U+2793
<i>identifier-head </i>→ U+2C00–U+2DFF or U+2E80–U+2FFF
<i>identifier-head </i>→ U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or U+3040–U+D7FF
<i>identifier-head </i>→ U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or U+FE30–U+FE44
<i>identifier-head </i>→ U+FE47–U+FFFD
<i>identifier-head </i>→ U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, or U+40000–U+4FFFD
<i>identifier-head </i>→ U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, or U+80000–U+8FFFD
<i>identifier-head </i>→ U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, or U+C0000–U+CFFFD
<i>identifier-head </i>→ U+D0000–U+DFFFD or U+E0000–U+EFFFD
<i>identifier-character </i>→ Цифры от 0 до 9 (включительно)
<i>identifier-character </i>→ U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, or U+FE20–U+FE2F
<i>identifier-character </i>→ <i>identifier-head­</i>
<i>identifier-characters </i>→ <i>identifier-character­identifier-characters­</i><i><sub>opt</sub></i>­
<i>implicit-parameter-name </i>→ <b>$­</b><i>decimal-digits­</i></code></pre>
<h3>Грамматика литерала</h3>
<pre><code class="language-swift"><i>literal </i>→ <i>numeric-literal­</i> | <i>string-literal­</i>| <i>boolean-literal­</i> | <i>nil-literal­</i>
<i>numeric-literal </i>→ <b>-­</b><i><sub>opt</sub></i>­ <i>integer-literal­ |</i> <b>-­</b><i><sub>opt</sub>floating-point-literal­</i>
<i>boolean-literal </i>→ <b>true­</b> | <b>false­</b>
<i>nil-literal </i>→ <b>nil­</b></code></pre>
<h3>Грамматика целочисленного литерала</h3>
<pre><code class="language-swift"><i>integer-literal </i>→ <i>binary-literal­</i>
<i>integer-literal </i>→ <i>octal-literal­</i>
<i>integer-literal </i>→ <i>decimal-literal­</i>
<i>integer-literal </i>→ <i>hexadecimal-literal­</i>
<i>binary-literal </i>→ <b>0b </b><i>binary-digit­binary-literal-characters­</i><i><sub>opt</sub></i>­
<i>binary-digit </i>→ <strong>Цифры 0 или 1</strong>
<i>binary-literal-character </i>→ <i>binary-digit­</i> | <b>_­</b>
<i>binary-literal-characters </i>→ <i>binary-literal-character­ binary-literal-characters­</i><i><sub>opt</sub></i>­
<i>octal-literal </i>→ <b>0o­ </b><i>octal-digit­octal-literal-characters­</i><i><sub>opt</sub></i>­
<i>octal-digit </i>→ <strong>Цифры от 0 до 7 включительно</strong>
<i>octal-literal-character </i>→ <i>octal-digit­</i> |  <b>_ ­</b>
<i>octal-literal-characters </i>→ <i>octal-literal-character ­octal-literal-characters­</i><i><sub>opt</sub></i>­
<i>decimal-literal </i>→ <i>decimal-digit­ decimal-literal-characters­</i><i><sub>opt</sub></i>­
<i>decimal-digit </i>→ <strong>Цифры от 0 до 9 включительно</strong>
<i>decimal-digits </i>→ <i>decimal-digit­decimal-digits­</i><i><sub>opt</sub></i>­
<i>decimal-literal-character </i>→ <i>decimal-digit­</i>  | <b>_­</b>
<i>decimal-literal-characters </i>→ <i>decimal-literal-character ­decimal-literal-characters­</i><i><sub>opt</sub></i>­
<i>hexadecimal-literal </i>→ <b>0x </b><i>hexadecimal-digit­hexa decimal-literal-characters­</i><i><sub>opt</sub></i>­
<i>hexadecimal-digit </i>→ <strong>Цифры от 0 до 9 включительно, от a до f включительно или от A до F включительно</strong>
<i>hexadecimal-literal-character </i>→ <i>hexadecimal-digit­ </i>| <b>_­</b>
<i>hexadecimal-literal-characters </i>→ <i>hexadecimal-literal-character­ hexadecimal-literal-characters­</i><i><sub>opt</sub></i>­</code></pre>
<h3>Грамматика числа с плавающей точкой</h3>
<pre><code class="language-swift"><i>floating-point-literal </i>→ <i>decimal-literal­ decimal-fraction­</i><i><sub>opt</sub></i>­ <i>decimal-exponent­</i><i><sub>opt</sub></i>­
<i>floating-point-literal </i>→ <i>hexadecimal-literal­ hexadecimal-fraction­</i><i><sub>opt</sub></i>­ <i>hexadecimal-exponent­</i>
<i>decimal-fraction </i>→ <b>.­</b><i>decimal-literal­</i>
<i>decimal-exponent </i>→ <i>floating-point-e­sign­</i><i><sub>opt </sub></i>­<i>decimal-literal­</i>
<i>hexadecimal-fraction </i>→ <b>.­</b><i>hexadecimal-digit­ hexadecimal-literal-characters­</i><i><sub>opt</sub></i>­
<i>hexadecimal-exponent </i>→ <i>floating-point-p­sign­</i><i><sub>opt</sub></i>­ <i>decimal-literal­</i>
<i>floating-point-e </i>→ <b>e­</b> | <b>E­</b>
<i>floating-point-p </i>→ <b>p­</b> | <b>P­</b>
<i>sign </i>→ <b>+­</b> | <b>-­</b></code></pre>
<h3>Грамматика строкового литерала</h3>
<pre><code class="language-swift"><i>string-literal → static-string-literal | interpolated-string-literal
static-string-literal → " quoted-text opt "
static-string-literal → """ multiline-quoted-text opt """
quoted-text → quoted-text-item quoted-text opt
quoted-text-item → escaped-character
quoted-text-item → Any Unicode scalar value except ", \, U+000A, or U+000D "
multiline-quoted-text → multiline-quoted-text-item multiline-quoted-text opt
multiline-quoted-text-item → escaped-character
multiline-quoted-text-item → Any Unicode scalar value except \
multiline-quoted-text-item → escaped-newline
interpolated-string-literal → " interpolated-text opt "
interpolated-string-literal → """ multiline-interpolated-text opt """
interpolated-text → interpolated-text-item interpolated-text opt
interpolated-text-item → \( expression ) | quoted-text-item
multiline-interpolated-text → multiline-interpolated-text-item multiline-interpolated-text opt
multiline-interpolated-text-item → \( expression ) | multiline-quoted-text-item
escaped-character → \0 | \\ | \t | \n | \r | \" | \'
escaped-character → \u { unicode-scalar-digits }
unicode-scalar-digits → Between one and eight hexadecimal digits
escaped-newline → \ whitespace opt line-break</i></code></pre>
<h3>Грамматика операторов</h3>
<pre><code class="language-swift"><i>operator </i>→ <i>operator-head­ operator-characters­</i><i><sub>opt</sub></i>­
<i>operator </i>→ <i>dot-operator-head­ dot-operator-characters­</i>
<i>operator-head </i>→ <b>/­ </b>| <b>=­</b> | <b>-­</b> | <b>+­</b> | <b>!­</b> | <b>*­</b> | <b>%­</b> | <b>&lt;­ </b>| <b>&gt;­</b> | <b>&amp;­</b> | <b>|­</b> | <b>^­</b> | <b>~­</b> | <b>?­</b>
<i>operator-head </i>→ U+00A1–U+00A7
<i>operator-head </i>→ U+00A9 or U+00AB
<i>operator-head </i>→ U+00AC or U+00AE
<i>operator-head </i>→ U+00B0–U+00B1, U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7
<i>operator-head </i>→ U+2016–U+2017 or U+2020–U+2027
<i>operator-head </i>→ U+2030–U+203E
<i>operator-head </i>→ U+2041–U+2053
<i>operator-head </i>→ U+2055–U+205E
<i>operator-head </i>→ U+2190–U+23FF
<i>operator-head </i>→ U+2500–U+2775
<i>operator-head </i>→ U+2794–U+2BFF
<i>operator-head </i>→ U+2E00–U+2E7F
<i>operator-head </i>→ U+3001–U+3003
<i>operator-head </i>→ U+3008–U+3030
<i>operator-character </i>→ <i>operator-head­</i>
<i>operator-character </i>→ U+0300–U+036F
<i>operator-character </i>→ U+1DC0–U+1DFF
<i>operator-character </i>→ U+20D0–U+20FF
<i>operator-character </i>→ U+FE00–U+FE0F
<i>operator-character </i>→ U+FE20–U+FE2F
<i>operator-character </i>→ U+E0100–U+E01EF
<i>operator-characters </i>→ <i>operator-character­ operator-characters­</i><i><sub>opt</sub></i>­
<i>dot-operator-head </i>→ <b>.­</b>
<i>dot-operator-character </i>→ <b>.­</b> | <i>operator-character­</i>
<i>dot-operator-characters </i>→ <i>dot-operator-character­dot-operator-characters­</i><i><sub>opt</sub></i>­
<i>binary-operator </i>→ <i>operator­</i>
<i>prefix-operator </i>→ <i>operator­</i>
<i>postfix-operator </i>→ <i>operator­</i></code></pre>
<h2>Типы</h2>
<h3>Грамматика типа</h3>
<pre><code class="language-swift">type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/array-type">array-type</a>
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/dictionary-type">dictionary-type</a>­
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type">function-type</a>­
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type">tuple-type</a>
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/optional-type">optional-type</a>­
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/implicitly-unwrapped-optional-type">implicitly-unwrapped-optional-type</a>­
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-composition-type">protocol-composition-type</a>
type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/metatype-type">metatype-type</a>
type → Any
type → Self
type → <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//appleref/swift/grammar/type">( type )</a>
</code></pre>
<h3>Грамматика аннотации типа</h3>
<pre><code class="language-swift">type-annotation → <code>:­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <strong>inout</strong><sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­</code></pre>
<h3>Грамматика идентификатора типа</h3>
<pre><code class="language-swift">type-identifier → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-name">type-name</a>­  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>­<sub>opt</sub>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-name">type-name</a>­  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>­<sub>opt</sub>­  <code>. </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ type-name → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­</code></pre>
<h3>Грамматика кортежного типа</h3>
<pre><code class="language-swift">tuple-type → <code>(­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type-body">tuple-type-body</a>­<sub>opt</sub>­<code>)­</code> tuple-type-element-list → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type-element">tuple-type-element</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type-element">tuple-type-element</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type-element-list">tuple-type-element-list</a>­ tuple-type-element →  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/element-name">element-name</a>   ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation">type-annotation</a>­  ­|  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ element-name → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­</code></pre>
<h3>Грамматика функционального типа</h3>
<pre><code class="language-swift">function-type → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt  </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type-argument-clause">function-type-argument-clause</a>­  <code>throws­</code><sub>opt</sub>­  <code>-&gt;­  </code><a href="https://developer.apple&lt;p&gt;.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ function-type → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type-argument-clause">function-type-argument-clause</a>­  <code>rethrows­  </code><code>-&gt;­  </code><a href="https://developer.ap&lt;p&gt;ple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ function-type-argument-clause → <code>(­</code><code>)­</code> function-type-argument-clause → <code>(­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.ht&lt;p&gt;ml#//apple_ref/swift/grammar/function-type-argument-list">function-type-argument-list</a>­<code>...­</code><sub>opt</sub>­<code>)­</code> function-type-argument-list → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type-argument">function-type-argument</a>­ | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type-argument">function-type-argument</a>­ <code>, ­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming&lt;p&gt;_Language/Types.html#//apple_ref/swift/grammar/function-type-argument-list">function-type-argument-list</a>­ function-type-argument → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <code>inout­</code><sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/argument-label">argument-label</a>­  <a href="https://developer.apple.com/library/content/&lt;p&gt;documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation">type-annotation</a>­ argument-label → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­</code></pre>
<h3>Грамматика типа массива</h3>
<pre><code class="language-swift">array-type → <code>[­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­<code>]­</code></code></pre>
<h3>Грамматика типа словаря</h3>
<pre><code class="language-swift"><em>dictionary-type </em>→ <span class="inline-pre">[­</span><em>type­ </em><span class="inline-pre">:­ </span><em>type­</em><span class="inline-pre">]­</span></code></pre>
<h3>Грамматика опционального типа</h3>
<pre><code class="language-swift">optional-type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­  <code>?­</code></code></pre>
<h3>Грамматика неявно извлеченного опционального типа</h3>
<pre><code class="language-swift">implicitly-unwrapped-optional-type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a> ­<code>!­</code></code></pre>
<h3>Грамматика типа композиции протоколов</h3>
<pre><code class="language-swift">protocol-composition-type → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-identifier">protocol-identifier</a>­ <code>&amp; ­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-composition-continuation">protocol-composition-continuation</a>­ protocol-composition-continuation → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-identifier">protocol-identifier</a>­  | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-composition-type">protocol-composition-type</a>­ </code></pre>
<h3>Грамматика метатипа</h3>
<pre><code class="language-swift">metatype-type → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ <code>.­ </code><strong><code>Type­</code>  </strong>|  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­<code>. ­ </code><strong><code>Protocol­</code></strong></code></pre>
<h3>Грамматика наследования типа</h3>
<pre><code class="language-swift">type-inheritance-clause → <b>:</b> <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//appleref/swift/grammar/type-inheritance-list">type-inheritance-list</a>
type-inheritance-list → <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//appleref/swift/grammar/type-identifier">type-identifier</a> | <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//appleref/swift/grammar/type-identifier">type-identifier</a>, <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//appleref/swift/grammar/type-inheritance-list">type-inheritance-list</a></code></pre>
<h2>Выражения</h2>
<h3>Грамматика выражений</h3>
<pre><code class="language-swift">expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/try-operator">try-operator</a> ­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/prefix-expression">prefix-expression</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/binary-expressions">binary-expressions</a>­<sub>opt</sub>­
expression-list → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­  | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression-list">expression-list</a>­</code></pre>
<h3>Грамматика префиксных выражений</h3>
<pre><code class="language-swift"><i>prefix-expression </i>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/prefix-operator"><i>prefix-operator</i></a><i>­</i><i><sub>opt </sub></i>­<i>postfix-expression</i><i>­</i>
<i>prefix-expression </i>→ <i>in-out-expression</i><i>­</i>
<i>in-out-expression </i>→ <b>&amp;­ </b><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><i>identifier</i></a><i>­</i></code></pre>
<h3>Грамматика выражения try</h3>
<pre><code class="language-swift"><i>try-operator </i>→ <b>try­</b> | <b>try­?­</b> | <b>try­!­</b></code></pre>
<h3>Грамматика бинарных выражений</h3>
<pre><code class="language-swift">binary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/binary-operator">binary-operator</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>­
binary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/assignment-operator">assignment-operator</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/try-operator">try-operator</a>­<sub>opt </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>­
binary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/conditional-operator">conditional-operator</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/try-operator">try-operator</a>­<sub>opt </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>­
binary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/type-casting-operator">type-casting-operator</a>­
binary-expressions → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/binary-expression">binary-expression</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/binary-expressions">binary-expressions</a>­<sub>opt</sub>­</code></pre>
<h3>Грамматика оператора присваивания</h3>
<pre><code class="language-swift"><i>assignment-operator </i>→ <b>=­</b></code></pre>
<h3>Грамматика условного оператора</h3>
<pre><code class="language-swift">conditional-operator → <code>?­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/try-operator">try-operator</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>:­</code></code></pre>
<h3>Грамматика операторов приведения типа</h3>
<pre><code class="language-swift">type-casting-operator → <code><b>is­</b> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ type-casting-operator → <code><b>as</b> ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ type-casting-operator → <b><code>as­ </code></b><code><span class="inline-pre">?</span> ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­ type-casting-operator → <b><code>as­ </code></b><code><span class="inline-pre">!</span>­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­</code></pre>
<h3>Грамматика первичных выражений</h3>
<pre><code class="language-swift">primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>­ <sub>opt</sub>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/literal-expression">literal-expression</a>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/self-expression">self-expression</a>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/superclass-expression">superclass-expression</a>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/closure-expression">closure-expression</a>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/parenthesized-expression">parenthesized-expression</a>­
primary-expression → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/tuple-expression">tuple-expression</a>
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/implicit-member-expression">implicit-member-expression</a>­
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/wildcard-expression">wildcard-expression</a>­
primary-expression → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/key-path-expression">key-path-expression</a>
primary-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/selector-expression">selector-expression</a>­
primary-expression → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/key-path-string-expression">key-path-string-expression</a></code></pre>
<h3>Грамматика выражения литерала</h3>
<pre><code class="language-swift">literal-expression → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/literal">literal</a>­
literal-expression → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/array-literal">array-literal</a>­  | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dictionary-literal">dictionary-literal</a> |­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/playground-literal">playground-literal</a>­
literal-expression → <code>#file­</code>  | <code>#line­</code> | <code>#column­</code>  |  <code>#function­</code> array-literal → <code>[­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/array-literal-items">array-literal-items</a>­<sub>opt</sub>­<code>]­</code> array-literal-items → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/array-literal-item">array-literal-item</a>­<code>,­</code><sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/array-literal-item">array-literal-item</a>­<code>,­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/array-literal-items">array-literal-items</a>­ array-literal-item → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­ dictionary-literal → <code>[­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dictionary-literal-items">dictionary-literal-items</a>­<code>]­</code> |<code>[­</code><code>:­</code><code>]­</code> dictionary-literal-items → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dictionary-literal-item">dictionary-literal-item</a>­<code>,­</code><sub>opt</sub>­ <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dictionary-literal-item">dictionary-literal-item</a>­<code>,­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dictionary-literal-items">dictionary-literal-items</a>­ dictionary-literal-item → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>:­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­ playground-literal → <b><code>#colorLiteral­ (­ </code><code>red­ </code></b><code><b>: </b>­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>,­ </code><b><code>green­ </code><code>: ­</code></b><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>,­ </code><b><code>blue­ </code></b><code><b>: </b>­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>, ­</code><b><code>alpha­ </code></b><code><b>: </b>­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>)­</code> playground-literal → <b><code>#fileLiteral­ </code><code>(­ </code><code>resourceName­ </code><code>: ­</code></b><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>)­</code> playground-literal → <b><code>#imageLiteral­ </code><code>(­ </code><code>resourceName­ </code><code>: ­</code></b><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>)­</code></code></pre>
<h3>Грамматика выражения self</h3>
<pre><code class="language-swift">self-expression → <code>self­</code>  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/self-method-expression">self-method-expression</a>­  | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/self-subscript-expression">self-subscript-expression</a>­ | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/self-initializer-expression">self-initializer-expression</a>­ self-method-expression → <code>self­</code><code>.­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ self-subscript-expression → <code>self­</code><code>[­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression-list">expression-list</a>­<code>]­</code> self-initializer-expression → <code>self­</code><code>.­</code><code>init­</code></code></pre>
<h3>Грамматика выражения суперкласса</h3>
<pre><code class="language-swift">superclass-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/superclass-method-expression">superclass-method-expression</a>­  | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/superclass-subscript-expression">superclass-subscript-expression</a>­ | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/superclass-initializer-expression">superclass-initializer-expression</a>­
superclass-method-expression → <code>super­</code><code>.­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ superclass-subscript-expression → <code>super­</code><code>[­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression-list">expression-list</a>­<code>]­</code> superclass-initializer-expression → <code>super­</code><code>.­</code><code>init­</code></code></pre>
<h3>Грамматика выражений замыканий</h3>
<pre><code class="language-swift">closure-expression → {closure-signature <sub>opt</sub>­ statements}
‌closure-signature → capture-list <sub>opt</sub>­ closure-parameter-clause <b>throws </b> <sub>opt</sub>­ function-result <sub>opt</sub>­ <b>in</b>
‌closure-signature → capture-list <b>in</b>
‌closure-parameter-clause → <b>( )</b> | <b>(</b>closure-parameter-list<b>)</b> | identifier-list
‌closure-parameter-list → closure-parameter | closure-parameter, closure-parameter-list
‌closure-parameter → closure-parameter-nametype-annotation <sub>opt</sub>­
‌closure-parameter → closure-parameter-nametype-annotation...
‌closure-parameter-name → identifier
‌capture-list → <b>[</b>capture-list-items<b>]</b>
‌capture-list-items → capture-list-item capture-list-item, capture-list-items
‌capture-list-item → capture-specifier <sub>opt</sub>­ expression
‌capture-specifier → <b>weak</b>  | <b>unowned </b>| <b>unowned(safe)</b> |  <b>unowned(unsafe)</b></code></pre>
<h3>Грамматика неявного выражения члена</h3>
<pre><code class="language-swift"><i>implicit-member-expression </i>→ <b>.­</b><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><i>identifier</i></a><i>­</i></code></pre>
<h3>Грамматика выражения в скобках</h3>
<pre><code class="language-swift">parenthesized-expression → <code>(­</code><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>)</code></code></pre>
<h3>Грамматика выражения кортежа</h3>
<pre><code class="language-swift">tuple-expression → <code>(­</code><code>)­</code> | <code>(­</code><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/tuple-element">tuple-element</a>­<code>,­</code><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/tuple-element-list">tuple-element-list</a>­<code>)­</code> tuple-element-list → <a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/tuple-element">tuple-element</a>­  | <a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/tuple-element">tuple-element</a>­<code>,­</code><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/tuple-element-list">tuple-element-list</a>­ tuple-element → <a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­  | <a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­<code>:­</code><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­</code></pre>
<h3>Грамматика выражения wildcard</h3>
<pre><code class="language-swift"><i>wildcard-expression </i>→ <b>_­</b></code></pre>
<h3>Грамматика выражения Key-Path</h3>
<pre><code class="language-swift">key-path-expression → \ type opt . key-path-components
key-path-components → key-path-component | key-path-component . key-path-components
key-path-component → identifier key-path-postfixes opt | key-path-postfixes
key-path-postfixes → key-path-postfix key-path-postfixes opt
key-path-postfix → ? | ! | [ function-call-argument-list ] </code></pre>
<h3>Грамматика выражения селектора</h3>
<pre><code class="language-swift">selector-expression → <b>#selector (</b> expression<b> )</b>
‌selector-expression → <b>#selector ( getter:</b> expression <b>)</b>
‌selector-expression → <b>#selector ( setter:</b> expression <b>)</b></code></pre>
<h3>Грамматика выражения зачения пути по ключу</h3>
<pre><code class="language-swift">key-path-expression → <b>#keyPath (</b> expression <b>)</b></code></pre>
<h3>Грамматика постфиксных выражений</h3>
<pre><code class="language-swift">postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/primary-expression">primary-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/postfix-operator">postfix-operator</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/function-call-expression">function-call-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/initializer-expression">initializer-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/explicit-member-expression">explicit-member-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-self-expression">postfix-self-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/dynamic-type-expression">dynamic-type-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/subscript-expression">subscript-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/forced-value-expression">forced-value-expression</a>­
postfix-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/optional-chaining-expression">optional-chaining-expression</a>­</code></pre>
<h3>Грамматика выражения вызова функции</h3>
<pre><code class="language-swift">function-call-expression → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/postfix-expression">postfix-expression</a> <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/function-call-argument-clause">function-call-argument-clause</a>
function-call-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/parenthesized-expression">parenthesized-expression</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/trailing-closure">trailing-closure</a>
function-call-argument-clause → ( ) | (<a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/function-call-argument-list">function-call-argument-list</a>)
function-call-argument-list → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/function-call-argument">function-call-argument</a> | <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/function-call-argument">function-call-argument </a>,<a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/function-call-argument-list">function-call-argument-list</a>
function-call-argument → <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/expression">expression</a> | <a href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#//appleref/swift/grammar/identifier">identifier </a> : <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#//appleref/swift/grammar/expression">expression</a>
function-call-argument → <a href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#//appleref/swift/grammar/operator">operator</a> | <a href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#//appleref/swift/grammar/identifier">identifier</a> : <a href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#//appleref/swift/grammar/operator">operator</a>
­
trailing-closure → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/closure-expression">closure-expression</a>­</code></pre>
<h3>Грамматика выражения инициализатора</h3>
<pre><code class="language-swift">initializer-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><code>init­</code> initializer-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><code>init­</code><code>(­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/argument-names">argument-names</a>­<code>)­</code></code></pre>
<h3>Грамматика явного выражения члена</h3>
<pre><code class="language-swift">explicit-member-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><a href="https://developer.apple.com/library/ios/documentation/S&lt;p&gt;wift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/decimal-digits">decimal-digits</a>­ explicit-member-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language&lt;p&gt;/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>­<sub>opt</sub>­ explicit-member-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­<code>(­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Co&lt;p&gt;nceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/argument-names">argument-names</a>­<code>)­</code> argument-names → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/argument-name">argument-name</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift&lt;p&gt;/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/argument-names">argument-names</a>­<sub>opt</sub>­ argument-name → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­<code>:­</code></code></pre>
<h3>Грамматика выражения self</h3>
<pre><code class="language-swift">postfix-self-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>.­</code><code>self­</code></code></pre>
<h3>Грамматика выражения сабскрипта</h3>
<pre><code class="language-swift">subscript-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­ <code><b>[</b> ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression-list">expression-list</a>­ <b><code>]­</code></b></code></pre>
<h3>Грамматика принудительного значения</h3>
<pre><code class="language-swift">forced-value-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>!­</code></code></pre>
<h3>Грамматика принудительного значения</h3>
<pre><code class="language-swift">forced-value-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>!­</code></code></pre>
<h3>Грамматика выражения опциональной последовательности</h3>
<pre><code class="language-swift">optional-chaining-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>­<code>?­</code></code></pre>
<h2>Инструкции</h2>
<h3>Грамматика инструкций</h3>
<pre><code class="language-swift">statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration">declaration</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/loop-statement">loop-statement</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/branch-statement">branch-statement</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/labeled-statement">labeled-statement</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/control-transfer-statement">control-transfer-statement</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/defer-statement">defer-statement</a>­<code>;­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/do-statement">do-statement</a>­<code>:­</code><sub>opt</sub>­ statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/compiler-control-statement">compiler-control-statement</a>­ statements → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statement">statement</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statements">statements</a>­ <sub>opt</sub>­</code></pre>
<h3>Грамматика инструкции цикла</h3>
<pre><code class="language-swift">loop-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/for-in-statement">for-in-statement</a>­
loop-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/while-statement">while-statement</a>­
loop-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/repeat-while-statement">repeat-while-statement</a>­</code></pre>
<h3>Грамматика инструкции for-in</h3>
<pre><code class="language-swift">for-in-statement →<strong> <code>for­ </code><code>case­</code></strong><sub>opt </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a> ­<code><strong>in </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­ <sub>opt </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика инструкции while</h3>
<pre><code class="language-swift">while-statement → <strong><code>while­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-clause">condition-clause</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­ condition-clause → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­ condition-clause → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list">condition-list</a>­ condition-clause → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list">condition-list</a>­ condition-clause → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition">availability-condition</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­ condition-list → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition">condition</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition">condition</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list">condition-list</a>­ condition → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition">availability-condition</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-condition">case-condition</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-condition">optional-binding-condition</a>­ case-condition → <strong><code>case­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer">initializer</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­<sub>opt</sub>­ optional-binding-condition → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-head">optional-binding-head</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-continuation-list">optional-binding-continuation-list</a>­<sub>opt</sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­<sub>opt</sub>­ optional-binding-head → <code>let ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer">initializer</a>­  | <code>var ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer">initializer</a>­ optional-binding-continuation-list → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-continuation">optional-binding-continuation</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-continuation">optional-binding-continuation</a>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-continuation-list">optional-binding-continuation-list</a>­ optional-binding-continuation → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer">initializer</a>­  | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-head">optional-binding-head</a>­</code></pre>
<h3>Грамматика repeat-while инструкции</h3>
<pre><code class="language-swift"><i>repeat-while-statement </i>→ <b>repeat ­</b><i><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a> </i><b>while­ </b><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression"><i>expression</i></a><i>­</i></code></pre>
<h3>Грамматика инструкций ветвления</h3>
<pre><code class="language-swift">branch-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement">if-statement</a>­
branch-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/guard-statement">guard-statement</a>­
branch-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/switch-statement">switch-statement</a>­</code></pre>
<h3>Грамматика инструкции if</h3>
<pre><code class="language-swift">if-statement → <code><strong>if­</strong> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-clause">condition-clause</a>­   <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/else-clause">else-clause</a> ­<sub>opt</sub>­ else-clause → <code>else­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­  |  <code>else ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement">if-statement</a>­</code></pre>
<h3>Грамматика инструкции guard</h3>
<pre><code class="language-swift">guard-statement → <code>guard­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-clause">condition-clause</a>­ <code>else ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика инструкции switch</h3>
<pre><code class="language-swift">switch-statement → <strong><code>switch­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­<code>{­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/switch-cases">switch-cases</a>­<sub>opt</sub>­<code>}­</code> switch-cases → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/switch-case">switch-case</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/switch-cases">switch-cases</a>­ <sub>opt</sub>­ switch-case → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-label">case-label</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statements">statements</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/default-label">default-label</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statements">statements</a>­ case-label → <strong><code>case­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-item-list">case-item-list</a>­<code>:­</code> case-item-list → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­<sub>opt</sub>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­<sub>opt</sub>­<code>,­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-item-list">case-item-list</a>­ default-label → <strong><code>default­</code></strong><code>:­</code> where-clause → <code>where­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-expression">where-expression</a>­ where-expression → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­</code></pre>
<h3>Грамматика маркированных инструкций</h3>
<pre><code class="language-swift">labeled-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statement-label">statement-label</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/loop-statement">loop-statement</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statement-label">statement-label</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement">if-statement</a>­  |  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statement-label">statement-label</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/switch-statement">switch-statement</a>­
statement-label → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/label-name">label-name</a>­<code>:­</code> label-name → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­</code></pre>
<h3>Грамматика инструкции передачи управления</h3>
<pre><code class="language-swift">control-transfer-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/break-statement">break-statement</a>­
control-transfer-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/continue-statement">continue-statement</a>­
control-transfer-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/fallthrough-statement">fallthrough-statement</a>­
control-transfer-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/return-statement">return-statement</a>­
control-transfer-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/throw-statement">throw-statement</a>­</code></pre>
<h3>Грамматика инструкции Break</h3>
<pre><code class="language-swift">break-statement → <code>break ­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/label-name">label-name</a>­ <sub>opt</sub>­</code></pre>
<h3>Грамматика инструкции Continue</h3>
<pre><code class="language-swift">continue-statement → <strong><code>continue­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/label-name">label-name</a>­ <sub>opt</sub>­</code></pre>
<h3>Грамматика инструкции fallthrough</h3>
<pre><code class="language-swift">fallthrough-statement → <strong><code>fallthrough­</code></strong></code></pre>
<h3>Грамматика инструкции return</h3>
<pre><code class="language-swift">return-statement → <strong><code>return­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­ <sub>opt</sub>­</code></pre>
<h3>Грамматика инструкции throw</h3>
<pre><code class="language-swift">throw-statement → <strong>throw </strong>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression">expression</a>­</code></pre>
<h3>Грамматика инструкции defer</h3>
<pre><code class="language-swift">defer-statement → <code><strong>defer­</strong> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика инструкции do</h3>
<pre><code class="language-swift">do-statement → <code><strong>do </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/catch-clauses">catch-clauses</a>­ <sub>opt</sub>­ catch-clauses → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/catch-clause">catch-clause</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/catch-clauses">catch-clauses</a>­ <sub>opt</sub>­ catch-clause → <code><strong>catch­</strong> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern">pattern</a>­ <sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause">where-clause</a>­ <sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика инструкций управления компилятором</h3>
<pre><code class="language-swift">compiler-control-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/build-configuration-statement">build-configuration-statement</a>­
compiler-control-statement → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/line-control-statement">line-control-statement</a>­</code></pre>
<h3>Грамматика блока условной компиляции</h3>
<pre><code class="language-swift">conditional-compilation-block → if-directive-clause elseif-directive-clauses­<sub>opt</sub>­ else-directive-clause<sub>opt</sub>­ endif-directive
‌ if-directive-clause → if-directive compilation-condition statements­ <sub>opt</sub>­
‌ elseif-directive-clauses → elseif-directive-clause elseif-directive-clauses­ <sub>opt</sub>­
‌ elseif-directive-clause → elseif-directive compilation-condition statements­ <sub>opt</sub>­
‌ else-directive-clause → else-directive statements­ <sub>opt</sub>­
if-directive → <strong>#if</strong>
‌ elseif-directive → <strong>#elseif</strong>
‌ else-directive → <strong>#else</strong>
‌ endif-directive → <strong>#endif</strong>
‌ compilation-condition → platform-condition
‌ compilation-condition → identifier
‌ compilation-condition → boolean-literal
‌ compilation-condition → <strong>(</strong>compilation-condition<strong>)</strong>
‌ compilation-condition → <strong>!</strong>compilation-condition
‌ compilation-condition → compilation-condition <strong>&amp;&amp; </strong>compilation-condition
‌ compilation-condition → compilation-condition <strong>||</strong> compilation-condition
‌ platform-condition →<strong> os (</strong>operating-system<strong>)</strong>
‌ platform-condition → <strong>arch (</strong>architecture<strong>)</strong>
‌ platform-condition → <strong>swift ( &gt;= </strong>swift-version<strong>)</strong>
‌ operating-system → <strong>OSX</strong>  <strong>iOS  watchOS tvOS</strong>
‌ architecture → <strong>i386 | x86_64 |</strong>  <strong>arm |  arm64</strong>
‌ swift-version → decimal-digits <strong>.</strong> decimal-digits</code></pre>
<h3>Грамматика инструкции управления строкой</h3>
<pre><code class="language-swift">line-control-statement → <strong>#sourceLocation ( file: </strong>file-name,line:line-number)
‌ line-control-statement → <strong>#sourceLocation ( )</strong>
‌ line-number → Целое число большее нуля
‌ file-name → static-string-literal</code></pre>
<h3>Грамматика оператора диагностики времени компиляции</h3>
<pre><code class="language-swift">diagnostic-statement → #error ( diagnostic-message )
diagnostic-statement → #warning ( diagnostic-message )
diagnostic-message → static-string-literal </code></pre>
<h3>Грамматика условий доступности</h3>
<pre><code class="language-swift">availability-condition → <strong>#available ( </strong>availability-arguments <strong>)</strong>
availability-arguments → availability-argument  |  availability-argument <strong>,</strong> availability-arguments
‌availability-argument → platform-name platform-version
‌availability-argument → <strong>*</strong>
‌platform-name → <strong>iOS</strong>  |  <strong>iOSApplicationExtension</strong>
‌platform-name → <strong>OSX  </strong>|<strong>  OSXApplicationExtension</strong>
‌platform-name → <strong>watchOS</strong>
‌platform-name → <strong>tvOS</strong>
‌platform-version → decimal-digits
‌platform-version → decimal-digits . decimal-digits
‌platform-version → decimal-digits . decimal-digits . decimal-digits</code></pre>
<h2>Инструкции</h2>
<h3>Грамматика объявления</h3>
<pre><code class="language-swift">declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration">import-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/constant-declaration">constant-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/variable-declaration">variable-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/typealias-declaration">typealias-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/function-declaration">function-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/enum-declaration">enum-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-declaration">struct-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-declaration">class-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-declaration">protocol-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-declaration">initializer-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/deinitializer-declaration">deinitializer-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-declaration">extension-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-declaration">subscript-declaration</a>­
declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/operator-declaration">operator-declaration</a>­
declarations → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration">declaration</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declarations">declarations</a>­ <sub>opt</sub>­</code></pre>
<h3>Грамматика объявления верхнего уровня</h3>
<pre><code class="language-swift"><em>top-level-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statements"><em>statements</em></a><em>­ </em><em><sub>opt</sub></em>­</code></pre>
<h3>Грамматика блока кода</h3>
<pre><code class="language-swift"><em>code-block </em>→ <strong>{­ </strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/statements"><em>statements</em></a><em>­ </em><em><sub>opt</sub></em>­ <strong>}­</strong></code></pre>
<h3>Грамматика объявления импорта</h3>
<pre><code class="language-swift"><em>import-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­ </em><em><sub>opt </sub></em>­<strong>import­ </strong><em>import-kind</em><em>­</em><em><sub>opt </sub></em>­<em>import-path</em><em>­</em>
<em>import-kind </em>→ <strong>typealias­</strong> | <strong>struct­ </strong>| <strong>class­ </strong>| <strong>enum­ </strong>| <strong>protocol­ </strong>| <strong>var­ </strong>| <strong>func­</strong>
<em>import-path </em>→ <em>import-path-identifier</em><em>­ </em>| <em>import-path-identifier</em><em>­ </em><strong>.­ </strong><em>import-path</em><em>­</em>
<em>import-path-identifier </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­ </em>| <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator"><em>operator</em></a><em>­</em></code></pre>
<h3>Грамматика объявления константы</h3>
<pre><code class="language-swift"><em>constant-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­ </em><em><sub>opt</sub></em>­ <em>declaration-modifiers</em><em>­ </em><em><sub>opt </sub></em>­<strong>let ­</strong><em>pattern-initializer-list</em><em>­</em>
<em>pattern-initializer-list </em>→ <em>pattern-initializer</em><em>­</em> <em>pattern-initializer</em><em>­ </em><strong>,­ </strong><em>pattern-initializer-list</em><em>­</em>
<em>pattern-initializer </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern"><em>pattern</em></a><em>­ </em><em>initializer</em><em>­ </em><em><sub>opt</sub></em>­
<em>initializer </em>→ <strong>=­ </strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression"><em>expression</em></a><em>­</em></code></pre>
<h3>Грамматика объявления переменной</h3>
<pre><code class="language-swift"><em>variable-declaration </em>→ <em>variable-declaration-head</em><em>­ </em><em>pattern-initializer-list</em><em>­</em>
<em>variable-declaration </em>→ <em>variable-declaration-head</em><em>­ </em><em>variable-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em>­ </em><em>code-block</em><em>­</em>
<em>variable-declaration </em>→ <em>variable-declaration-head</em><em>­ </em><em>variable-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em>­ </em><em>getter-setter-block</em><em>­</em>
<em>variable-declaration </em>→ <em>variable-declaration-head</em><em>­ </em><em>variable-name </em><em>­</em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em>­ </em><em>getter-setter-keyword-block</em><em>­</em>
<em>variable-declaration </em>→ <em>variable-declaration-head</em><em>­ </em><em>variable-name</em><em>­ </em><em>initializer</em><em>­ </em><em>willSet-didSet-block</em><em>­</em>
<em>variable-declaration </em>→ <em>variable-declaration-head </em><em>­</em><em>variable-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em>­ </em><em>initializer</em><em>­</em><em><sub>opt</sub></em>­ <em>willSet-didSet-block</em><em>­</em>
<em>variable-declaration-head </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­ </em><em><sub>opt</sub></em>­ <em>declaration-modifiers</em><em>­</em><em><sub>opt</sub></em>­ <strong>var­</strong>
<em>variable-name </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­</em>
<em>getter-setter-block </em>→ <em>code-block</em><em>­</em>
<em>getter-setter-block </em>→ <strong>{­ </strong><em>getter-clause</em><em>­ </em><em>setter-clause</em><em>­</em><em><sub>opt</sub></em>­ <strong>}­</strong>
<em>getter-setter-block </em>→ <strong>{­ </strong><em>setter-clause</em><em>­ </em><em>getter-clause</em><em>­ </em><strong>}­</strong>
<em>getter-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>get­ </strong><em>code-block</em><em>­</em>
<em>setter-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>set­ </strong><em>setter-name</em><em>­</em><em><sub>opt</sub></em>­ <em>code-block</em><em>­</em>
<em>setter-name </em>→ <strong>(­ </strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­ </em><strong>)­</strong>
<em>getter-setter-keyword-block </em>→ <strong>{­ </strong><em>getter-keyword-clause </em><em>­</em><em>setter-keyword-clause</em><em>­</em><em><sub>opt</sub></em>­ <strong>}­</strong>
<em>getter-setter-keyword-block </em>→ <strong>{­ </strong><em>setter-keyword-clause</em><em>­ </em><em>getter-keyword-clause</em><em>­ </em><strong>}­</strong>
<em>getter-keyword-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>get­</strong>
<em>setter-keyword-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt </sub></em>­<strong>set­</strong>
<em>willSet-didSet-block </em>→ <strong>{­ </strong><em>willSet-clause</em><em>­ </em><em>didSet-clause</em><em>­</em><em><sub>opt</sub></em>­ <strong>}­</strong>
<em>willSet-didSet-block </em>→ <strong>{­ </strong><em>didSet-clause</em><em>­ </em><em>willSet-clause</em><em>­</em><em><sub>opt</sub></em>­ <strong>}­</strong>
<em>willSet-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>willSet­ </strong><em>setter-name</em><em>­</em><em><sub>opt</sub></em>­ <em>code-block</em><em>­</em>
<em>didSet-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>didSet­ </strong><em>setter-name</em><em>­</em><em><sub>opt</sub></em>­ <em>code-block</em><em>­</em></code></pre>
<h3>Грамматика объявления псевдонима типа</h3>
<pre><code class="language-swift"><em>typealias-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <em>access-level-modifier</em><em>­</em><em><sub>opt</sub></em>­ <strong>typealias­ </strong><em>typealias-name</em><em>­ </em><em>typealias-assignment</em><em>­</em>
<em>typealias-name </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­</em>
<em>typealias-assignment </em>→ <strong>= ­</strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type"><em>type</em></a><em>­</em></code></pre>
<h3>Грамматика объявления функции</h3>
<pre><code class="language-swift">function-declaration → function-head function-name generic-parameter-clause<em>­</em><em><sub>opt</sub></em>­ function-signature function-body<em>­</em><em><sub>opt</sub></em>­
‌function-head → attributes<em>­</em><em><sub>opt</sub></em>­ declaration-modifiers<em>­</em><em><sub>opt</sub></em>­ <strong>func</strong>
‌function-name → identifier | operator
‌function-signature → parameter-clause <strong>throws</strong><em>­</em><em><sub>opt</sub></em>­ function-result<em>­</em><em><sub>opt</sub></em>­
‌function-signature → parameter-clause <strong>rethrows </strong>function-result<em>­</em><em><sub>opt</sub></em>­
‌function-result →  <strong>-&gt;</strong> attributes<em>­</em><em><sub>opt</sub></em>­ type
‌function-body → code-block
‌parameter-clause → <strong>() </strong>|<strong> (</strong> parameter-list <strong>)</strong>
‌parameter-list → parameter | parameter <strong>, </strong>parameter-list
‌parameter → external-parameter-name<em>­</em><em><sub>opt</sub></em>­ local-parameter-name type-annotation default-argument-clause<em>­</em><em><sub>opt</sub></em>­
parameter → external-parameter-name<em>­</em><em><sub>opt</sub></em>­ local-parameter-name type-annotation
‌parameter → external-parameter-name<em>­</em><em><sub>opt</sub></em>­ local-parameter-namet ype-annotation <strong>...</strong>
‌external-parameter-name → identifier
‌local-parameter-name → identifier
‌default-argument-clause → <strong>=</strong> expression</code></pre>
<h3>Грамматика объявления перечислений</h3>
<pre><code class="language-swift"><em>enum-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <em>access-level-modifier</em><em>­</em><em><sub>opt</sub></em>­ <em>union-style-enum</em><em>­</em>
<em>enum-declaration </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <em>access-level-modifier</em><em>­</em><em><sub>opt</sub></em>­ <em>raw-value-style-enum</em><em>­</em>
<em>union-style-enum </em>→ <strong>indirect­</strong><em><sub>opt</sub></em>­ <strong>enum­ </strong><em>enum-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause"><em>generic-parameter-clause</em></a><em>­</em><em><sub>opt</sub></em>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause"><em>type-inheritance-clause</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>{­ </strong><em>union-style-enum-members</em><em>­</em><em><sub>opt</sub></em>­ <strong>}­</strong>
<em>union-style-enum-members </em>→ <em>union-style-enum-member</em><em>­ </em><em>union-style-enum-members</em><em>­</em><em><sub>opt</sub></em>­
<em>union-style-enum-member </em>→ <em>declaration</em><em>­ </em>| <em>union-style-enum-case-clause</em><em>­</em>
<em>union-style-enum-case-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>indirect­</strong><em><sub>opt</sub></em>­ <strong>case­ </strong><em>union-style-enum-case-list</em><em>­</em>
<em>union-style-enum-case-list </em>→ <em>union-style-enum-case</em><em>­</em> | <em>union-style-enum-case</em><em>­ </em><strong>, ­</strong><em>union-style-enum-case-list</em><em>­</em>
<em>union-style-enum-case </em>→ <em>enum-case-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/tuple-type"><em>tuple-type</em></a><em>­</em><em><sub>opt</sub></em>­
<em>enum-name </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­</em>
<em>enum-case-name </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­</em>
<em>raw-value-style-enum </em>→ <strong>enum­ </strong><em>enum-name</em><em>­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause"><em>generic-parameter-clause</em></a><em>­</em><em><sub>opt</sub></em>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause"><em>type-inheritance-clause</em></a><em>­ </em><strong>{­ </strong><em>raw-value-style-enum-members </em><em>­</em><strong>}­</strong>
<em>raw-value-style-enum-members </em>→ <em>raw-value-style-enum-member</em><em>­ </em><em>raw-value-style-enum-members</em><em>­</em><em><sub>opt</sub></em>­
<em>raw-value-style-enum-member </em>→ <em>declaration</em><em>­</em> <em>raw-value-style-enum-case-clause</em><em>­</em>
<em>raw-value-style-enum-case-clause </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes"><em>attributes</em></a><em>­</em><em><sub>opt</sub></em>­ <strong>case­ </strong><em>raw-value-style-enum-case-list</em><em>­</em>
<em>raw-value-style-enum-case-list </em>→ <em>raw-value-style-enum-case</em><em>­</em> | <em>raw-value-style-enum-case </em><em>­</em><strong>,­ </strong><em>raw-value-style-enum-case-list</em><em>­ </em>
<em>raw-value-style-enum-case </em>→ <em>enum-case-name</em><em>­ </em><em>raw-value-assignment</em><em>­</em><em><sub>opt</sub></em>­
<em>raw-value-assignment </em>→ <strong>=­ </strong><em>raw-value-literal</em><em>­</em>
<em>raw-value-literal </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/numeric-literal"><em>numeric-literal</em></a><em>­</em> | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/static-string-literal"><em>static-string-literal</em></a><em>­</em> | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/boolean-literal"><em>boolean-literal</em></a><em>­</em></code></pre>
<h3>Грамматика объявления структур</h3>
<pre><code class="language-swift">struct-declaration → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­ <code>struct­ - </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-name">struct-name</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-where-clause">generic-where-clause</a>­<sub>opt </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-body">struct-body</a>­ struct-name → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ struct-body → <code>{­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-members">struct-members</a>­<sub>opt</sub>­ <code>}­</code> struct-members → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-member">struct-member</a>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/struct-members">struct-members</a>­<sub>opt</sub>­ struct-member → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration">declaration</a>­  |  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/compiler-control-statement">compiler-control-statement</a>­</code></pre>
<h3>Грамматика объявления класса</h3>
<pre><code class="language-swift">class-declaration → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­  <code>final­</code><sub>opt</sub>­  <code>class­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-name">class-name</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt  </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-where-clause">generic-where-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-body">class-body</a>­ class-declaration → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <code>final­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt  </sub>­<code>class­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-name">class-name</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt  </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-where-clause">generic-where-clause</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-body">class-body</a>­ class-name → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ class-body → <code>{­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-members">class-members</a>­<sub>opt</sub>­ <code>}­</code> class-members → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-member">class-member</a>  ­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/class-members">class-members</a>­<sub>opt</sub>­ class-member → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration">declaration</a>­  |  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/compiler-control-statement">compiler-control-statement</a>­</code></pre>
<h3>Грамматика объявления протокола</h3>
<pre><code class="language-swift">protocol-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­ <strong><code>protocol­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-name">protocol-name</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-body">protocol-body</a>­ protocol-name → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ protocol-body → <code><strong>{­</strong> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-member-declarations">protocol-member-declarations</a>­<sub>opt</sub>­ <strong><code>}­</code></strong> protocol-member-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-property-declaration">protocol-property-declaration</a>­ protocol-member-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-method-declaration">protocol-method-declaration</a>­ protocol-member-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-initializer-declaration">protocol-initializer-declaration</a>­ protocol-member-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-subscript-declaration">protocol-subscript-declaration</a>­ protocol-member-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-associated-type-declaration">protocol-associated-type-declaration</a>­ protocol-member-declarations → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-member-declaration">protocol-member-declaration</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/protocol-member-declarations">protocol-member-declarations</a>­<sub>opt</sub>­</code></pre>
<h3>Грамматика объявления свойств протокола</h3>
<pre><code class="language-swift">protocol-property-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/variable-declaration-head">variable-declaration-head</a>­  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/variable-name">variable-name</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation">type-annotation</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/getter-setter-keyword-block">getter-setter-keyword-block</a>­</code></pre>
<h3>Грамматика объявления метода протокола</h3>
<pre><code class="language-swift">protocol-method-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/function-head">function-head</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/function-name">function-name</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt   </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/function-signature">function-signature</a>­</code></pre>
<h3>Грамматика объявления инициализатора протокола</h3>
<pre><code class="language-swift">protocol-initializer-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-head">initializer-head</a>­  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt </sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/parameter-clause">parameter-clause</a> ­<strong><code>throws­</code></strong><sub>opt</sub>­ protocol-initializer-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-head">initializer-head</a>  ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt </sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/parameter-clause">parameter-clause</a>­ <strong><code>rethrows­</code></strong></code></pre>
<h3>Грамматика объявления сабскрипта протокола</h3>
<pre><code class="language-swift">protocol-subscript-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-head">subscript-head</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-result">subscript-result</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/getter-setter-keyword-block">getter-setter-keyword-block</a>­</code></pre>
<h3>Грамматика объявления ассоциированного типа</h3>
<pre><code class="language-swift">protocol-associated-type-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­ <strong><code>associatedtype­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/typealias-name">typealias-name</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/typealias-assignment">typealias-assignment</a>­<sub>opt</sub>­</code></pre>
<h3>Грамматика объявления инициализатора</h3>
<pre><code class="language-swift">initializer-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-head">initializer-head</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/parameter-clause">parameter-clause</a>­ <strong><code>throws­</code></strong><sub>opt </sub>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-body">initializer-body</a>­ initializer-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-head">initializer-head</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-clause">generic-parameter-clause</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/parameter-clause">parameter-clause</a>­ <code><strong>rethrows</strong>­ </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer-body">initializer-body</a>­ initializer-head → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifiers">declaration-modifiers</a>­<sub>opt</sub>­ <strong><code>init­</code></strong> initializer-head → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifiers">declaration-modifiers</a>­<sub>opt</sub>­ <strong><code>init­</code></strong><code><strong>?</strong>­</code> initializer-head → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifiers">declaration-modifiers</a>­<sub>opt</sub>­ <strong><code>init­</code></strong><code><strong>!</strong>­</code> initializer-body → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика объявления деинициализатора</h3>
<pre><code class="language-swift">deinitializer-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <code><strong>deinit­</strong> </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­</code></pre>
<h3>Грамматика объявления расширений</h3>
<pre><code class="language-swift">extension-declaration → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­  <strong><code>extension­ </code></strong><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>  ­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-inheritance-clause">type-inheritance-clause</a>­<sub>opt  </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-body">extension-body</a>­ extension-declaration → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt  </sub>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­<sub>opt</sub>­  <code><strong>extension </strong>­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-where-clause">generic-where-clause</a>  ­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-body">extension-body</a>­ extension-body → <code>{­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-members">extension-members</a>­<sub>opt</sub>­ <code>}­</code> extension-members → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-member">extension-member</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-members">extension-members</a>­<sub>opt</sub>­ extension-member → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration">declaration</a>­  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/compiler-control-statement">compiler-control-statement</a>­</code></pre>
<h3>Грамматика объявления сабскрипта</h3>
<pre><code class="language-swift">subscript-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-head">subscript-head</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-result">subscript-result</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block">code-block</a>­
subscript-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-head">subscript-head</a> ­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-result">subscript-result</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/getter-setter-block">getter-setter-block</a>­
subscript-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-head">subscript-head</a>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/subscript-result">subscript-result</a>­<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/getter-setter-keyword-block">getter-setter-keyword-block</a>­
subscript-head → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifiers">declaration-modifiers</a>­<sub>opt</sub>­ <strong><code>subscript­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/parameter-clause">parameter-clause</a>­ subscript-result → <code>-&gt;­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­</code></pre>
<h3>Грамматика объявления оператора</h3>
<pre><code class="language-swift">operator-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/prefix-operator-declaration">prefix-operator-declaration</a>­ <code>|</code><em><code> </code></em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/postfix-operator-declaration">postfix-operator-declaration</a>­ <code>| </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/infix-operator-declaration">infix-operator-declaration</a>­ prefix-operator-declaration → <strong><code>prefix­ </code></strong><code><strong>operator </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­ postfix-operator-declaration → <strong><code>postfix­ </code><code>operator­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­ infix-operator-declaration → <strong><code>infix­ </code></strong><code><strong>operator </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­<code><strong> </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/infix-operator-attributes">infix-operator-attributes</a>­<sub>opt</sub>­ infix-operator-group → :­ <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-name">precedence-group-name</a>­</code></pre>
<pre><code class="language-swift">operator-declaration → <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/prefix-operator-declaration">prefix-operator-declaration</a>­ <code>|</code><em><code> </code></em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/postfix-operator-declaration">postfix-operator-declaration</a>­ <code>| </code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/infix-operator-declaration">infix-operator-declaration</a>­ prefix-operator-declaration → <strong><code>prefix­ </code></strong><code><strong>operator </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­ postfix-operator-declaration → <strong><code>postfix­ </code><code>operator­ </code></strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­ infix-operator-declaration → <strong><code>infix­ </code></strong><code><strong>operator </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/operator">operator</a>­<code><strong> </strong>­</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/infix-operator-attributes">infix-operator-attributes</a>­<sub>opt</sub>­ infix-operator-group → :­ <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-name">precedence-group-name</a>­</code></pre>
<h3>Грамматика объявления групп приоритета</h3>
<pre><code class="language-swift">recedence-group-declaration → <code>precedencegroup­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-name">precedence-group-name</a>­ <code>{­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-attributes">precedence-group-attributes</a>­ <sub>opt</sub>­ <code>}­</code> precedence-group-attributes → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-attribute">precedence-group-attribute</a> ­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-attributes">precedence-group-attributes</a>­ <sub>opt</sub>­ precedence-group-attribute → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-relation">precedence-group-relation</a>­ precedence-group-attribute → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-assignment">precedence-group-assignment</a>­ precedence-group-attribute → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-associativity">precedence-group-associativity</a>­ precedence-group-relation → <strong><code>higherThan­ </code></strong><code><strong>:­</strong> </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-names">precedence-group-names</a>­ precedence-group-relation → <strong><code>lowerThan­ </code><code>: ­</code></strong><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-names">precedence-group-names</a>­ precedence-group-assignment → <strong><code>assignment­ </code></strong><code><strong>:­</strong> </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/boolean-literal">boolean-literal</a>­ precedence-group-associativity → <strong><code>associativity­ </code><code>:­ </code><code>left­</code></strong> precedence-group-associativity → <strong><code>associativity­ </code><code>:­ </code><code>right­</code></strong> precedence-group-associativity → <strong><code>associativity­ </code><code>: ­</code><code>none­</code></strong> precedence-group-names → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-name">precedence-group-name</a>­  |  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-name">precedence-group-name</a>­<code>,­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/precedence-group-names">precedence-group-names</a>­ precedence-group-name → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­</code></pre>
<h3>Грамматика объявления модификатора</h3>
<pre><code class="language-swift">declaration-modifier → <strong><code>class­</code> </strong>| <strong><code>convenience­</code> </strong>| <strong><code>dynamic­</code> </strong>| <strong><code>final­</code> </strong>| <strong><code>infix­</code> </strong>| <strong><code>lazy­</code> </strong>| <strong><code>optional­</code> </strong>| <strong><code>override­</code> </strong>| <strong><code>postfix­</code> </strong>| <strong><code>prefix­</code> </strong>| <strong><code>required­</code> </strong>| <strong><code>static­</code> </strong>| <strong><code>unowned­</code> </strong>| <strong><code>unowned­</code><code>(­</code><code>safe­</code><code>)­</code></strong> | <strong><code>unowned­</code><code>(­</code><code>unsafe­</code><code>)­</code></strong> | <strong><code>weak­</code></strong> declaration-modifier → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/access-level-modifier">access-level-modifier</a>­ declaration-modifier → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/mutation-modifier">mutation-modifier</a>­ declaration-modifiers → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifier">declaration-modifier</a>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/declaration-modifiers">declaration-modifiers</a>­<sub>opt</sub>­ access-level-modifier → <strong><code>private­</code>  </strong>| <strong><code>private­</code><code>(­</code><code>set­</code></strong><code><strong>)</strong>­</code> access-level-modifier → <strong><code>fileprivate­</code> </strong>| <strong><code>fileprivate­</code><code>(­</code><code>set­</code><code>)­</code></strong> access-level-modifier → <strong><code>internal­</code> </strong>| <strong><code>internal­</code><code>(­</code><code>set­</code><code>)­</code></strong> access-level-modifier → <strong><code>public­</code> </strong>| <strong><code>public­</code><code>(­</code><code>set­</code><code>)­</code></strong> access-level-modifier → <strong><code>open­</code> </strong>| <strong><code>open­</code><code>(­</code><code>set­</code><code>)­</code></strong> mutation-modifier → <strong><code>mutating­</code> </strong>| <strong><code>nonmutating­</code></strong></code></pre>
<h2>Атрибуты</h2>
<h3>Грамматика атрибута</h3>
<pre><code class="language-swift">attribute → <code>@­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attribute-name">attribute-name</a>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attribute-argument-clause">attribute-argument-clause</a>­<sub>opt</sub>­ attribute-name → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier">identifier</a>­ attribute-argument-clause → <code>(­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-tokens">balanced-tokens</a>­<sub>opt</sub>­ <code>)­</code> attributes → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attribute">attribute</a>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/attributes">attributes</a>­<sub>opt</sub>­ balanced-tokens → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-token">balanced-token</a>­<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-tokens">balanced-tokens</a>­<sub>opt</sub>­ balanced-token → <code>(­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-tokens">balanced-tokens</a>­<sub>opt</sub>­ <code>)­</code> balanced-token → <code>[ ­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-tokens">balanced-tokens</a>­<sub>opt</sub>­<code>] ­</code> balanced-token → <code>{­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/swift/grammar/balanced-tokens">balanced-tokens</a>­<sub>opt</sub>­ <code>}­</code> balanced-token → Any identifier, keyword, literal, or operator balanced-token → Any punctuation except <code>(­</code>, <code>)­</code>, <code>[­</code>, <code>]­</code>, <code>{­</code>, or <code>}­</code></code></pre>
<h2>Шаблоны</h2>
<h3>Грамматика шаблонов</h3>
<pre><code class="language-swift"><em>pattern </em>→ <em>wildcard-pattern </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em><sub>opt</sub></em>­
<em>pattern </em>→ <em>identifier-pattern­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em><sub>opt</sub></em>­
<em>pattern </em>→ <em>value-binding-pattern</em>
<em>pattern </em>→ <em>tuple-pattern­ </em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-annotation"><em>type-annotation</em></a><em>­<sub>opt</sub></em>­
<em>pattern </em>→ <em>enum-case-pattern­</em>
<em>pattern </em>→ <em>optional-pattern­</em>
<em>pattern </em>→ <em>type-casting-pattern­</em>
<em>pattern </em>→ <em>expression-pattern­</em></code></pre>
<h3>Грамматика шаблона wildcard</h3>
<pre><code class="language-swift"><em>wildcard-pattern </em>→ <span class="inline-pre">_­</span></code></pre>
<h3>Грамматика шаблона идентификатора</h3>
<pre><code class="language-swift"><em>identifier-pattern </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a></code></pre>
<h3>Грамматика шаблона присваивающего значение</h3>
<pre><code class="language-swift"><em>value-binding-pattern </em>→ <span class="inline-pre">var­ </span><em>pattern­</em> <span class="inline-pre">let­ </span><em>pattern­</em></code></pre>
<h3>Грамматика шаблона кортежа</h3>
<pre><code class="language-swift"><em>tuple-pattern </em>→ <span class="inline-pre">(­ </span><em>tuple-pattern-element-list­<sub>opt </sub></em>­<span class="inline-pre">) ­</span>
<em>tuple-pattern-element-list </em>→ <em>tuple-pattern-element­</em> | <em>tuple-pattern-element­</em><span class="inline-pre">,­ </span><em>tuple-pattern-element-list­</em>
<em>tuple-pattern-element </em>→ <em>pattern­</em> | <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/swift/grammar/identifier"><em>identifier</em></a><em>­ </em><span class="inline-pre">:­ </span><em>pattern­</em></code></pre>
<h3>Грамматика кейса перечисления</h3>
<pre><code class="language-swift"><em>enum-case-pattern </em>→ <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier"><em>type-identifier</em></a><em>­<sub>opt</sub></em>­ <strong>.­ </strong><em><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/enum-case-name">enum-case-name</a> ­tuple-pattern­<sub>opt</sub></em>­</code></pre>
<h3>Грамматика опционального шаблона</h3>
<pre><code class="language-swift"><em>optional-pattern </em>→ <em>identifier-pattern­</em><strong>?­</strong></code></pre>
<h3>Грамматика шаблона приведения типа</h3>
<pre><code class="language-swift"><em>type-casting-pattern </em>→ <em>is-pattern­</em> <em>as-pattern­</em>
<em>is-pattern </em>→ <strong>is­ </strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type"><em>type</em></a>
<em>as-pattern </em>→ <em>pattern­ </em><strong>as­ </strong><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type"><em>type</em></a></code></pre>
<h3>Грамматика шаблона выражения</h3>
<pre><code class="language-swift"><em>expression-pattern </em>→<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression"> <em>expression</em></a></code></pre>
<h2>Параметры и аргументы универсального типа</h2>
<h3>Грамматика условия универсального параметра</h3>
<pre><code class="language-swift">generic-parameter-clause → <code>&lt;­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-list">generic-parameter-list</a>­<code>&gt;­</code> generic-parameter-list → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter">generic-parameter</a>­  | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter">generic-parameter</a>­<code>,­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-parameter-list">generic-parameter-list</a>­ generic-parameter → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-name">type-name</a>­ generic-parameter → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-name">type-name</a>­<code>:­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ generic-parameter → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-name">type-name</a>­<code>:­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-composition-type">protocol-composition-type</a>­ generic-where-clause → <code>where­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/requirement-list">requirement-list</a>­ requirement-list → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/requirement">requirement</a>­  | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/requirement">requirement</a>­<code>,­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/requirement-list">requirement-list</a>­ requirement → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/conformance-requirement">conformance-requirement</a>­  | <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/swift/grammar/same-type-requirement">same-type-requirement</a>­ conformance-requirement → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ <code>: ­</code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ conformance-requirement → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ <code>:­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/protocol-composition-type">protocol-composition-type</a>­ same-type-requirement → <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier">type-identifier</a>­ <code>==­ </code><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type">type</a>­</code></pre>
<h3>Грамматика условия универсального аргумента</h3>
<pre><code class="language-swift"><em>generic-argument-clause </em>→ <strong>&lt;­ </strong><em>generic-argument-list </em><strong>&gt;­</strong>
<em>generic-argument-list </em>→ <em>generic-argument</em> | <em>generic-argument</em><strong>,­ </strong><em>generic-argument-list</em>
<em>generic-argument </em>→<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type"> <em>type</em></a></code></pre>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/language-reference/generic-parameters-and-arguments" rel="2082"  >Параметры и аргументы универсального типа</a></p>
<p class="next-link"><a href="#" rel="0" > </a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/language-reference/%d1%80%d0%b5%d0%b7%d1%8e%d0%bc%d0%b5-%d0%bf%d0%be-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b5/">Резюме по грамматике</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Продвинутые операторы
https://swiftbook.ru/content/languageguide/advanced-operators/
				Sun, 29 Jul 2018 12:06:24 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=7022
<p>Продвинутые операторы В дополнение к операторам, которые мы рассматривали в главе Базовые операторы, Swift предоставляет нам еще несколько продвинутых операторов, которые позволяют нам проводить более сложные манипуляции со значениями. Они включают в себя побитовые и операторы разрядного смещения, с которыми вы возможно знакомы из языков C или Objective-C. В отличии от арифметических операторов C, арифметические [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/advanced-operators/">Продвинутые операторы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p><a name="advanced-operators"></a></p>
<h1>Продвинутые операторы</h1>
<p>В дополнение к операторам, которые мы рассматривали в главе <a href="https://swiftbook.ru/content/languageguide/basic-operators/#top">Базовые операторы</a>, Swift предоставляет нам еще несколько продвинутых операторов, которые позволяют нам проводить более сложные манипуляции со значениями. Они включают в себя побитовые и операторы разрядного смещения, с которыми вы возможно знакомы из языков C или Objective-C.</p>
<p>В отличии от арифметических операторов C, арифметические операторы в Swift не переполняются по умолчанию. Переполнения отслеживаются и выводятся как ошибка. Для того, чтобы этого избежать, вы можете использовать оператор из второго набора арифметических операторов Swift (<span class="inline-pre">&amp;+</span>). Все операторы переполнения начинаются с амперсанда (<span class="inline-pre">&amp;</span>).</p>
<p>Когда вы определяете ваши собственные структуры, классы или перечисления, то может быть полезным обеспечивать ваши собственные реализации стандартных операторов Swift, для этих пользовательских типов. Swift позволяет создавать адаптивные реализации этих операторов, так что вы можете определить их поведения для каждого конкретного типа, который вы создаете.</p>
<p>Вы не ограничены в предопределенных операторах. Swift дает вам свободу определять ваши собственные префиксные, инфиксные, постфиксные операторы и операторы присваивания, которым вы можете задавать собственный приоритет и ассоциативность значений. Эти операторы могут быть использованы и приняты вашим кодом, как и любой другой предопреленный оператор, вы так же можете расширить уже существующие типы, для того, чтобы они могли поддерживать ваши пользовательские операторы.</p>
<h1>Побитовые операторы</h1>
<p>Побитовые операторы позволяют вам манипулировать отдельными битами необработанных данных внутри структуры данных. Они часто используются в низкоуровневом программировании, например программирование графики или создание драйвера для устройства. Побитовые операторы также могут быть полезны, когда вы работаете с необработанными данными из внешних ресурсов, например, кодирование или декодирование данных для связи через собственный протокол.</p>
<p>Swift поддерживает все побитовые операторы, которые были основаны в C о которых мы поговорим далее.</p>
<h2>Побитовый оператор NOT</h2>
<p>Побитовый оператор NOT (<span class="inline-pre">~</span>) инвертирует все битовые числа:</p>
<p style="text-align: center;"><img style="width: 447px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitwiseNOT_2x.png" alt="" /></p>
<p>Побитовый оператор NOT является префиксным оператором и ставится прямо перед значением (без пробела), над которым он оперирует.</p>
<pre><code class="swift language-swift">let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // равен 11110000</code></pre>
<p>Целые числа типа <span class="inline-pre">UInt8</span> имеют восемь бит и могут хранить значения от <span class="inline-pre">0</span> до <span class="inline-pre">255</span>. В этом примере инициализируем число типа <span class="inline-pre">UInt8</span>, которое имеет бинарное значение <span class="inline-pre">00001111</span>, которое имеет первые четыре бита равные <span class="inline-pre">0</span>, а вторая четверка битов равна <span class="inline-pre">1.</span> Это эквивалент числа <span class="inline-pre">15</span>.</p>
<p>Далее используем побитовый оператор <span class="inline-pre">NOT</span> для создания новой константы <span class="inline-pre">invertedBits</span>, которая равна <span class="inline-pre">initialBits</span>, но только с перевернутыми битами. То есть теперь все единицы стали нулями, а нули единицами. Значение числа <span class="inline-pre">invertedBits</span> равно <span class="inline-pre">11110000</span>, что является эквивалентом <span class="inline-pre">240</span>.</p>
<h2>Побитовый оператор AND</h2>
<p>Побитовый оператор AND (<span class="inline-pre">&amp;</span>) комбинирует два бита двух чисел. Он возвращает новое число, чье значение битов равно <span class="inline-pre">1</span>, если только оба бита из входящих чисел были равны <span class="inline-pre">1</span>:</p>
<p style="text-align: center;"><img style="width: 447px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitwiseAND_2x.png" alt="" /></p>
<p>В примере ниже, значения <span class="inline-pre">firstSixBits</span> и <span class="inline-pre">lastSixBits</span> имеют четыре бита по середине равными <span class="inline-pre">1.</span> Побитовый оператор AND комбинирует их для создания числа <span class="inline-pre">00111100</span>, которое равно беззнаковому целому числу <span class="inline-pre">60</span>:</p>
<pre><code class="swift language-swift">let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits &amp; lastSixBits  // равен 00111100</code></pre>
<h2>Побитовый оператор OR</h2>
<p>Побитовый оператор OR (<span class="inline-pre">|</span>) сравнивает биты двух чисел. Оператор возвращает новое число, чьи биты устанавливаются на <span class="inline-pre">1</span>, если один из пары битов этих двух чисел имеет бит равный <span class="inline-pre">1</span>:</p>
<p style="text-align: center;"><img style="width: 447px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitwiseOR_2x.png" alt="" /></p>
<p>В примере ниже значения <span class="inline-pre">someBits</span> и <span class="inline-pre">moreBits</span> имеют разные биты со значениями <span class="inline-pre">1.</span> Побитовый оператор OR комбинирует их для создания числа <span class="inline-pre">11111110</span>, что равно беззнаковому целому числу <span class="inline-pre">254</span>:</p>
<pre><code class="swift language-swift">let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // равен 11111110</code></pre>
<h2>Побитовый оператор XOR</h2>
<p>Побитовый оператор XOR или “оператор исключающего OR” (<span class="inline-pre">^</span>), который сравнивает биты двух чисел. Оператор возвращает число, которое имеет биты равные <span class="inline-pre">1</span>, когда биты входных чисел разные, и возвращает <span class="inline-pre">0</span>, когда биты одинаковые:</p>
<p style="text-align: center;"><img style="width: 447px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitwiseXOR_2x.png" alt="" /></p>
<p>В примере ниже, значения <span class="inline-pre">firstBits</span> и <span class="inline-pre">otherBits</span> каждый имеет один бит в том месте, где у другого <span class="inline-pre">0.</span> Побитовый оператор XOR устанавливает оба этих бита в качестве выходного значения. Все остальные биты повторяются, поэтому оператор возвращает <span class="inline-pre">0</span>:</p>
<pre><code class="swift language-swift">let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // равен 00010001</code></pre>
<h2><a id="bitwise-operators"></a>Операторы побитового левого и правого сдвига</h2>
<p>Оператор побитового левого сдвига (<span class="inline-pre">&lt;&lt;</span>) и оператор побитового правого сдвига (<span class="inline-pre">&gt;&gt;</span>) двигают все биты числа влево или вправо на определенное количество мест, в зависимости от правил, которые определены ниже.</p>
<p>Побитовые операторы левого и правого сдвига имеют эффект умножения или деления числа на <span class="inline-pre">2.</span> Сдвигая биты целого числа влево на одну позицию, мы получаем удвоенное первоначальное число, в то время как, двигая его вправо на одну позицию, мы получаем первоначальное число поделённое на <span class="inline-pre">2</span>.</p>
<h3>Поведение сдвига для беззнаковых целых чисел</h3>
<p>Поведение побитового сдвига имеет следующие правила:</p>
<ul>
<li>Существующие биты сдвигаются вправо или влево на требуемое число позиций.</li>
<li>Любые биты, которые вышли за границы числа, отбрасываются.</li>
<li>На пустующие позиции сдвинутых битов вставляются нули.</li>
</ul>
<p>Такой подход называется <em>логическим сдвигом</em>.</p>
<p>Иллюстрация внизу отображает результат смещения <span class="inline-pre">11111111 &lt;&lt; 1</span> (что означает <span class="inline-pre">11111111</span> сдвинутые влево на <span class="inline-pre">1</span>), и <span class="inline-pre">11111111 &gt;&gt; 1</span> (что означает <span class="inline-pre">11111111</span> сдвинутые на <span class="inline-pre">1</span> вправо). Голубые цифры - сдвинутые, серые - отброшенные, оранжевые - вставленные:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftUnsigned_2x.png" alt="" /></p>
<p>Вот как выглядит побитовый сдвиг в виде Swift кода:</p>
<pre><code class="swift language-swift">let shiftBits: UInt8 = 4   // 00000100 бинарный вид
shiftBits &lt;&lt; 1       // 00001000
shiftBits &lt;&lt; 2       // 00010000
shiftBits &lt;&lt; 5       // 10000000
shiftBits &lt;&lt; 6       // 00000000
shiftBits &gt;&gt; 2       // 00000001</code></pre>
<p>Вы можете использовать побитовый сдвиг для кодирования и декодирования значений внутри других типов данных:</p>
<pre><code class="swift language-swift">let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent равен 0xCC, или 204
let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent равен 0x66, или 102
let blueComponent = pink &amp; 0x0000FF // blueComponent равен 0x99, или 153</code></pre>
<p>Этот пример использует <span class="inline-pre">UInt32</span>, который называется <span class="inline-pre">pink</span>, для хранения значения розового цвета из файла CSS. Значение розового цвета #<span class="inline-pre">CC6699</span>, что записывается в виде шестнадцатеричном представлении Swift как <span class="inline-pre">0xCC6699</span>. Этот цвет затем раскладывается на его красный(<span class="inline-pre">CC</span>), зеленый (<span class="inline-pre">66</span>) и голубой (<span class="inline-pre">99</span>) компоненты при помощи побитового оператора AND (<span class="inline-pre">&amp;</span>) и побитового оператора правого сдвига (<span class="inline-pre">&gt;&gt;</span>).</p>
<p>Красный компонент получен с помощью побитового оператора AND между числами <span class="inline-pre">0xCC6699</span> и <span class="inline-pre">0xFF0000</span>. Нули в <span class="inline-pre">0xFF0000</span> фактически являются “маской” для третьего и четвертого бита в <span class="inline-pre">0xCC6699</span>, тем самым заставляя игнорировать <span class="inline-pre">6699</span>, и оставляя <span class="inline-pre">0xCC0000</span> в качестве результата.</p>
<p>После этого число сдвигается на <span class="inline-pre">16</span> позиций вправо (<span class="inline-pre">&gt;&gt; 16</span>). Каждая пара символов в шестнадцатеричном числе использует 8 битов, так что сдвиг вправо на <span class="inline-pre">16</span> позиций преобразует число <span class="inline-pre">0xCC0000</span> в <span class="inline-pre">0x0000CC</span>. Это то же самое, что и <span class="inline-pre">0xCC</span>, которое имеет целое значение равное <span class="inline-pre">204</span>.</p>
<p>Аналогично с зеленым компонентом, который получается путем использования побитового оператора AND между числами <span class="inline-pre">0xCC6699</span> и <span class="inline-pre">0x00FF00</span>, который в свою очередь дает нам выходное значение <span class="inline-pre">0x006600</span>. Это выходное значение затем сдвигается на восемь позиций вправо, давая нам значение <span class="inline-pre">0x66</span>, что имеет целое значение равное <span class="inline-pre">102</span>.</p>
<p>Ну а теперь последний синий компонент, который получается при использовании побитового оператора AND между числами <span class="inline-pre">0xCC6699</span> и <span class="inline-pre">0x0000FF</span>, что в свою очередь дает нам выходное значение равное <span class="inline-pre">0x000099</span>. Таким образом, нам не нужно сдвигать это вправо, так как <span class="inline-pre">0x000099</span> уже равно <span class="inline-pre">0x99</span>, что имеет целое значение равное <span class="inline-pre">153</span>.</p>
<h3>Поведение побитового сдвига для знаковых целых чисел</h3>
<p>Поведение побитового сдвига для знаковых целых чисел более сложное, чем для беззнаковых, из-за того, как они представлены в бинарном виде. (Пример ниже основан на восьми битовом знаковом целом числе для простоты примера, однако этот принцип применим к знаковым целым числам любого размера).</p>
<p>Знаковые целые числа используют первый бит (известный как знаковый бит) для индикации того, является ли число положительным или отрицательным. Значение знакового бита равное <span class="inline-pre">0</span> свидетельствует о положительном числе, <span class="inline-pre">1</span> - отрицательном.</p>
<p>Остальные биты (известные как биты значения) хранят фактическое значение. Положительные числа хранятся в точности так же как и беззнаковые целые числа, считая от <span class="inline-pre">0.</span> Вот как выглядят биты внутри <span class="inline-pre">Int8</span> для числа <span class="inline-pre">4</span>:</p>
<p style="text-align: center;"><img style="width: 396px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftSignedFour_2x.png" alt="" /></p>
<p>Знаковый бит равен <span class="inline-pre">0</span> (число положительное), остальные семь битов означают число <span class="inline-pre">4</span>, записанное в бинарной форме.</p>
<p>Однако отрицательные числа хранятся иначе. Они хранятся путем вычитания их абсолютного значения из 2 в степени n, где n - количество битов значения.</p>
<p>Вот как выглядит биты внутри <span class="inline-pre">Int8</span> для числа -<span class="inline-pre">4</span>:</p>
<p style="text-align: center;"><img style="width: 396px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftSignedMinusFour_2x.png" alt="" /></p>
<p>В этот раз, знаковый бит равен <span class="inline-pre">1</span> (число отрицательное), а остальные семь знаковых бита имеют бинарное значение числа <span class="inline-pre">124</span> (что означает 128 - 4):</p>
<p style="text-align: center;"><img style="width: 393px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftSignedMinusFourValue_2x.png" alt="" /></p>
<p>Кодирование отрицательных чисел известно под названием <em>дополнительный код</em>. Это может показаться необычным способом для отображения отрицательных чисел, но в нем есть несколько преимуществ.</p>
<p>Первое. Вы можете добавить -<span class="inline-pre">1</span> к -<span class="inline-pre">4</span>, просто выполняя стандартное сложение всех восьми битов (включая и восьмой бит), и отбрасывая все, что не поместится в ваши восемь бит:</p>
<p style="text-align: center;"><img style="width: 446px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftSignedAddition_2x.png" alt="" /></p>
<p>Второе. Представление “дополнительного кода” также позволяет вам сдвигать биты отрицательных чисел влево и вправо, как в случае с положительными, и все так же умножая их при сдвиге влево или уменьшая их в два раза, при сдвиге на 1 место вправо. Для того чтобы обеспечить такое поведение при движении знаковых чисел вправо, мы должны применить дополнительное правило: Когда вы сдвигаете знаковое число вправо, используйте то же самое правило, что и для беззнаковых чисел, но заполняйте освободившиеся левые биты знаковыми битами, а не нулями.</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/bitshiftSigned_2x.png" alt="" /></p>
<p>Эти действия гарантируют вам, что знаковые числа имеют тот же знак, после того как они сдвинуты вправо, и эти действия известны как <em>арифметический сдвиг</em>.</p>
<p>Из-за такого способа хранения положительных и отрицательных чисел, сдвиг вправо двигает их значение ближе к нулю. Оставляя знаковый бит тем же самым в течение побитового сдвига, означает, что ваше отрицательное число, так же и остается отрицательным, в то время как его значение так же движется к нулю.</p>
<h1><a id="overflow-operators"></a>Операторы переполнения</h1>
<p>Если вы попытаетесь ввести число в целочисленную константу или переменную, которая не может держать это число, то по умолчанию Swift выдаст сообщение об ошибке, а не будет создавать недействительное значение. Это поведение дает дополнительную безопасность, когда вы работаете с числами, которые слишком велики или слишком малы.</p>
<p>Для примера, целочисленный тип <span class="inline-pre">Int16</span> может держать любое знаковое целое число от -<span class="inline-pre">32768</span> и до <span class="inline-pre">32767</span>. Если вы попытаетесь установить число (константу или переменную) типа <span class="inline-pre">Int16</span> за границами приведенного диапазона, то вы получите ошибку:</p>
<pre><code class="swift language-swift">var potentialOverflow = Int16.max
// potentialOverflow равняется 32767, что является самым большим значением, которое может содержаться в Int16
potentialOverflow += 1
// это вызовет ошибку</code></pre>
<p>Обеспечивая обработку ошибки, когда значение является слишком большим или слишком маленьким, вы получаете намного большую гибкость, для кодирования краевых условий.</p>
<p>Однако, когда вы специально хотите осуществить условие переполнения, чтобы обрезать количество доступных битов, то вы можете получить именно такое поведение, вместо отчета об ошибке переполнения. Swift предоставляет три арифметических <em>оператора переполнения</em>, которые помогают перейти к поведению переполнения для целочисленных вычислений. Все эти операторы начинаются с символа амперсанда (<span class="inline-pre">&amp;</span>):</p>
<ul>
<li>Оператор переполнения с добавлением (<span class="inline-pre">&amp;+</span>)</li>
<li>Оператор переполнения с вычитанием (<span class="inline-pre">&amp;-</span>)</li>
<li>Оператор переполнения с умножением (<span class="inline-pre">&amp;</span>*)</li>
</ul>
<h2>Переполнение значения</h2>
<p>Числа могут переполняться как в положительную, так и в отрицательную сторону.</p>
<p>Ниже приведен пример того, что случится, когда беззнаковое значение позволяет переполнить себя, с использованием оператора (<span class="inline-pre">&amp;+</span>):</p>
<pre><code class="swift language-swift">var willOverflow = UInt8.max
// willOverflow равняется 255, что является наибольшим числом, которое может держать UInt
willOverflow = willOverflow &amp;+ 1
// willOverflow теперь равно 0</code></pre>
<p>Переменная <span class="inline-pre">willOverflow</span> инициализирована самым большим числом, которое может держать <span class="inline-pre">UInt8</span> (<span class="inline-pre">255</span> или в бинарном виде <span class="inline-pre">11111111</span>). Затем оно увеличивается на 1 при помощи оператора переполнения (<span class="inline-pre">&amp;+</span>). Это выталкивает бинарное представление размерности <span class="inline-pre">UInt8</span>, вызывая тем самым переполнение границ, что отображено на диаграмме ниже. Значение, которое остается в пределах границ значения типа <span class="inline-pre">UInt8</span> после переполнения и добавления выглядит как <span class="inline-pre">00000000</span>, или попросту <span class="inline-pre">0</span> в десятичной форме:</p>
<p style="text-align: center;"><img style="width: 486px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/overflowAddition_2x.png" alt="" /></p>
<p>Числа так же могут быть слишком маленькими, чтобы соответствовать определенному типу. Ниже приведен пример с использованием оператора недополнения (<span class="inline-pre">&amp;-</span>)</p>
<pre><code class="language-swift">var unsignedOverflow = UInt8.min
// unsignedOverflow равен 0, что является наименьшим возможным значением UInt8
unsignedOverflow = unsignedOverflow &amp;- 1
// unsignedOverflow теперь равно 255</code></pre>
<p>Самое маленькое значение, которое может держать <span class="inline-pre">UInt8</span> равно <span class="inline-pre">0</span> (что отображается как <span class="inline-pre">00000000</span> в восьмибитной бинарной форме). Если вы из <span class="inline-pre">00000000</span> вычтите <span class="inline-pre">1</span>, с использованием оператора недополнения, число переполнится в обратную сторону к <span class="inline-pre">11111111</span>, или к <span class="inline-pre">255</span> в десятичной форме:</p>
<p style="text-align: center;"><img style="width: 486px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/overflowUnsignedSubtraction_2x.png" alt="" /></p>
<p>Аналогичное недополнение случается и с знаковыми целыми числами. Все вычитание для знаковых целых чисел проводится как прямое бинарное вычитание с учетом знакового бита, в качестве части вычитаемых чисел, что описано в <a href="https://swiftbook.ru/content/languageguide/advanced-operators/#bitwise-operators">Операторы побитового левого и правого сдвига</a>.</p>
<pre><code class="swift language-swift">var signedUnderflow = Int8.min
// signedUnderflow равняется -128, что является самым маленьким числом, которое может держать Int8
signedUnderflow = signedUnderflow &amp;- 1
// signedUnderflow теперь равняется 127</code></pre>
<p>Самым маленьким числом, которое может держать <span class="inline-pre">Int8</span>, является <span class="inline-pre">–128</span>, что записывается в бинарной форме как <span class="inline-pre">10000000</span>. Вычитая <span class="inline-pre">1</span> из этого бинарного числа с оператором недополнения, дает нам значение <span class="inline-pre">01111111</span>, что переключает наш знаковый бит на противоположный и дает нам положительное <span class="inline-pre">127</span>, что является самым большим числом, которое может держать <span class="inline-pre">Int8</span>:</p>
<p style="text-align: center;"><img style="width: 486px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/overflowSignedSubtraction_2x.png" alt="" /></p>
<p>Конечный результат поведения переполнения и недополнения описан выше и одинаково работает как для знаковых, так и для беззнаковых целых чисел. Переполнение всегда переворачивает значение с самого большого на самое маленькое, недополнение всегда переворачивает самое маленькое число на самое большое.</p>
<h1><a id="precedence-and-associativity"></a>Приоритет и ассоциативность</h1>
<p>Оператор <em>приоритета</em> дает некоторым операторам более высокий приоритет по сравнению с остальными. В выражении сначала применяются эти операторы, затем все остальные.</p>
<p>Оператор <em>ассоциативности</em> определяет то, как операторы одного приоритета сгруппированы вместе (или <em>ассоциированы</em> друг с другом), то есть либо они сгруппированы слева, либо справа. Думайте об этом как “они связаны с выражением слева” или “они связаны с выражением справа”.</p>
<p>Это важно учитывать приоритет и ассоциативность каждого оператора, когда работаете с порядком, в котором должно считаться выражение. Вот простой пример. Почему данное выражение имеет равенство <span class="inline-pre">17</span>?</p>
<pre><code class="swift language-swift">2 + 3 % 4 * 5
// это равно 17</code></pre>
<p>Если вы прочитаете это выражение строго слева направо, то вы можете ожидать действия в таком порядке:</p>
<ul>
<li style="list-style-type: none;">
<ul>
<li style="list-style-type: none;">
<ul>
<li><span class="inline-pre">2</span> плюс <span class="inline-pre">3</span> равняется <span class="inline-pre">5</span></li>
<li><span class="inline-pre">5</span> остаток от деления на <span class="inline-pre">4</span> равен <span class="inline-pre">1</span></li>
<li><span class="inline-pre">1</span> умножаем на <span class="inline-pre">5</span> и получаем <span class="inline-pre">5</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Однако, как не крути, правильный ответ равен <span class="inline-pre">17</span>, а не <span class="inline-pre">5</span>. Операторы более высокого приоритета выполняются раньше операторов более низкого приоритета. В Swift, как и в C, оператор умножения (<span class="inline-pre">*</span>) и оператор остатка (<span class="inline-pre">%</span>) имеют более высокий приоритет, чем оператор сложения (<span class="inline-pre">+</span>). В результате они оба вычисляются раньше, чем вычисляется оператор сложения.</p>
<p>Однако оператор умножения и оператор остатка имеют один и тот же приоритет по отношению друг к другу. Для выяснения точного порядка вычисления вы должны обратиться к их ассоциативности. Операторы умножения и остатка оба ассоциируются с выражением слева от себя. Представляйте это, как будто вы добавили скобки вокруг этих частей выражения, начиная слева:</p>
<pre><code class="swift language-swift">2 + ((3 % 4) * 5)</code></pre>
<p>(<span class="inline-pre">3 % 4</span>) равно <span class="inline-pre">3</span>, значит можно записать:</p>
<pre><code class="swift language-swift">2 + (3 * 5)</code></pre>
<p>(<span class="inline-pre">3 * 5</span>) равно <span class="inline-pre">15</span>, и значит мы можем записать:</p>
<pre><code class="swift language-swift">2 + 15</code></pre>
<p>Таким образом наш конечный результат равен <span class="inline-pre">17</span>.</p>
<p>Для получения информации об операторах, предоставляемых стандартной библиотекой Swift, включая полный список групп приоритета операторов и параметров ассоциативности, см. <a href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations">Объявление операторов</a>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Правила приоритета и ассоциативности операторов Swift проще и более предсказуемые чем в C или Objective-C. Однако это означает, что они ведут себя не так же как они вели себя в этих C-языках. Будьте внимательны с тем, как ведут себя операторы взаимодействия при переносе кода в Swift.</p>
</div>
<h1><a id="operator-methods"></a>Операторные функции</h1>
<p>Классы и структуры могут предоставлять свои собственные реализации существующих операторов. Действие переопределения оператора известно как <em>перегрузка </em>существующего оператора.</p>
<p>Пример ниже отображает как можно реализовать арифметический оператор сложения (<span class="inline-pre">+</span>) для пользовательской структуры. Арифметический оператор сложения является <em>бинарным оператором</em>, потому что он оперирует с двумя операндами, то есть он является <em>инфиксным</em>, потому как вставляется между двумя операндами.</p>
<p>Пример определяет структуру <span class="inline-pre">Vector2D</span> для двухмерного вектора положения <span class="inline-pre">(x, y)</span>, за которой идет статическая функция, которая добавляет друг к другу экземпляры структуры <span class="inline-pre">Vector2D</span>:</p>
<pre><code class="swift language-swift">struct Vector2D {
    var x = 0.0, y = 0.0
}
 
extension Vector2D {
    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y + right.y)
    }
}</code></pre>
<p>Операторный метод определен как метод типа <span class="inline-pre">Vector2D</span> с именем метода, которое совпадает с именем оператора, который перегружают (<span class="inline-pre">+</span>). Так как сложение не является неотъемлемой частью поведения вектора, метод типа определен в расширении нашего <span class="inline-pre">Vector2D</span>, а не в основной структуре <span class="inline-pre">Vector2D</span>. Так как арифметический оператор сложения является бинарным оператором, то этот оператор принимает два параметра типа <span class="inline-pre">Vector2D</span> и возвращает единственное выходное значение, которое тоже имеет тип <span class="inline-pre">Vector2D</span>.</p>
<p>В этой реализации входные параметры имеют имена <span class="inline-pre">left</span> и <span class="inline-pre">right</span>, для отображения экземпляров <span class="inline-pre">Vector2D</span>, которые будут по левую и по правую сторону от оператора <span class="inline-pre">+</span>. Функция возвращает новый экземпляр <span class="inline-pre">Vector2D</span>, <span class="inline-pre">x</span> и <span class="inline-pre">y</span> которого инициализированы суммой свойств <span class="inline-pre">x</span> и <span class="inline-pre">y</span> из двух экземпляров <span class="inline-pre">Vector2D</span>, которые были добавлены друг другу.</p>
<p>Метод типа может использоваться как инфиксный оператор между существующими экземплярами <span class="inline-pre">Vector2D</span>:</p>
<pre><code class="swift language-swift">let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector является экземпляром Vector2D, который имеет значения (5.0, 5.0)</code></pre>
<p>Этот пример складывает два вектора вместе <span class="inline-pre">(3.0, 1.0)</span> и <span class="inline-pre">(2.0, 4.0)</span> для создания вектора <span class="inline-pre">(5.0, 5.0)</span>, который нарисован ниже:</p>
<p style="text-align: center;"><img style="width: 387px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/vectorAddition_2x.png" alt="" /></p>
<h2>Префиксные и постфиксные операторы</h2>
<p>Пример, отображенный выше, демонстрирует пользовательскую реализацию бинарного инфиксного оператора. Классы и структуры так же могут обеспечивать реализацию стандартных <em>унарных операторов</em>. Унарные операторы работают с одним операндом. Они бывают <em>префиксными</em>, если они предшествуют их операнду (например, <span class="inline-pre">-a</span>) или <em>постфиксными</em>, если они следуют за операндом (например <span class="inline-pre">b!</span>).</p>
<p>Вы реализуете префиксный или постфиксный унарный оператор при помощи модификаторов <span class="inline-pre">prefix</span> или <span class="inline-pre">postfix</span> перед ключевым словом <span class="inline-pre">func</span>, когда объявляете операторную функцию:</p>
<pre><code class="swift language-swift">extension Vector2D {
    static prefix func - (vector: Vector2D) -&gt; Vector2D {
        return Vector2D(x: -vector.x, y: -vector.y)
    }
}</code></pre>
<p>Пример выше реализует унарный оператор (<span class="inline-pre">-a</span>) для экземпляров <span class="inline-pre">Vector2D</span>. Оператор унарного минуса является префиксным оператором, таким образом эта функция должна быть модифицирована при помощи <span class="inline-pre">prefix</span> модификатора.</p>
<p>Для простых числовых значений оператор унарного минуса конвертирует положительные числа в их негативный эквивалент и наоборот. Соответствующая реализация для экземпляров <span class="inline-pre">Vector2D</span> проводит операции и на <span class="inline-pre">x</span>, и на <span class="inline-pre">y</span> свойствах:</p>
<pre><code class="swift language-swift">let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative - экземпляр Vector2D со значениями (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive - экземпляр Vector2D со значениями (3.0, 4.0)</code></pre>
<h2>Составные операторы присваивания</h2>
<p>Составные операторы присваивания комбинируют оператор присваивания (<span class="inline-pre">=</span>) с другим оператором. Например, оператор сложения-присваивания (<span class="inline-pre">+=</span>) комбинирует в себе оператор добавления и оператор присваивания. Вы обозначаете левый входной параметр составного оператора как <span class="inline-pre">inout</span>, потому что именно эта величина и будет изменена напрямую изнутри самой операторной функции.</p>
<p>Пример ниже реализует операторную функцию добавления-присваивания для экземпляров <span class="inline-pre">Vector2D</span>:</p>
<pre><code class="swift language-swift">extension Vector2D {
    static func += (left: inout Vector2D, right: Vector2D) {
        left = left + right
    }
}</code></pre>
<p>Так как оператор сложения был определен ранее, то вам не нужно реализовывать процесс сложения здесь. Вместо этого оператор сложения-присваивания использует существующую операторную функцию сложения и использует ее для установки нового значения левому значению, как сумму левого и правого значений:</p>
<pre><code class="swift language-swift">var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original теперь имеет значения (4.0, 6.0)</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Нет такой возможности перегрузить оператор присваивания (<span class="inline-pre">=</span>). Только составные операторы могут быть перегружены. Тернарный оператор (<span class="inline-pre">a ? b : c</span>) так же не может быть перегружен.</p>
</div>
<h2><a id="equivalence-operators"></a>Операторы эквивалентности</h2>
<p>Пользовательские классы и структуры не получают дефолтной реализации <em>эквивалентных операторов</em>, известных как “равен чему-то” оператор (<span class="inline-pre">==</span>) или “не равен чему-то” (<span class="inline-pre">!=</span>).</p>
<p>Чтобы использовать операторы эквивалентности для проверки эквивалентности вашего собственного пользовательского типа, предоставьте реализацию для этих операторов тем же самым способом, что и для инфиксных операторов и добавьте соответствие протоколу стандартной библиотеки <span style="color: #333333;">Equatable</span>:</p>
<pre><code class="swift language-swift">extension Vector2D: Equatable {
    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {
        return (left.x == right.x) &amp;&amp; (left.y == right.y)
    }
}</code></pre>
<p>Пример выше реализует оператор “равен чему-то” (<span class="inline-pre">==</span>) для проверки эквивалентности значений двух экземпляров <span class="inline-pre">Vector2D</span>. В контексте <span class="inline-pre">Vector2D</span> имеет смысл считать, что “равно чему-то” означает, что “оба экземпляра имеют одни и те же значения <span class="inline-pre">x</span> и <span class="inline-pre">y</span>”, таким образом это является той логикой, которая используется при реализации оператора. Пример так же реализует оператор “не равен чему-то” (<span class="inline-pre">!=</span>), который просто возвращает обратный результат оператора “равен чему-то”.</p>
<p>Теперь вы можете использовать эти операторы для проверки того, эквивалентны ли экземпляры <span class="inline-pre">Vector2D</span> друг другу или нет:</p>
<pre><code class="swift language-swift">let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {
    print("Эти два вектора эквиваленты.")
}
// Выведет "Эти два вектора эквиваленты."</code></pre>
<p>Swift предоставляет синтезированные реализации операторов эквивалентности для следующих пользовательских типов:</p>
<ul>
<li>Структур, имеющих только свойства хранения, соответствующие протоколу <span class="inline-pre">Equatable</span></li>
<li>Перечислений, имеющих только ассоциированные типы, соответствующие протоколу <span class="inline-pre">Equatable</span></li>
<li>Перечислений, не имеющих связанных типов</li>
</ul>
<p>Объявите о соответствии протоколу <span class="inline-pre">Equatable</span> в исходной  реализации для получения этих дефолтных реализаций.</p>
<p>Приведенный ниже пример определяет структуру <span class="inline-pre">Vector3D</span> для трехмерного вектора положения <span class="inline-pre">(x, y, z)</span>, аналогичную структуре <span class="inline-pre">Vector2D</span>. Поскольку свойства <span class="inline-pre">x</span>, <span class="inline-pre">y</span> и <span class="inline-pre">z</span> являются эквивалентными, <span class="inline-pre">Vector3D</span> принимает стандартные реализации операторов эквивалентности.</p>
<pre><code class="swift language-swift">struct Vector3D: Equatable {
    var x = 0.0, y = 0.0, z = 0.0
}
 
let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
if twoThreeFour == anotherTwoThreeFour {
    print("These two vectors are also equivalent.")
}
// Выведет "These two vectors are also equivalent."</code></pre>
<h1><a id="custom-operators"></a>Пользовательские операторы</h1>
<p>Вы можете объявить и реализовать ваши собственные пользовательские операторы в дополнение к стандартным операторам Swift. Список символов, которые можно использовать для определения пользовательских операторов, см. в разделе «<a href="https://swiftbook.ru/content/language-reference/lexical-structure/#operators">Операторы</a>».</p>
<p>Новые операторы объявляются на глобальном уровне при помощи ключевого слова <span class="inline-pre">operator</span> и отмечаются модификатором <span class="inline-pre">prefix</span>, <span class="inline-pre">infix</span>, <span class="inline-pre">postfix</span>:</p>
<pre><code class="swift language-swift">prefix operator +++</code></pre>
<p>Пример выше определяет новый префиксный оператор <span class="inline-pre">+++</span>. Этот оператор не имеет никакого значения в Swift, таким образом мы даем ему собственное назначение, которое описано чуть ниже, которое имеет специфический контекст работы с экземплярами <span class="inline-pre">Vector2D</span>. Для целей этого примера, оператор <span class="inline-pre">+++</span> рассматривается как новый “префиксный двойной” оператор. Он удваивает значения <span class="inline-pre">x</span> и <span class="inline-pre">y</span> экземпляра <span class="inline-pre">Vector2D</span>, путем добавления вектора самому себе при помощи оператора сложения-присваивания, который мы определили ранее. Для реализации <span class="inline-pre">+++</span> оператора мы добавим метод типа <span class="inline-pre">Vector2D</span> с именем <span class="inline-pre">+++</span> как показано ниже:</p>
<pre><code class="swift language-swift">extension Vector2D {
    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {
        vector += vector
        return vector
    }
}
 
var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled имеет значения (2.0, 8.0)
// afterDoubling так же имеет значения (2.0, 8.0)
</code></pre>
<h2>Приоритет для пользовательских инфиксных операторов</h2>
<p>Каждый пользовательский <span class="inline-pre">infix</span> оператор принадлежит к своей приоритетной группе. Группа приоритета определяет приоритет оператора по отношению к другим инфиксным операторам, так же как и ассоциативность оператора. Посмотрите главу <a href="https://swiftbook.ru/content/languageguide/advanced-operators/#precedence-and-associativity">Приоритет и ассоциативность</a> для объяснения того, как эти две характеристики влияют на взаимодействие инфиксных операторов между собой.</p>
<p>Пользовательскому инфиксному оператору, который явно не размещен в приоритетной группе, предоставляется дефолтная группа приоритета, которая является по приоритету следующей после тернарного условного оператора.</p>
<p>Следующий пример определяет новый инфиксный оператор <span class="inline-pre">+-</span> левой ассоциативности и с приоритетом <span class="inline-pre">AdditionPrecedence</span>:</p>
<pre><code class="swift language-swift">infix operator +-: AdditionPrecedence
extension Vector2D {
    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y - right.y)
    }
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector является экземпляром Vector2D со значениями (4.0, -2.0)</code></pre>
<p>Этот оператор складывает значения x двух векторов и вычитает значение y второго вектора из значения y первого вектора. Так как этот оператор в сущности является оператором “сложения”, то приоритет будет равным операторам сложения (<span class="inline-pre">+</span>) и вычитания (<span class="inline-pre">-</span>). Для получения информации об операторах, представленных стандартной библиотекой Swift, включая список настроек ассоциативности и групп приоритета смотрите раздел "<a href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations">Объявления операторов</a>". Для более полной информации по группам приоритета и для ознакомления с синтаксисом создания своих собственных операторов и групп ассоциативности смотрите "<a href="https://swiftbook.ru/content/language-reference/declarations/#operator-declaration">Объявление оператора</a>".</p>
<div class="tip">
<h4>Заметка</h4>
<p>Вы не указываете приоритет, когда определяете префиксный и постфиксные операторы. Однако, если вы воздействуете на операнд сразу двумя операторами (префиксным и постфиксным), то первым будет применен постфиксный оператор.</p>
</div>
<h2>Result Builders</h2>
<p>Result Builder - это определяемый вами тип, который добавляет синтаксис для создания вложенных данных, таких как список или дерево, естественным, декларативным образом. Код, использующий result builder, может включать обычный синтаксис Swift, например <span class="inline-pre">if</span> и <span class="inline-pre">for</span>, для обработки условных или повторяющихся фрагментов данных.</p>
<p>В приведенном ниже коде определены несколько типов рисования на одной линии с использованием звездочек и текста.</p>
<pre><code class="language-swift">protocol Drawable {
    func draw() -&gt; String
}
struct Line: Drawable {
    var elements: [Drawable]
    func draw() -&gt; String {
        return elements.map { $0.draw() }.joined(separator: "")
    }
}
struct Text: Drawable {
    var content: String
    init(_ content: String) { self.content = content }
    func draw() -&gt; String { return content }
}
struct Space: Drawable {
    func draw() -&gt; String { return " " }
}
struct Stars: Drawable {
    var length: Int
    func draw() -&gt; String { return String(repeating: "*", count: length) }
}
struct AllCaps: Drawable {
    var content: Drawable
    func draw() -&gt; String { return content.draw().uppercased() }
}</code></pre>
<p>Протокол <span class="inline-pre">Drawable</span> определяет требования к чему-то, что можно нарисовать, например линии или фигуре: тип должен реализовывать метод <span class="inline-pre">draw()</span>. Структура <span class="inline-pre">Line</span> представляет собой однолинейный рисунок и служит контейнером верхнего уровня для большинства рисунков. Чтобы нарисовать линию, структура вызывает <span class="inline-pre">draw()</span> для каждого из компонентов линии, а затем объединяет результирующие строки в одну строку. Структура <span class="inline-pre">Text</span> оборачивает строку, чтобы сделать ее частью рисунка. Структура <span class="inline-pre">AllCaps</span> оборачивает и изменяет другой рисунок, преобразуя любой текст в рисунке в верхний регистр.</p>
<p>Можно создать рисунок при помощи этих типов, вызвав их инициализаторы.</p>
<pre><code class="language-swift">let name: String? = "Ravi Patel"
let manualDrawing = Line(elements: [
    Stars(length: 3),
    Text("Hello"),
    Space(),
    AllCaps(content: Text((name ?? "World") + "!")),
    Stars(length: 2),
    ])
print(manualDrawing.draw())
// Выведет "***Hello RAVI PATEL!**"</code></pre>
<p>Этот код работает, но немного неудобен. Глубоко вложенные круглые скобки после <span class="inline-pre">AllCaps</span> трудночитаемы. Логика отката для использования <span class="inline-pre">«World»</span>, когда name равно <span class="inline-pre">nil</span>, должна быть встроена с использованием оператора <span class="inline-pre">??</span>, что было бы сложно использовать в более сложных кейсах. Если вам нужно было встроить инструкцию <span class="inline-pre">switch</span> или цикл <span class="inline-pre">for</span> для создания рисунка, то это было бы просто невозможно. Result Builder позволяет вам переписать такой код, чтобы он выглядел как обычный код на Swift.</p>
<p>Чтобы определить Result Builder, вы пишете атрибут @resultBuilder в объявлении типа. Например, этот код определяет Result Builder под названием DrawingBuilder, который позволяет вам использовать декларативный синтаксис для описания рисунка:</p>
<pre><code class="language-swift">@resultBuilder
struct DrawingBuilder {
    static func buildBlock(_ components: Drawable...) -&gt; Drawable {
        return Line(elements: components)
    }
    static func buildEither(first: Drawable) -&gt; Drawable {
        return first
    }
    static func buildEither(second: Drawable) -&gt; Drawable {
        return second
    }
}</code></pre>
<p>Структура <span class="inline-pre">DrawingBuilder</span> определяет три метода, которые реализуют части синтаксиса Result Builder. Метод <span class="inline-pre">buildBlock(_ :)</span> добавляет поддержку записи серии строк в блоке кода. Он объединяет компоненты в этом блоке в линию. Методы <span class="inline-pre">buildEither(first :)</span> и <span class="inline-pre">buildEither(second :)</span> добавляют поддержку if-else.</p>
<p>Вы можете применить атрибут <span class="inline-pre">@DrawingBuilder</span> к параметру функции, который превращает закрытие, переданное в функцию, в значение, которое построитель результатов создает из этого закрытия. Например:</p>
<pre><code class="language-swift">func draw(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable {
    return content()
}
func caps(@DrawingBuilder content: () -&gt; Drawable) -&gt; Drawable {
    return AllCaps(content: content())
}
func makeGreeting(for name: String? = nil) -&gt; Drawable {
    let greeting = draw {
        Stars(length: 3)
        Text("Hello")
        Space()
        caps {
            if let name = name {
                Text(name + "!")
            } else {
                Text("World!")
            }
        }
        Stars(length: 2)
    }
    return greeting
}
let genericGreeting = makeGreeting()
print(genericGreeting.draw())
// Выведет "***Hello WORLD!**"
let personalGreeting = makeGreeting(for: "Ravi Patel")
print(personalGreeting.draw())
// Выведет "***Hello RAVI PATEL!**"</code></pre>
<p>Функция <span class="inline-pre">makeGreeting(for :)</span> принимает параметр имени и использует его для рисования персонализированного приветствия. Функции <span class="inline-pre">draw(_ :)</span> и <span class="inline-pre">caps(_ :)</span> принимают в качестве аргумента одно закрытие, которое помечается атрибутом <span class="inline-pre">@DrawingBuilder</span>. Когда вы вызываете эти функции, вы используете специальный синтаксис, который определяет <span class="inline-pre">DrawingBuilder</span>. Swift преобразует это декларативное описание рисунка в серию вызовов методов в <span class="inline-pre">DrawingBuilder</span> для создания значения, переданного в качестве аргумента функции. Например, Swift преобразует вызов <span class="inline-pre">caps(_ :)</span> в этом примере в код, подобный следующему:</p>
<pre><code class="language-swift">let capsDrawing = caps {
    let partialDrawing: Drawable
    if let name = name {
        let text = Text(name + "!")
        partialDrawing = DrawingBuilder.buildEither(first: text)
    } else {
        let text = Text("World!")
        partialDrawing = DrawingBuilder.buildEither(second: text)
    }
    return partialDrawing
}</code></pre>
<p>Swift преобразует блок if-else в вызовы методов <span class="inline-pre">buildEither(first :)</span> и <span class="inline-pre">buildEither(second :)</span>. Хотя вы не вызываете эти методы в собственном коде, отображение результата преобразования позволяет легче увидеть, как Swift преобразует ваш код, когда вы используете синтаксис <span class="inline-pre">DrawingBuilder</span>.</p>
<p>Чтобы добавить поддержку записи для циклов в специальном синтаксисе рисования, добавьте метод buildArray(_ :).</p>
<pre><code class="language-swift">extension DrawingBuilder {
    static func buildArray(_ components: [Drawable]) -&gt; Drawable {
        return Line(elements: components)
    }
}
let manyStars = draw {
    Text("Stars:")
    for length in 1...3 {
        Space()
        Stars(length: length)
    }
}</code></pre>
<p>В приведенном выше коде цикл <span class="inline-pre">for</span> создает массив рисунков, а метод <span class="inline-pre">buildArray(_ :)</span> превращает этот массив в <span class="inline-pre">Line</span>.</p>
<div class="mistape_caption">Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/access-control" rel="8819">Контроль доступа</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/language-reference" rel="2074">Справочник языка</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/advanced-operators/">Продвинутые операторы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Контроль доступа
https://swiftbook.ru/content/languageguide/access-control/
				Sun, 29 Jul 2018 08:17:35 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=7017
<p>Контроль доступа Контроль доступа ограничивает доступ к частям вашего кода из кода других исходных файлов и модулей. Эта особенность позволяет вам прятать детали реализации вашего кода и указывать на предпочтительный интерфейс, через который можно получить доступ к вашему коду. Вы можете присвоить определенные уровни доступа как к индивидуальным типам (классы, структуры и перечисления), так и [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/access-control/">Контроль доступа</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p><a name="top"></a></p>
<h1>Контроль доступа</h1>
<p><em>Контроль доступа</em> ограничивает доступ к частям вашего кода из кода других исходных файлов и модулей. Эта особенность позволяет вам прятать детали реализации вашего кода и указывать на предпочтительный интерфейс, через который можно получить доступ к вашему коду.</p>
<p>Вы можете присвоить определенные уровни доступа как к индивидуальным типам (классы, структуры и перечисления), так и к свойствам, методам, инициализаторам и сабскриптам, принадлежащим этим типам. Протоколы могут быть ограничены в определенном контексте, так же как могут быть ограничены глобальные переменные или функции.</p>
<p>В дополнение к предложению контроля различных уровней доступа, Swift уменьшает необходимость указания явного уровня контроля доступа тем, что сам обеспечивает уровни доступа по умолчанию для типичных сценариев. И на самом деле, если вы пишете простое приложение, то вам может и не понадобится указывать явно уровень контроля доступа вообще.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Различные аспекты вашего кода, к которым применим контроль уровня доступа (свойства, типы, функции и т.д.) будем называть “сущности”, для краткости.</p>
</div>
<h1>Модули и исходные файлы</h1>
<p>Модель контроля доступа Swift основывается на концепции модулей и исходных файлов.</p>
<p><em>Модуль</em> представляет из себя единый блок распределения кода - фреймворк или приложение, которое построено и поставляется в качестве единого блока и которое может быть импортировано другим модулем с ключевым словом <span class="inline-pre">import</span>.</p>
<p>Каждый таргет сборки (например, бандл приложения или фреймворк) в Xcode обрабатывается как отдельный модуль. Если вы объедините вместе аспекты кода вашего приложения в качестве отдельного фреймворка, то их возможно будет инкапсулировать и использовать заново во множестве других приложений. Таким образом, все, что вы определите в рамках этого фреймворка будет считаться частью отдельного модуля, когда это будет импортировано и использовано внутри приложения, или когда это будет использовано внутри другого фреймворка.</p>
<p><em>Исходный файл</em> - исходный код файла в пределах одного модуля (в сущности это и есть один файл вашего приложения или фреймворка). Хотя в большинстве случаев определение типов происходит в отдельных исходных файлах, но фактически исходный файл может содержать определения множества различных типов, функций и т.д.</p>
<h1><a id="access-levels"></a>Уровни доступа</h1>
<p>Swift предлагает пять различных уровней доступа для объектов вашего кода. Эти уровни доступа относительны исходному файлу, в котором определен объект, и так же они относительны модулю, которому принадлежит исходный файл:</p>
<ul>
<li><em>Открытый доступ</em> и <em>публичный доступ</em> (<em>open access</em> и <em>public access</em>). Этот уровень доступа позволяет использовать объекты внутри любого исходного файла из определяющего их модуля и так же в любом исходном файле из другого модуля, который импортирует определяющий модуль. Вы обычно используете открытый и публичный доступы, когда указываете общий интерфейс фреймворка. Отличия между этими двумя уровнями доступа будет описаны ниже.</li>
<li><em>Внутренний</em> (<em>internal access</em>). Этот уровень доступа позволяет использовать объекты внутри любого исходного файла из их определяющего модуля, но не исходного файла не из этого модуля. Вы обычно указываете внутренний доступ , когда определяете внутреннюю структуру приложения или фреймворка.</li>
<li><em>Файл-частный</em> (<em>file private</em>). Этот уровень доступа позволяет использовать объект в пределах его исходного файла. Используйте файл-частный уровень доступа для того, чтобы спрятать детали реализации определенной части функциональности, когда эти части функциональности будут использоваться внутри другого файла.</li>
<li><em>Частный</em> (<em>private</em>). Этот уровень доступа позволяет использовать сущность только в пределах области ее реализации. Используйте частный доступ для того, чтобы спрятать детали реализации конкретной части функциональности, когда они используются только внутри области объявления.</li>
</ul>
<p>Открытый доступ - самый высокий уровень доступа (наименее строгий), и частный уровень доступа является самым низким уровнем доступа (самый строгий).</p>
<p>Открытый доступ применяется только к классам и членам класса и отличается от public доступа следующим:</p>
<ul>
<li>Классы, с уровнем доступа <span class="inline-pre">public</span>, могут наследоваться только в том модуле, в котором они определены.</li>
<li>Члены класса с уровнем доступа <span class="inline-pre">public</span> или с более строгим уровнем доступа могут быть переопределены подклассами только в том модуле, в котором они определены.</li>
<li>Открытые классы могут наследоваться внутри модуля, в котором они определены и внутри модуля, который импортирует модуль, в котором они определены.</li>
<li>Открытые члены класса могут переопределяться подклассами внутри модуля, в котором они были определены или внутри модуля, который импортирует модуль, в котором они были определены.</li>
</ul>
<p>Обозначая класс через маркер <span class="inline-pre">open</span>, явно свидетельствует о том, что вы рассмотрели влияние этого класса на код других модулей, использующих его в качестве суперкласса.</p>
<h2>Руководящий принцип по выбору уровня доступа</h2>
<p>Уровни доступа в Swift следуют общему руководящему принципу: <em>никакой объект не может быть определен в пределах другого объекта, который имеет более низкий (более строгий) уровень доступа</em>.</p>
<p>Например:</p>
<ul>
<li>Переменная с уровнем доступа <span class="inline-pre">public</span> не может быть определена как будто она имеет уровень доступа <span class="inline-pre">private</span>, потому что этот уровень доступа не может быть использован везде, где доступен <span class="inline-pre">public</span>.</li>
<li>Функция не может иметь уровень доступа выше чем у ее параметров или возвращаемого типа, потому что функция не может использоваться там, где ее параметры не доступны.</li>
</ul>
<p>Более глубокий смысл данного руководящего принципа для различных аспектов раскрывается ниже.</p>
<h2>Дефолтный уровень доступа</h2>
<p>Все сущности вашего кода (кроме двух исключений, о которых мы поговорим чуточку позже) имеют дефолтный уровень доступа - внутренний (<span class="inline-pre">internal</span>), если вы явно не указываете другой уровень. В результате во многих случаях вам не нужно указывать явный уровень доступа в вашем коде.</p>
<h2>Уровень доступа для простых однозадачных приложений</h2>
<p>Когда вы пишете простое однозадачное приложение, то код вашего приложения обычно самодостаточен и не требует доступа к нему из внешних источников. По умолчанию уровень доступа стоит внутренний, так что это полностью удовлетворяет требованию кода. Таким образом, вам не нужно указывать явно этот уровень доступа. Однако, если вам все таки нужно, то вы можете некоторые части вашего кода обозначить как <span class="inline-pre">fileprivate</span> или <span class="inline-pre">private</span>, для того чтобы спрятать детали реализации от другого кода этого же модуля.</p>
<h2>Уровень доступа для фреймворка</h2>
<p>Когда вы разрабатываете фреймворк, обозначьте внешний интерфейс фреймворка как <span class="inline-pre">open</span>, <span class="inline-pre">public</span>, так чтобы его можно было посмотреть и получить к нему доступ из других модулей, так например, чтобы приложение могло импортировать его. Внешний интерфейс - интерфейс прикладного программирования (API) для фреймворка.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Любые внутренние детали реализации вашего фреймворка могут использоваться с дефолтным уровнем доступа <span class="inline-pre">internal</span>, или они могут быть отмечены как <span class="inline-pre">fileprivate</span> или <span class="inline-pre">private</span>, если вы хотите их спрятать от остального внутреннего кода фреймворка. Вам нужно отметить объект как <span class="inline-pre">open</span> или <span class="inline-pre">public</span>, если вы хотите сделать его частью интерфейса фреймворка.</p>
</div>
<h3>Уровни доступа для модуля поэлементного тестирования (unit test target)</h3>
<p>Когда вы пишете приложение с модулем поэлементного тестирования, то код вашего приложения должен быть доступным для модуля, чтобы он мог его проверить. По умолчанию только сущности с маркировкой <span class="inline-pre">public</span> могут быть доступны для других модулей, однако этот модуль может получить доступ ко всем внутренним сущностям, если вы поставили входную маркировку объявления модуля продукта как <span class="inline-pre">@testable</span> и компилируете со включенным режимом тестирования.</p>
<h1>Синтаксис контроля доступа</h1>
<p>Определите уровень доступа для объекта, установив одно из ключевых слов (<span class="inline-pre">private</span>, <span class="inline-pre">fileprivate</span>, <span class="inline-pre">internal</span>, <span class="inline-pre">public</span>, <span class="inline-pre">open</span>) перед вступительным словом сущности:</p>
<pre><code class="swift language-swift">public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}
 
public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}</code></pre>
<p>Если вы не укажете уровень доступа, то он будет <span class="inline-pre">internal</span> по умолчанию, о чем было поведано в главе <a href="https://swiftbook.ru/content/languageguide/access-control/#access-levels">Уровни доступа</a>. Это значит, что <span class="inline-pre">SomeInternalClass</span> и <span class="inline-pre">someInternalConstant</span> могут быть записаны без явного указания модификатора уровня доступа, и они все равно будут все еще иметь <span class="inline-pre">internal</span> уровень доступа:</p>
<pre><code class="swift language-swift">class SomeInternalClass {}              // неявно internal
let someInternalConstant = 0            // неявно internal</code></pre>
<h1>Пользовательские типы</h1>
<p>Если вы хотите указать явно уровень доступа для пользовательского типа, то делайте это на этапе определения типа. Новый тип может быть использован там, где позволяет его уровень доступа. К примеру, если вы определите класс с уровнем доступа <span class="inline-pre">fileprivate</span>, то он сможет быть использован только как тип свойства или параметр функции или возвращаемый тип в исходном файле, в котором определен этот <span class="inline-pre">fileprivate</span> класс.</p>
<p>Контроль уровня доступа типа так же влияет на уровень доступа для этих членов по умолчанию (его свойств, методов, инициализаторов и сабскриптов). Если вы определяете уровень доступа типа как <span class="inline-pre">fileprivate</span> или <span class="inline-pre">private</span>, то дефолтный уровень доступа его членов так же будет <span class="inline-pre">fileprivate</span> или <span class="inline-pre">private</span>. Если вы определите уровень доступа как <span class="inline-pre">internal</span> или <span class="inline-pre">public</span> (или будете использовать дефолтный уровень доступа, без явного указания <span class="inline-pre">internal</span>), то уровень доступа членов типа по умолчанию будет <span class="inline-pre">internal</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Как уже было сказано выше, типы с уровнем доступа <span class="inline-pre">public</span> по умолчанию имеют члены с уровнем доступа <span class="inline-pre">internal</span>, а не <span class="inline-pre">public</span>. Если вы хотите чтобы члены типа имели уровень доступа <span class="inline-pre">public</span>, то вы должны явно указать его. Такое требование гарантирует, что внешняя часть API - эта та часть, которую вы выбираете сами и исключает тот случай, когда вы можете по ошибке забыть указать <span class="inline-pre">internal</span> для внутреннего кода.</p>
</div>
<pre><code class="swift language-swift">public class SomePublicClass {                  // явный public класс
    public var somePublicProperty = 0            // явный public член класса
    var someInternalProperty = 0                 // неявный internal член класса
    fileprivate func someFilePrivateMethod() {}  // явный file-private член класса
    private func somePrivateMethod() {}          // явный private член класса
}
 
class SomeInternalClass {                       // неявный internal класс
    var someInternalProperty = 0                 // неявный internal член класса
    fileprivate func someFilePrivateMethod() {}  // явный file-private член класса
    private func somePrivateMethod() {}          // явный private член класса
}
 
fileprivate class SomeFilePrivateClass {        // явный file-private класс
    func someFilePrivateMethod() {}              // неявный file-private член класса
    private func somePrivateMethod() {}          // явный private член класса
}
 
private class SomePrivateClass {                // явный private класс
    func somePrivateMethod() {}                  // неявный private член класса
}
</code></pre>
<h2>Кортежи типов</h2>
<p>Уровень доступа для кортежей типов имеет самый строгий уровень доступа типа из всех используемых типов в кортеже. Например, если вы скомпонуете кортеж из двух разных типов, один из которых будет иметь уровень доступа как <span class="inline-pre">internal</span>, другой как <span class="inline-pre">private</span>, то кортеж будет иметь уровень доступа как <span class="inline-pre">private</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Кортежи типов не имеют отдельного определения в отличии от классов, структур, перечислений или функций. Уровень доступа кортежей типов вычисляется автоматически, когда используется кортеж, и не может быть указан явно.</p>
</div>
<h2>Типы функций</h2>
<p>Уровень доступа для типов функции вычисляется как самый строгий уровень доступа из типов параметров функции и типа возвращаемого значения. Вы должны указывать уровень доступа явно как часть определения функции, если вычисляемый уровень доступа функции не соответствует контекстному по умолчанию.</p>
<p>Пример ниже определяет глобальную функцию <span class="inline-pre">someFunction</span>, без явного указания уровня доступа самой функции. Вы может быть ожидаете, что эта функция будет иметь уровень доступа по умолчанию <span class="inline-pre">internal</span>, но только не в нашем случае. На самом деле функция, которая описана ниже вообще не будет компилироваться:</p>
<pre><code class="swift language-swift">func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // реализация функции…
}</code></pre>
<p>Возвращаемый тип функцией является кортежем, который составлен из двух пользовательских классов, которые были определены ранее в этом разделе. Один из этих классов был определен как <span class="inline-pre">internal</span>, другой - как <span class="inline-pre">private</span>. Таким образом, общий уровень доступа кортежа будет вычислен как <span class="inline-pre">private</span> (минимальный уровень доступа из всех элементов кортежа).</p>
<p>Из-за того, что уровень доступа функции <span class="inline-pre">private</span>, то вы должны установить общий уровень доступа как <span class="inline-pre">private</span> во время определения функции:</p>
<pre><code class="swift language-swift">private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // реализация функции…
}</code></pre>
<p>Это неправильно ставить маркер уровня доступа функции <span class="inline-pre">someFunction</span> как <span class="inline-re">public</span> или <span class="inline-re">internal</span>, или использовать уровень доступа по умолчанию, потому что пользователи функции с уровнем доступа <span class="inline-pre">public</span> или <span class="inline-pre">internal</span> не смогут получить соответствующий доступ к <span class="inline-pre">private</span> классу, который используется в качестве части возвращаемого значения функции.</p>
<h2>Типы перечислений</h2>
<p>Каждый кейс в перечислении автоматически получает тот же уровень доступа, что и само перечисление. Вы не можете указать другой уровень доступа для какого-то определенного кейса перечисления.</p>
<p>В примере ниже перечисление <span class="inline-pre">CompassPoint</span> имеет явный уровень доступа <span class="inline-pre">public</span>. Случаи перечисления <span class="inline-pre">north</span>, <span class="inline-pre">south</span>, <span class="inline-pre">east</span> и <span class="inline-pre">west</span> так же получают такой же уровень доступа, то есть <span class="inline-pre">public</span>:</p>
<pre><code class="swift language-swift">public enum CompassPoint {
    case north
    case south
    case east
    case west
}</code></pre>
<h2>Исходные значения и связанные значения</h2>
<p>Типы, используемые для любых начальных значений или связанных значений в перечислении, должны иметь как минимум такой же высокий уровень доступа как и перечисление. Вы не можете использовать тип <span class="inline-pre">private</span> для типа исходного значения перечисления, которое имеет <span class="inline-pre">internal</span> уровень доступа.</p>
<h2>Вложенные типы</h2>
<p>Вложенные типы, определенные внутри типа с уровнем доступа <span class="inline-pre">private</span>, автоматически получают уровень доступа <span class="inline-pre">private</span>. Вложенные типы внутри <span class="inline-pre">public</span> типов или <span class="inline-pre">internal</span> типов, автоматически получают уровень доступа как <span class="inline-pre">internal</span>. Если вы хотите, чтобы вложенный тип внутри <span class="inline-pre">public</span> типа имел уровень доступа как <span class="inline-pre">public</span>, то вам нужно явно указать этот тип самостоятельно.</p>
<h1>Уровень доступа класса и подкласса</h1>
<p>Вы можете создать подкласс любого класса, который может быть доступен в текущем контексте. Подкласс не может иметь более высокого уровня доступа, чем его суперкласс. Например, вы не можете написать подклассу <span class="inline-pre">public</span>, если его суперкласс имеет <span class="inline-pre">internal</span> доступ.</p>
<p>В дополнение вы можете переопределить любой член класса (метод, свойство, инициализатор или сабскрипт), который будет виден в определенном контексте доступа.</p>
<p>Переопределение может сделать член унаследованного класса более доступным, чем его версия суперкласса. В примере ниже класс <span class="inline-pre">A</span> имеет доступ <span class="inline-pre">public</span> и имеет метод <span class="inline-pre">someMethod</span> с уровнем доступа <span class="inline-pre">fileprivate</span>. Класс <span class="inline-pre">B</span> является подклассом класса <span class="inline-pre">A</span>, который имеет урезанный уровень доступа до <span class="inline-pre">internal</span>. Тем не менее, класс <span class="inline-pre">B</span> предоставляет переопределение метода <span class="inline-pre">someMethod</span> с уровнем доступа <span class="inline-pre">internal</span>, который выше, чем первоначальное определение метода <span class="inline-pre">someMethod</span>:</p>
<pre><code class="swift language-swift">public class A {
    fileprivate func someMethod() {}
}
 
internal class B: A {
    override internal func someMethod() {}
}</code></pre>
<p>Член подкласса может вызвать член суперкласса, который имеет более низкий уровень доступа, чем член подкласса, до тех пор пока вызов члена суперкласса попадает под допустимый уровень доступа контекста (то есть, попадает в пределы одного и того же исходного файла, что и суперкласс - для вызова члена с уровнем доступа <span class="inline-pre">fileprivate </span>или попадает в пределы одного и того же модуля, что и суперкласс - для вызова члена с уровнем доступа <span class="inline-pre">internal</span>):</p>
<pre><code class="swift language-swift">public class A {
    fileprivate func someMethod() {}
}
 
internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}</code></pre>
<p>Из-за того, что суперкласс <span class="inline-pre">A</span> и подкласс <span class="inline-pre">B</span> определены в одном исходном файле, то будет корректно для реализации B записать вызов метода <span class="inline-pre">someMethod</span> как <span class="inline-pre">super.someMethod()</span>.</p>
<h1>Константы, переменные, свойства и сабскрипт</h1>
<p>Константы, переменные, свойства не могут быть более открытыми, чем их тип. Это не правильно писать свойство <span class="inline-pre">public</span> для <span class="inline-pre">private</span> типа. Аналогично дело обстоит и с сабскриптом: сабскрипт не может быть более открытым, чем тип индекса или возвращаемый тип.</p>
<p>Если константа, переменная, свойство или сабскрипт используют тип <span class="inline-pre">private</span>, то они должны быть отмечены ключевым словом <span class="inline-pre">private</span>:</p>
<pre><code class="swift language-swift">private var privateInstance = SomePrivateClass()</code></pre>
<h2><a id="getters-and-setters"></a>Геттеры и сеттеры</h2>
<p>Геттеры и сеттеры для констант, переменных и сабскриптов автоматически получают тот же уровень доступа как и константа, переменная, свойство или сабскрипт, которому они принадлежат.</p>
<p>Вы можете задать сеттер более низкого уровня доступа чем его соответствующий геттер, для ограничения области read-write этой переменной, свойства или сабскрипта. Вы присваиваете более низкий уровень доступа написав <span class="inline-pre">fileprivate(set)</span>, <span class="inline-pre">private(set)</span> или <span class="inline-pre">internal(set)</span> до вступительного <span class="inline-pre">var</span> или <span class="inline-pre">subscript</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Это правило применяется как к свойствам хранения так и к вычисляемым свойствам. Даже если вы не пишете явного геттера и сеттера для хранимого свойства, Swift все еще создает для вас неявный геттер и сеттер, чтобы вы могли получить доступ к хранимым свойствам. Используйте <span class="inline-pre">fileprivate(set)</span>, <span class="inline-pre">private(set)</span> и <span class="inline-pre">internal(set)</span> для изменения уровня доступа этого созданного сеттера в точно такой же форме как и в случае явного сеттера вычисляемого свойства.</p>
</div>
<p>Пример ниже определяет структуру <span class="inline-pre">TrackedString</span>, которая отслеживает число изменений строкового свойства:</p>
<pre><code class="swift language-swift">struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
}</code></pre>
<p>Структура <span class="inline-pre">TrackedString</span> определяет свойство хранения <span class="inline-pre">value</span> с начальным значением "" (пустая строка). Структура так же определяет свойство хранения <span class="inline-pre">numberOfEdits</span>, которое используется для отслеживания количества изменений значения <span class="inline-pre">value</span>. Эта модификация отслеживания реализована в наблюдателе <span class="inline-pre">didSet</span> свойства <span class="inline-pre">value</span>, которое увеличивает <span class="inline-pre">numberOfEdits</span> каждый раз, как <span class="inline-pre">value</span> получает новое значение.</p>
<p>Структура <span class="inline-pre">TrackedString</span> и свойство <span class="inline-pre">value</span> не указывают явного уровня доступа, таким образом они оба получают дефолтный уровень доступа <span class="inline-pre">internal</span>. Однако уровень доступа <span class="inline-pre">numberOfEdits</span> обозначен как <span class="inline-pre">private(set)</span>, что означает, что геттер свойства все еще имеет уровень доступа по умолчанию <span class="inline-pre">internal</span>, но свойство может быть установлено только в пределах кода, который является частью структуры <span class="inline-pre">TrackedString</span>. Это позволяет <span class="inline-pre">TrackedString</span> изменять свойство <span class="inline-pre">numberOfEdits</span> скрытно, но тем не менее позволяет свойству быть read-only (только для чтения), когда оно используется в других исходных файлах в пределах того же модуля.</p>
<p>Если вы создаете экземпляр <span class="inline-pre">TrackedString</span> и изменяете его строковое значение несколько раз, то вы можете увидеть, что свойство <span class="inline-pre">numberOfEdits</span> изменяется, чтобы соответствовать количеству фактических изменений значения:</p>
<pre><code class="swift language-swift">var stringToEdit = TrackedString()
stringToEdit.value = "This string will be tracked."
stringToEdit.value += " This edit will increment numberOfEdits."
stringToEdit.value += " So will this one."
print("Количество изменений равно \(stringToEdit.numberOfEdits)")
// Выведет "Количество изменений равно 3"</code></pre>
<p>Хотя вы и можете обращаться к текущему значению свойства <span class="inline-pre">numberOfEdits</span> в пределах другого исходного файла, но вы не можете <em>изменять</em> его из другого исходного файла. Это ограничение защищает детали реализации функциональности <span class="inline-pre">TrackedString</span>, в то же время обеспечивая удобный доступ к аспекту этой функциональности.</p>
<p>Обратите внимание, что вы можете присвоить явный уровень доступа и к геттеру, и к сеттеру, если это необходимо. Пример ниже показывает версию структуры <span class="inline-pre">TrackedString</span>, где она определена с явным указанием открытого уровня доступа. Таким образом, элементы структуры (включая свойство <span class="inline-pre">numbersOfEdits</span>) получают уровень доступа <span class="inline-pre">internal</span> по умолчанию. Вы можете сделать уровень доступа геттера параметра <span class="inline-pre">numberOfEdits</span> открытым, а сеттера этого же свойства сделать частным, таким образом вы комбинируете и <span class="inline-pre">public</span>, и <span class="inline-pre">private(set)</span> модификаторы уровней доступа:</p>
<pre><code class="swift language-swift">public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
    public init() {}
}</code></pre>
<h1>Инициализаторы</h1>
<p>Пользовательским инициализаторам может быть присвоен уровень доступа ниже или равный уровню доступа самого типа, который они инициализируют. Единственное исключение составляют <a href="https://swiftbook.ru/content/languageguide/initialization/#required-initializers">Требуемые инициализаторы</a>. Требуемый инициализатор должен иметь тот же уровень доступа как и класс, которому он принадлежит.</p>
<p>Что же касается параметров функций и методов, типов параметров инициализатора, то они не могут быть более частными, чем собственный уровень доступа инициализатора.</p>
<h2>Дефолтные инициализаторы</h2>
<p>Как было описано в главе <a href="https://swiftbook.ru/content/languageguide/initialization/#default-initializers">Дефолтные инициализаторы</a>, Swift автоматически предоставляет <em>дефолтный инициализатор</em>, который не имеет никаких аргументов, для любой структуры или базового класса, который предоставляет значения по умолчанию для всех своих свойств и который не имеет ни одного собственного инициализатора.</p>
<p>Дефолтный инициализатор имеет тот же уровень доступа, что и тип, который он инициализирует, если только тип не имеет доступа <span class="inline-pre">public</span>. Для типа, у которого уровень доступа установлен <span class="inline-pre">public</span>, дефолтный инициализатор имеет уровень доступа <span class="inline-pre">internal</span>. Если вы хотите, чтобы открытый (<span class="inline-pre">public</span>) тип был инициализируемым при помощи инициализатора, который не имеет аргументов, когда используется в другом модуле, то вы должны явно указать такой инициализатор как часть определения типа.</p>
<h2>Дефолтные почленные инициализаторы для типов структур</h2>
<p>Дефолтные почленные инициализаторы для типов структур считаются частными (<span class="inline-pre">private</span>), если есть свойства, которые имеют уровень доступа как <span class="inline-pre">private</span>. В противном случае, инициализатор имеет уровень доступа <span class="inline-pre">internal</span>.</p>
<p>Как и с дефолтным инициализатором выше, если вы хотите открытый тип структуры, который может быть инициализирован при помощи почленного инициализатора, когда используется в другом модуле, то вы должны предоставить открытый почленный инициализатор самостоятельно, как часть определения типа.</p>
<h1>Протоколы и уровень доступа</h1>
<p>Если вы хотите присвоить явный уровень доступа протоколу, то вы должны указать его во время определения протокола. Это позволяет вам создавать протоколы, которые могут быть приняты только внутри определенного уровня доступа контекста.</p>
<p>Уровень доступа каждого требования в процессе определения протокола устанавливается на тот же уровень, что и сам протокол. Вы не можете установить уровень доступа требований протокола отличным от того, который поддерживает сам протокол. Это гарантирует, что все требования протокола будут видимы любому типу, который принимает протокол.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Если вы определяете <span class="inline-pre">public</span> протокол, то требования протокола требуют <span class="inline-pre">public</span> уровня доступа для тех требований, которые они реализуют. Это поведение отличается от поведений других типов, где определение открытого типа предполагает наличие уровня <span class="inline-pre">internal</span> у элементов этого типа.</p>
</div>
<h2>Наследование протокола</h2>
<p>Если вы определяете новый протокол, который наследует из другого существующего протокола, то новый протокол может иметь уровень доступа не выше чем протокол, который он наследует. Вы не можете писать <span class="inline-pre">public</span> протокол, который наследует из <span class="inline-pre">internal</span> протокола, к примеру.</p>
<h2>Соответствие протоколу</h2>
<p>Тип может соответствовать протоколу с более низким уровнем доступа, чем сам тип. Например, вы можете определить <span class="inline-pre">public</span> тип, который может быть использован в других модулях, но чье соответствие внутреннему протоколу может быть использовано только внутри модуля, где определен сам <span class="inline-pre">internal</span> протокол.</p>
<p>Контекст, в котором тип соответствует конкретному протоколу, является минимумом из доступов протокола и типа. Если тип является <span class="inline-pre">public</span>, но протокол, которому он соответствует является <span class="inline-pre">internal</span>, то соответствие типа этому протоколу будет тоже <span class="inline-pre">internal</span>.</p>
<p>Когда вы пишете или расширяете тип для того, чтобы он соответствовал протоколу, вы должны быть уверены, что реализация этого типа каждому требованию протокола, по крайней мере имеет один и тот же уровень доступа, что и соответствие типа этому протоколу. Например, если тип <span class="inline-pre">public</span> соответствует протоколу <span class="inline-pre">internal</span>, то реализация каждого требования протокола должна быть как минимум <span class="inline-pre">internal</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>В Swift как и в Objective-C соответствие протоколу является глобальным. И тип не может соответствовать протоколу двумя разными способами в пределах одной программы.</p>
</div>
<h1>Расширения и уровни доступа</h1>
<p>Вы можете расширить класс, структуру или перечисление в любом контексте, в котором класс, структура или перечисление доступны. Любой элемент типа, добавленный в расширение, имеет тот же дефолтный уровень доступа, что и типы, объявленные в исходном типе, будучи расширенными. Например, если вы расширяете тип <span class="inline-pre">public</span>, то любые новые элементы этого типа, которые вы добавили, будут иметь уровень доступа равный <span class="inline-pre">internal</span>. Если вы расширяете <span class="inline-pre">fileprivate</span> тип, то дефолтный уровень доступа любого добавленного в него члена будет <span class="inline-pre">fileprivate</span>. Если вы расширяете <span class="inline-pre">private</span> тип, то дефолтный уровень доступа любого добавленного в него члена будет <span class="inline-pre">private</span>.</p>
<p>Аналогично вы можете отметить расширение, явно указав модификатор уровня доступа (например, <span class="inline-pre">private extension</span>), для того чтобы указать новый дефолтный уровень доступа, который будут иметь элементы, определенные в этом расширении. Этот новый уровень доступа может быть переопределен для отдельных элементов расширением.</p>
<p>Вы не можете предоставлять явный модификатор уровня доступа для расширения, если вы используете расширение для добавления соответствия протоколу. Вместо этого, собственный уровень доступа протокола используется для предоставления дефолтного уровня доступа для каждой реализации требования протокола внутри расширения.</p>
<h2>Private свойства и методы в расширениях</h2>
<p>Расширения, которые находятся в <strong>том же</strong> файле, что и сам класс/структура/перечисление, который(ую/ое) они расширяют, ведут себя точно так, как будто они являются частью расширяемого типа. И в результате вы можете:</p>
<ul>
<li>Объявлять приватные члены в оригинальном объявлении и получать доступ к ним через расширение</li>
<li>Объявлять приватные члены в одном расширении и получать доступ к ним через другие расширения, если они находятся в том же файле</li>
<li>Объявлять приватные члены в расширении и получать доступ к ним в оригинальном объявлении</li>
</ul>
<p>Это поведение означает, что вы можете использовать расширения для организации вашего кода, независимо от того, имеют ли ваши типы приватные члены или нет. Например, нам дан вот такой простой протокол:</p>
<pre><code class="language-swift">protocol SomeProtocol {
    func doSomething()
}</code></pre>
<p>Вы можете использовать расширение, чтобы реализовать требование протокола:</p>
<pre><code class="language-swift">struct SomeStruct {
    private var privateVariable = 12
}
 
extension SomeStruct: SomeProtocol {
    func doSomething() {
        print(privateVariable)
    }
}</code></pre>
<h1>Универсальные шаблоны. Алиасы типов</h1>
<p>Уровень доступа для универсального типа или универсальной функции вычисляется как минимальный уровень доступа универсального типа или самой функции и уровень доступа ограничений любого типа ограничений для параметров типа.</p>
<h2>Алиасы типов</h2>
<p>Любой алиас типа, который вы определяете, рассматривается как отдельный тип для цели контроля доступа. Алиас типа может иметь уровень доступа такой же или ниже, чем уровень доступа типа, псевдоним которого он создает. Например, алиас с уровнем доступа <span class="inline-pre">private</span>, может быть алиасом для типа с уровнем доступа <span class="inline-pre">private</span>, <span class="inline-pre">fileprivate</span>, <span class="inline-pre">internal</span>, <span class="inline-pre">public</span>, <span class="inline-pre">open</span> но если у алиаса уровень доступа стоит <span class="inline-pre">public</span>, то он не может быть алиасом типа, у которого уровень доступа стоит как <span class="inline-pre">internal</span> или <span class="inline-pre">private</span>, <span class="inline-pre">fileprivate</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Это правило так же применимо для алиасов типа связанных типов, используемых для удовлетворения несоответствий протоколу.</p>
</div>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/memory-safety" rel="8818">Безопасность хранения</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/advanced-operators" rel="8820">Продвинутые операторы</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/access-control/">Контроль доступа</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Безопасность хранения
https://swiftbook.ru/content/languageguide/memory-safety/
				Sun, 29 Jul 2018 08:16:53 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=7015
<p>Безопасность хранения По умолчанию Swift предотвращает небезопасное поведение в вашем коде. Например, Swift гарантирует, что переменные будут инициализированы до обращения к ним, память перестанет быть доступной после того, как будет освобождена, а индексы массивов будут проверены на ошибку не вхождения в диапазон индексов массива. Swift также гарантирует, что множественный доступ к одной и той же [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/memory-safety/">Безопасность хранения</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<h1>Безопасность хранения</h1>
<p>По умолчанию Swift предотвращает небезопасное поведение в вашем коде. Например, Swift гарантирует, что переменные будут инициализированы до обращения к ним, память перестанет быть доступной после того, как будет освобождена, а индексы массивов будут проверены на ошибку не вхождения в диапазон индексов массива.</p>
<p>Swift также гарантирует, что множественный доступ к одной и той же области памяти не вызовет конфликта, так как потребует кода, который изменит местоположение в памяти, для того, чтобы у вас появился эксклюзивный доступ к этой памяти. Поскольку Swift автоматически управляет памятью, большую часть времени вам вообще не нужно думать о доступе к памяти. Однако важно понять, где могут возникнуть потенциальные конфликты, и вы сможете избежать написания кода, который вызовет конфликт доступа к памяти. Если у вас в коде возникает конфликт, то вы получите ошибку компиляции или ошибку выполнения.</p>
<h2>Что такое конфликт доступа к памяти</h2>
<p>Доступ к памяти происходит в вашем коде, когда вы, например, устанавливаете значение переменной или передаете аргумент функции. Так следующий код содержит доступ и на чтение и на запись:</p>
<pre><code class="language-swift">// Доступ к памяти с правами записи, где хранится данная переменная
var one = 1
// Доступ к памяти с правами чтения, где хранится данная переменная
print("We're number \(one)!”)</code></pre>
<p>Конфликт доступа к памяти может возникнуть, когда разные части вашего кода пытаются одновременно получить доступ к одному и тому же фрагменту памяти. Множественный одновременный доступ к фрагменту памяти может привести к непредсказуемому поведению. В Swift существуют способы изменить значение, охватывающее несколько строк кода, что позволяет попытаться получить доступ к значению в середине его собственной модификации.</p>
<p>С такой же проблемой можно столкнуться, когда встает вопрос, как внести дополнительные траты в бюджет, который написан на листе бумаги. Обновление бюджета - это двухэтапный процесс: сначала вы добавляете названия и цены, а затем изменяете общую сумму, чтобы отразить элементы, находящиеся в списке. До и после обновления, вы можете считывать любую информацию по бюджету и всегда будете получать корректный ответ, как показано на схеме ниже.</p>
<p style="text-align: center;"><img src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/memorySafety_0.png" alt="" /></p>
<p>Но пока вы добавляете элементы в бюджет, он находится во временном, недействительном состоянии, потому что общая сумма еще не обновлена, и не отражает вновь добавленные элементы. И общая сумма в процессе добавления элементов дает нам неверную информацию.</p>
<p>Этот пример также отражает проблему, с которой вы можете столкнуться при устранении конфликта доступа к памяти: иногда есть несколько способов исправить конфликт, порождающий разные ответы, и не всегда очевидно, какой ответ правильный. В этом примере, в зависимости от того, хотите ли вы получить исходную общую текущую сумму или обновленную общую сумму, правильный ответ может быть равен <span class="inline-pre">$5</span> или <span class="inline-pre">$320</span>. Прежде чем вы сможете исправить конфликт доступа, вы должны определить, в чем именно он заключается.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Если вы уже писали параллельный или многопоточный код, проблема конфликта доступа к памяти может быть вам знакома. Однако конфликт доступа, который мы обсуждаем здесь, может происходить в одном потоке и не включать параллельный или многопоточный код.</p>
<p>Если у вас есть конфликт доступа к памяти в одном потоке, Swift гарантирует, что вы получите сообщение об ошибке во время компиляции или выполнения. Для многопоточного кода используйте <a href="https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early">Санитайзер потоков</a>, чтобы выявить конфликт доступа по потокам.</p>
</div>
<h2>Характеристики доступа к памяти</h2>
<p>Существует три характеристики доступа к памяти (в контексте рассматриваемого конфликта доступа): является ли доступ с правами чтения или записи, продолжительностью доступа и местоположением в памяти, к которой обращаются. В частности, конфликт возникает, если у вас есть два доступа, отвечающие полностью всем следующим условиям:</p>
<ul>
<li>По крайней мере, один из них является доступом на запись или неатомарным доступом.</li>
<li>Они получают доступ к одному и тому же фрагменту в памяти.</li>
<li>Их длительность перекрывается друг другом.</li>
</ul>
<p>Разница между доступом для чтения и доступом для записи очевидна: доступ на запись изменяет местоположение в памяти, а доступ для чтения нет. Местоположение в памяти относится к тому, к чему обращаются, например, к переменной, константе или свойству. Длительность доступа к памяти - мгновенная или долгосрочная.</p>
<p>Операция является <em>атомарной</em>, если она использует атомарные операции языка C, в противном случае операция неатомарная. Список атомарных операций можно найти на справочной странице <span class="inline-pre">stdatomic(3)</span>.</p>
<p>Доступ считается мгновенным (моментальным), если невозможно запустить другой код после того, пока не завершится уже запущенный код с доступом к памяти. По своей природе два моментальных (мгновенных) доступа не могут произойти одновременно. В большинстве случаев доступ к памяти происходит мгновенно. Например, все доступы для чтения и записи в приведенном ниже коде являются мгновенными:</p>
<pre><code class="language-swift">func oneMore(than number: Int) -&gt; Int {
    return number + 1
}
 
var myNumber = 1
myNumber = oneMore(than: myNumber)
print(myNumber)
// Выведет "2"</code></pre>
<p>Однако есть несколько способов доступа к памяти, называемых долгосрочными доступами, которые охватывают выполнение другого кода. Разница между мгновенным доступом и долгосрочным доступом заключается в том, что запуск другого кода возможен после запуска долгосрочного доступа и до его завершения, что называется наложением или перекрытием. Долгосрочный доступ может перекрываться с другими долгосрочными доступами и мгновенными доступами.</p>
<p>Перекрывающиеся обращения появляются, прежде всего, в коде, который использует сквозные параметры в функциях и методах или методы структуры c модификатором <span class="inline-pre">mutating</span>. Конкретные примеры кода в Swift, использующие долгосрочные доступы, будут рассмотрены в следующих разделах.</p>
<h2>Конфликт доступа к сквозным параметрам</h2>
<p>Функция имеет долгосрочный доступ для записи ко всем ее сквозным параметрам. Доступ записи для сквозного параметра начинается после того, как все несквозные параметры были оценены и длятся всю продолжительность вызова этой функции. Если имеется несколько сквозных параметров, то доступы на запись начинаются в том же порядке, в каком были объявлены параметры.</p>
<p>Одним из последствий этого долгосрочного доступа для записи является то, что вы не можете получить доступ к исходной переменной, которая была передана как сквозная переменная, даже если правила определения области видимости и контроля доступа это позволяют - любой доступ к оригиналу создаст конфликт. Например:</p>
<pre><code class="language-swift">var stepSize = 1
 
func <span class="nv">increment</span>(<span class="k">_</span> <span class="nv">number</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
    number += stepSize
}
 
increment(&amp;stepSize)
// Ошибка: conflicting accesses to stepSize</code></pre>
<p>В приведенном выше коде <span class="inline-pre">stepSize</span> является глобальной переменной, и она обычно доступна из <span class="inline-pre">increment(_:)</span>. Тем не менее, доступ для чтения к <span class="inline-pre">stepSize</span> перекрывается доступом для записи к number. Как показано на рисунке ниже, и number, и <span class="inline-pre">stepSize</span> относятся к одному и тому же фрагменту памяти. Доступ для чтения и записи относится к одной и той же памяти, и они перекрываются, создавая конфликт.<img class="aligncenter" src="https://swiftbook.ru/wp-content/uploads/sites/2/2019/03/Screenshot-2019-03-18-at-8.23.56-AM.png" alt="" /></p>
<p>Один из способов решения этого конфликта - сделать явную копию <span class="inline-pre">stepSize</span>:</p>
<pre><code class="language-swift">// Создадим явную копию
var copyOfStepSize = stepSize
increment(&amp;copyOfStepSize)
 
// Обновим оригинал
stepSize = copyOfStepSize
// stepSize равен 2</code></pre>
<p>Когда вы создаете копию <span class="inline-pre">stepSize</span> перед вызовом <span class="inline-pre">increment(_:)</span> то становится ясно, что значение <span class="inline-pre">copyOfStepSize</span> увеличивается на текущий размер шага. Доступ для чтения заканчивается до начала доступа для записи, поэтому конфликт не возникает.</p>
<p>Другим следствием долгосрочного доступа для записи к сквозным параметрам является то, что передача одной переменной в качестве аргумента для нескольких сквозных параметров одной и той же функции вызывает конфликт. Например:</p>
<pre><code class="language-swift">func balance(_ x: inout Int, _ y: inout Int) {
    let sum = x + y
    x = sum / 2
    y = sum - x
}
var playerOneScore = 42
var playerTwoScore = 30
balance(&amp;playerOneScore, &amp;playerTwoScore)  // OK
balance(&amp;playerOneScore, &amp;playerOneScore)
// Ошибка: Conflicting accesses to playerOneScore</code></pre>
<p>Функция <span class="inline-pre">balance(_:_:)</span> изменяет два своих параметра, чтобы равномерно распределять общее значение между ними. Вызов с помощью <span class="inline-pre">playerOneScore</span> и <span class="inline-pre">playerTwoScore</span> в качестве аргументов не приводит к конфликту - есть два доступа для записи, которые перекрываются во времени, но они получают доступ к различным фрагментам в памяти. Напротив, передача <span class="inline-pre">playerOneScore</span> в качестве значения для обоих параметров вызывает конфликт, поскольку он пытается одновременно выполнить два доступа для записи в одно и то же место в памяти.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Так как операторы это функции, то они также могут иметь долгосрочный доступ к своим сквозным параметрам. Например, если <span class="inline-pre">balance(_:_:)</span> это операторная функция с именем <span class="inline-pre">&lt;^&gt;</span>, то запись <span class="inline-pre">playerOneScore &lt;^&gt; playerOneScore</span> приведет к такому же конфликту, что и <span class="inline-pre">balance(&amp;playerOneScore, &amp;playerOneScore)</span></p>
</div>
<h2>Конфликт доступа к self в методах</h2>
<p><span class="inline-pre">Mutating </span>метод в структуре имеет доступ для записи к <span class="inline-pre">self</span> на время вызова метода. Например, давайте рассмотрим игру, в которой каждый игрок имеет какое-то количество здоровья, которое уменьшается при получении урона, и количество энергии, которое уменьшается при использовании специальных способностей.</p>
<pre><code class="language-swift">struct Player {
    var name: String
    var health: Int
    var energy: Int
    
    static let maxHealth = 10
    mutating func restoreHealth() {
        health = Player.maxHealth
    }
}</code></pre>
<p>В вышеописанном методе <span class="inline-pre">restoreHealth()</span> доступ для записи к <span class="inline-pre">self</span> начинается с начала метода и продолжается до тех пор, пока метод не вернется. В этом случае внутри <span class="inline-pre">restoreHealth()</span> нет другого кода, который может иметь перекрывающий доступ к свойствам экземпляра <span class="inline-pre">Player</span>. Метод <span class="inline-pre">shareHealth(with:)</span> (см. ниже) принимает другой экземпляр <span class="inline-pre">Player</span> как сквозной параметр, создавая возможность перекрытия доступа.</p>
<pre><code class="language-swift">extension Player {
    mutating func shareHealth(with teammate: inout Player) {
        balance(&amp;teammate.health, &amp;health)
    }
}
 
var oscar = Player(name: "Oscar", health: 10, energy: 10)
var maria = Player(name: "Maria", health: 5, energy: 10)
oscar.shareHealth(with: &amp;maria)  // OK</code></pre>
<p>В приведенном выше примере вызов <span class="inline-pre">shareHealth(with:)</span> для игрока Оскара для совместного использования здоровья с игроком Марией не вызывает конфликт. Во время вызова метода есть доступ для записи и к oscar, потому что <span class="inline-pre">oscar</span> - это значение <span class="inline-pre">self</span> в изменяющем методе, и есть доступ на запись к <span class="inline-pre">maria</span> в течение той же продолжительности, потому что <span class="inline-pre">maria</span> была передана как сквозной параметр. Как показано на рисунке ниже, они получают доступ к различным фрагментам памяти. Несмотря на то, что два доступа для записи перекрываются во времени, они не конфликтуют.</p>
<p style="text-align: center;"><img src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/memorySafety_2.png" alt="" /></p>
<p>Однако, если вы передадите <span class="inline-pre">oscar</span> в качестве аргумента <span class="inline-pre">shareHealth(with:)</span>, то возникает конфликт:</p>
<pre><code class="language-swift">oscar.shareHealth(with: &amp;oscar)
// Ошибка: conflicting accesses to oscar</code></pre>
<p><span class="inline-pre">Mutating</span> метод требует доступа для записи к <span class="inline-pre">self</span> в течение всего метода, а сквозной параметр требует доступа для записи к <span class="inline-pre">teammate</span> в это же время. Внутри метода и <span class="inline-pre">self</span>, и <span class="inline-pre">teammate</span> относятся к одному и тому же фрагменту в памяти - как показано на рисунке ниже. Два доступа для записи относятся к одному и тому же фрагменту в памяти, и они перекрываются, создавая конфликт.</p>
<p style="text-align: center;"><img src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/memorySafety_3.png" alt="" /></p>
<h2>Конфликт доступа к свойствам</h2>
<p>Такие типы, как структуры, кортежи и перечисления, состоят из отдельных составляющих их значений, таких как свойства структуры или элементы кортежа. Поскольку они являются типами значений, изменение любой части значения меняет все значение, то есть доступ для чтения или записи к одному из свойств требует доступа для чтения или записи ко всему значению. Например, перекрывающиеся доступы для записи к элементам кортежа приводят к конфликту:</p>
<pre><code class="language-swift">var playerInformation = (health: 10, energy: 20)
balance(&amp;playerInformation.health, &amp;playerInformation.energy)
// Ошибка: conflicting access to properties of playerInformation</code></pre>
<p>В приведенном выше примере вызов <span class="inline-pre">balance(_:_:)</span> по элементам кортежа создает конфликт, потому что есть перекрывающий доступ для записи к playerInformation. И <span class="inline-pre">playerInformation.health</span>, и <span class="inline-pre">playerInformation.energy</span> передаются как сквозные параметры, что означает, что <span class="inline-pre">balance(_:_:)</span> требует доступ для записи во время вызова функции. В обоих случаях доступ для записи к элементу кортежа требует доступа для записи ко всему кортежу. Это означает, что есть два доступа для записи в <span class="inline-pre">playerInformation</span> с длительностью, которая перекрывается, вызывая конфликт.</p>
<p>В приведенном ниже коде показано, что такая же ошибка появляется при перекрытии доступа для записи к свойствам структуры, которая хранится в глобальной переменной.</p>
<pre><code class="language-swift">var holly = Player(name: "Holly", health: 10, energy: 10)
balance(&amp;holly.health, &amp;holly.energy)  // Ошибка</code></pre>
<p>На практике большинство доступов к свойствам структуры могут перекрываться безопасно. Например, если переменная <span class="inline-pre">holly</span> в приведенном выше примере изменена на локальную переменную вместо глобальной переменной, то компилятор может доказать, что перекрывающий доступ к сохраненным свойствам структуры безопасен:</p>
<pre><code class="language-swift">func someFunction() {
    var oscar = Player(name: "Oscar", health: 10, energy: 10)
    balance(&amp;oscar.health, &amp;oscar.energy)  // OK
}</code></pre>
<p>В приведенном выше примере здоровье и энергия Оскара передаются в качестве двух сквозных параметров в <span class="inline-pre">balance(_:_:)</span>. Компилятор может доказать, что безопасность хранения сохраняется, поскольку два сохраненных свойства никак не взаимодействуют.</p>
<p>Ограничение перекрывающегося доступа к свойствам структуры не всегда необходимо для сохранения безопасности хранения. Безопасность хранения - это желаемая гарантия, но эксклюзивный доступ является более строгим требованием, чем безопасность хранения, что означает, что код может сохранять безопасность хранения, даже несмотря на то, что он нарушает исключительный доступ к памяти. Swift позволяет использовать этот безопасный для памяти код, если компилятор может доказать, что неисключительный доступ к памяти по-прежнему безопасен. В частности, он может доказать, что перекрывающий доступ к свойствам структуры безопасен, если применяются следующие условия:</p>
<ul>
<li>Вы получаете доступ только к сохраненным свойствам экземпляра, а не к вычисленным свойствам или свойствам класса.</li>
<li>Структура - это значение локальной переменной, а не глобальной переменной.</li>
<li>Структура либо не захватывается никакими замыканиями, либо захватывается только несбегающими замыканиями.</li>
</ul>
<p>Если компилятор не может доказать, что доступ безопасен, он не разрешает доступ.</p>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/automatic-reference-counting" rel="8817">Автоматический подсчет ссылок (ARC)</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/access-control" rel="8819">Контроль доступа</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/memory-safety/">Безопасность хранения</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Автоматический подсчет ссылок (ARC)
https://swiftbook.ru/content/languageguide/automatic-reference-counting/
				Fri, 27 Jul 2018 18:12:05 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=7008
<p>Автоматический подсчет ссылок (ARC) Swift использует automatic reference counting (автоматический подсчет ссылок) для отслеживания и управления памятью вашего приложения. В большинстве случаев это означает, что управление памятью "просто работает" в Swift и вам не нужно думать о самостоятельном управлении памятью. ARC автоматически освобождает память, которая использовалась экземплярами класса, когда эти экземпляры больше нам не нужны. [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/automatic-reference-counting/">Автоматический подсчет ссылок (ARC)</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p><a name="top"></a></p>
<h1>Автоматический подсчет ссылок (ARC)</h1>
<p>Swift использует <em>automatic reference counting</em> (автоматический подсчет ссылок) для отслеживания и управления памятью вашего приложения. В большинстве случаев это означает, что управление памятью "просто работает" в Swift и вам не нужно думать о самостоятельном управлении памятью. ARC автоматически освобождает память, которая использовалась экземплярами класса, когда эти экземпляры больше нам не нужны.</p>
<p>Однако, в некоторых случаях для управления памятью ARC нужно больше информации об отношениях между некоторыми частями вашего кода. Эта глава опишет эти случаи и покажет как включить ARC, чтобы эта система взяла на себя весь контроль памятью вашего приложения. Использование ARC в Swift очень схоже с использованием ARC в Objective-C, описание которого можно найти в <a href="https://developer.apple.com/library/prerelease/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226">Transitioning to ARC Release Notes</a>.</p>
<p>ARC применима только для экземпляров класса. Структуры и перечисления являются типами значений, а не ссылочными типами, и они не хранятся и не передают свои значения по ссылке.</p>
<h1>Работа ARC</h1>
<p>Каждый раз, когда вы создаете экземпляр класса, ARC выделяет фрагмент памяти для хранения информации этого экземпляра. Этот фрагмент памяти содержит информацию о типе экземпляра, о его значении и любых свойствах хранения, связанных с ним.</p>
<p>Дополнительно, когда экземпляр больше не нужен, ARC освобождает память, использованную под этот экземпляр, и направляет эту память туда, где она нужна. Это своего рода гарантия того, что ненужные экземпляры не будут занимать память.</p>
<p>Однако, если ARC освободит память используемого экземпляра, то доступ к свойствам или методам этого экземпляра будет невозможен. Если вы попробуете получить доступ к этому экземпляру, то ваше приложение скорее всего выдаст ошибку и будет остановлено.</p>
<p>Для того, чтобы нужный экземпляр не пропал, ARC ведет учет количества свойств, констант, переменных, которые ссылаются на каждый экземпляр класса. ARC не освободит экземпляр, если есть хотя бы одна активная ссылка.</p>
<p>Для того чтобы это было возможно, каждый раз как вы присваиваете экземпляр свойству, константе или переменной создается <em>strong reference</em> (сильная ссылка) с этим экземпляром. Такая связь называется “сильной”, так как она крепко держится за этот экземпляр и не позволяет ему освободится до тех пор, пока остаются сильные связи.</p>
<h1>ARC в действии</h1>
<p>Приведем пример того, как работает ARC. Наш пример начнем с класса <span class="inline-pre">Person</span>, который определяет константное свойство <span class="inline-pre">name</span>:</p>
<pre><code class="swift language-swift">class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) инициализируется")
    }
    deinit {
        print("\(name) деинициализируется")
    }
}</code></pre>
<p>Класс <span class="inline-pre">Person</span> имеет инициализатор, который устанавливает name свойство экземпляра и выводит сообщение для отображения того, что идет инициализация. Так же класс <span class="inline-pre">Person</span> имеет деинициализатор, который выводит сообщение, когда экземпляр класса освобождается.</p>
<p>Следующий фрагмент кода определяет три переменные класса <span class="inline-pre">Person?</span>, который используется для установки нескольких ссылок к новому экземпляру <span class="inline-pre">Person</span> в следующих кусках кода. Так как эти переменные опционального типа (<span class="inline-pre">Person?</span>, а не <span class="inline-pre">Person)</span>, они автоматически инициализируются со значением <span class="inline-pre">nil</span>, и не имеют никаких ссылок на экземпляр <span class="inline-pre">Person</span>.</p>
<pre><code class="swift language-swift">var reference1: Person?
var reference2: Person?
var reference3: Person?</code></pre>
<p>Теперь вы можете создать экземпляр класса <span class="inline-pre">Person</span> и присвоить его одной из этих трех переменных:</p>
<pre><code class="swift language-swift">reference1 = Person(name: "John Appleseed")
// Выведет "John Appleseed инициализируется"</code></pre>
<p>Обратите внимание, что сообщение <span class="inline-pre">"John Appleseed инициализируется"</span> выводится во время того, как вы вызываете инициализатор класса <span class="inline-pre">Person</span>. Это подтверждает тот факт, что происходила инициализация.</p>
<p>Так как новый экземпляр класса <span class="inline-pre">Person</span> был присвоен переменной <span class="inline-pre">reference1</span>, значит теперь существует сильная ссылка между <span class="inline-pre">reference1</span> и новым экземпляром класса <span class="inline-pre">Person</span>. Теперь у этого экземпляра есть как минимум одна сильная ссылка, значит ARC держит под <span class="inline-pre">Person</span> память и не освобождает ее.</p>
<p>Если вы присвоите другим переменным тот же экземпляр <span class="inline-pre">Person</span>, то добавится две сильные ссылки к этому экземпляру:</p>
<pre><code class="swift language-swift">reference2 = reference1
reference3 = reference1</code></pre>
<p>Теперь экземпляр класса <span class="inline-pre">Person</span> имеет три сильные ссылки.</p>
<p>Если вы сломаете две из этих трех ссылок (включая и первоначальную ссылку), присвоив <span class="inline-pre">nil</span> двум переменным, то останется одна сильная ссылка, и экземпляр <span class="inline-pre">Person</span> не будет освобожден:</p>
<pre><code class="swift language-swift">reference1 = nil
reference2 = nil</code></pre>
<p>ARC не освободит экземпляр класса <span class="inline-pre">Person</span> до тех пор, пока остается последняя сильная ссылка, уничтожив которую мы укажем на то, что наш экземпляр больше не используется:</p>
<pre><code class="swift language-swift">reference3 = nil
// Выведет "John Appleseed деинициализируется"</code></pre>
<h1><a id="strong-reference-cycles-between-class-instances"></a>Циклы сильных ссылок между экземплярами классов</h1>
<p>В примерах ранее ARC было в состоянии отслеживать количество ссылок к новому экземпляру <span class="inline-pre">Person</span>, который вы создали, и освободить его, если этот экземпляр уже более не нужен.</p>
<p>Однако возможно написать код, в котором экземпляр класса <em>никогда</em> не будет иметь нулевое число сильных ссылок. Это может случиться, если экземпляры классов имеют сильные связи друг с другом, что не позволяет им освободиться. Это известно как <em>цикл сильных ссылок</em>.</p>
<p>Вы сами решаете, когда сделать вместо сильной (<span class="inline-pre">strong</span>) ссылки слабую (<span class="inline-pre">weak</span>) или бесхозную (<span class="inline-pre">unowned</span>). Подробнее об этом можно прочитать в разделе <a href="https://swiftbook.ru/content/languageguide/automatic-reference-counting/#resolving-strong-reference-cycles-between-class-instances">Замена циклов сильных ссылок между экземплярами классов</a>. Однако перед тем как узнать, в каких случаях разрешить сильный ссылочный цикл, давайте узнаем что вызывает его.</p>
<p>Ниже приведен пример того, как сильный ссылочный цикл может быть создан по ошибке. В этом примере мы определяем два класса <span class="inline-pre">Person</span> и <span class="inline-pre">Apartment</span>, которые создают модель блока квартир с их жителями:</p>
<pre><code class="swift language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) освобождается") }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Апартаменты \(unit) освобождаются") }
}</code></pre>
<p>Каждый экземпляр <span class="inline-pre">Person</span> имеет свойство <span class="inline-pre">name</span> типа <span class="inline-pre">String</span> и опциональное свойство <span class="inline-pre">apartment</span>, которое изначально <span class="inline-pre">nil</span>. Свойство <span class="inline-pre">apartment</span> опционально, так как наша персона не обязательно всегда должна иметь апартаменты.</p>
<p>Аналогично, что каждый экземпляр <span class="inline-pre">Apartment</span> имеет свойство <span class="inline-pre">unit</span> типа <span class="inline-pre">String</span> и опциональное свойство <span class="inline-pre">tenant</span>, которое изначально <span class="inline-pre">nil</span>. Свойство <span class="inline-pre">tenant</span> опциональное, потому как не всегда в апартаментах кто-то живет.</p>
<p>Оба этих класса определяют деинициализатор, который отображает факт того, что экземпляр освободился. Это позволяет вам видеть освободились ли экземпляры этих классов как вы ожидали или нет.</p>
<p>Следующий фрагмент кода определяет две опциональные переменные с именами <span class="inline-pre">john</span> и <span class="inline-pre">unit4A</span>, которые будут назначены определенным экземплярам классов <span class="inline-pre">Apartment</span> и <span class="inline-pre">Person</span>. Оба значения переменных равны <span class="inline-pre">nil</span>, в силу того, что они опциональны:</p>
<pre><code class="language-swift">var john: Person?
var unit4A: Apartment?</code></pre>
<p>Теперь вы можете создать свои экземпляры <span class="inline-pre">Person</span> и <span class="inline-pre">Apartment</span> и присвоить их этим переменным <span class="inline-pre">john</span>, <span class="inline-pre">unit4A</span>:</p>
<pre><code class="language-swift">john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")</code></pre>
<p>Вот как выглядят сильные связи после того создания и присваивания этих двух экземпляров. Переменная <span class="inline-pre">john</span> имеет сильную связь с экземпляром класса <span class="inline-pre">Person</span>, переменная <span class="inline-pre">unit4A</span> имеет сильную связь с экземпляром <span class="inline-pre">Apartment</span>:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/referenceCycle01_2x.png" alt="" /></p>
<p>Теперь вы можете соединить эти два экземпляра вместе, так что житель будет иметь апартаменты, а апартаменты будут иметь своих жителей. Обратите внимание, что восклицательный знак (<span class="inline-pre">!</span>) используется для развертывания и допуска к экземплярам, хранимым в опциональных переменных <span class="inline-pre">john</span>, <span class="inline-pre">unit4A</span>, так что установить значения свойством можно в такой форме:</p>
<pre><code class="swift language-swift">john!.apartment = unit4A
unit4A!.tenant = john</code></pre>
<p>Вот как выглядят сильные связи после того, как мы соединили экземпляры:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/referenceCycle02_2x.png" alt="" /></p>
<p>К сожалению, соединяя таким образом, образуется цикл сильных ссылок между экземплярами. Экземпляр <span class="inline-pre">Person</span> имеет сильную ссылку на экземпляр <span class="inline-pre">Apartment</span>, экземпляр <span class="inline-pre">Apartment</span> имеет сильную ссылку на экземпляр <span class="inline-pre">Person</span>. Таким образом, когда вы разрушаете сильные ссылки, принадлежащие переменным <span class="inline-pre">john</span> и <span class="inline-pre">unit4A</span>, их количество все равно не падает до нуля, и экземпляры не освобождаются:</p>
<pre><code class="swift language-swift">john = nil
unit4A = nil</code></pre>
<p>Обратите внимание, что ни один деинициализатор не был вызван, когда вы присваивали <span class="inline-pre">nil</span>. Цикл сильных ссылок предотвратил экземпляры <span class="inline-pre">Person</span> и <span class="inline-pre">Apartment</span> от освобождения, что вызывает утечку памяти в вашем приложении.</p>
<p>Вот как выглядят сильные ссылки после того, как вы присвоили <span class="inline-pre">nil</span> переменным, <span class="inline-pre">john</span>, <span class="inline-pre">unit4A</span>:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/referenceCycle03_2x.png" alt="" /></p>
<p>Сильные взаимные ссылки остались между экземплярами <span class="inline-pre">Person</span> и <span class="inline-pre">Apartment</span> и не могут быть разрушены.</p>
<h1><a id="resolving-strong-reference-cycles-between-class-instances"></a>Замена циклов сильных ссылок между экземплярами классов</h1>
<p>Swift предлагает два способа переопределить ссылку, чтобы она была не сильной, а слабой или бесхозной.</p>
<p>Слабые и бесхозные ссылки позволяют одному экземпляру в цикле ссылок ссылаться на другой экземпляр без сильного прикрепления. Экземпляры могут ссылаться друг на друга без создания цикла сильных связей.</p>
<p>Используйте слабую ссылку, если другой экземпляр имеет более короткое время жизни, то есть когда другой экземпляр может быть освобожден первым. В приведенном выше примере использование <span class="inline-pre">Apartment</span> уместно - у квартиры не было арендатора в какой-то момент своей жизни, и поэтому слабая ссылка является подходящим способом нарушить опорный цикл в этом случае. Используйте бесхозные ссылки, если другой экземпляр имеет одинаковое время жизни или более длительный срок службы.</p>
<h2><a id="weak-references"></a>Слабые (weak) ссылки</h2>
<p>Слабые ссылки не удерживаются за экземпляр, на который они указывают, так что ARC не берет их во внимание, когда считает ссылки экземпляра. Такой подход позволяет избежать ситуации, когда ссылка становится частью цикла сильных ссылок. Вы указываете слабую ссылку ключевым словом <span class="inline-pre">weak</span> перед объявлением имени свойства или переменной.</p>
<p>Так как слабая ссылка не сильно держит экземпляр, то этот экземпляр может быть освобожден, пока слабая ссылка все еще ссылается на него. Таким образом ARC автоматически присваивает слабой ссылке <span class="inline-pre">nil</span>, когда экземпляр, на который она указывает, освобождается. И поскольку слабые ссылки должны позволять изменять их значение до <span class="inline-pre">nil</span> во время выполнения, они всегда объявляются как переменные, а не как константы опционального типа.</p>
<p>Вы можете проверить существование значения в слабой ссылке точно так же как и с любыми другими опциональными значениями, и вы никогда не будете иметь ссылку с недопустимым значением, например, указывающую на несуществующий экземпляр.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Когда ARC устанавливает слабую ссылку на nil, наблюдатели свойств не вызываются.</p>
</div>
<p>Пример ниже идентичен тому, что мы разбирали с вами с классами <span class="inline-pre">Person</span>, <span class="inline-pre">Apartment</span>, но только теперь в нем есть одно существенное отличие. В этот раз свойство <span class="inline-pre">tenant</span> экземпляра класса <span class="inline-pre">Apartment</span> объявлено как слабая ссылка:</p>
<pre><code class="swift language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) деинициализируется") }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) деинициализируется") }
}</code></pre>
<p>Создадим как и в предыдущем примере сильные ссылки от двух переменных (<span class="inline-pre">john</span>, <span class="inline-pre">unit4A</span>) и связи между двумя экземплярами:</p>
<pre><code class="swift language-swift">var john: Person?
var unit4A: Apartment?
 
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
 
john!.apartment = unit4A
unit4A!.tenant = john</code></pre>
<p>Вот как теперь выглядит соединение двух экземпляров между собой:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/weakReference01_2x.png" alt="" /></p>
<p>Экземпляр <span class="inline-pre">Person</span> все еще имеет сильную ссылку на экземпляр <span class="inline-pre">Apartment</span>, но <span class="inline-pre">Apartment</span> имеет слабую (<span class="inline-pre">weak</span>) ссылку на экземпляр <span class="inline-pre">Person</span>. Это означает, что когда вы разрушаете сильную ссылку, которая содержится в переменной <span class="inline-pre">john</span>, то больше сильных ссылок, указывающих на экземпляр <span class="inline-pre">Person</span>, не остается:</p>
<pre><code class="swift language-swift">john = nil
// Выведет "John Appleseed деинициализируется"</code></pre>
<p>А так как больше сильных ссылок на экземпляр <span class="inline-pre">Person</span> нет, то свойство <span class="inline-pre">tenant</span> становится равным <span class="inline-pre">nil</span>:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/weakReference02_2x.png" alt="" /></p>
<p>Остается только одна сильная ссылка на экземпляр <span class="inline-pre">Apartment</span> из переменной <span class="inline-pre">unit4A</span>. Если вы разрушите эту сильную ссылку, то их общее количество станет равным нулю:</p>
<pre><code class="swift language-swift">unit4A = nil
// выводит "Апартаменты 4A деинициализируется"</code></pre>
<p>А так как больше сильных ссылок нет, то и экземпляр <span class="inline-pre">Apartment</span> тоже освобождается:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/weakReference03_2x.png" alt="" /></p>
<div class="tip">
<h4>Заметка</h4>
<p>Там, где используются сборщики "мусора", слабые указатели иногда используются для реализации простого механизма кеширования, потому что объекты без сильных связей сразу отпускаются, как только у памяти появляется необходимость избавится от "мусора". Однако со включенной ARC значения удаляются только тогда, когда уходит последняя сильная связь на них, делая слабые связи не подходящими для текущей задачи.</p>
</div>
<h2><a id="unowned-references"></a>Бесхозные ссылки</h2>
<p>Как и слабые ссылки, бесхозные ссылки также не имеют сильной связи с экземпляром, на который они указывают. В отличии от слабых ссылок, бесхозные ссылки всегда имеют значение. Из-за этого бесхозные ссылки имеют неопциональный тип. Вы указываете на то, что ссылка бесхозная ключевым словом <span class="inline-pre">unowned</span>, поставленным перед объявлением свойства или переменной.</p>
<p>Так как бесхозная ссылка не является опциональной, то вам не нужно и разворачивать ее каждый раз, когда вы собираетесь ее использовать. Вы можете обратиться к бесхозной ссылке напрямую. Однако ARC не может установить значение ссылки на <span class="inline-pre">nil</span>, когда экземпляр, на который она ссылается, освобожден, так как переменные неопционального типа не могут иметь значения <span class="inline-pre">nil</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Используйте бесхозные ссылки только в том случае, если вы абсолютно уверены в том, что ссылка всегда будет указывать на экземпляр.</p>
<p>Если вы попытаетесь получить доступ к бесхозной ссылке после того, как экземпляр, на который она ссылается освобожден, то выскочит <span class="inline-pre">runtime</span> ошибка.</p>
</div>
<p>Следующий пример определяет два класса <span class="inline-pre">Customer</span> и <span class="inline-pre">CreditCard</span>, которые обыгрывают ситуацию клиента банка и кредитной карточки для этого клиента. Эти оба класса содержат экземпляры друг друга в качестве свойства. Такое взаимоотношение классов является потенциальной возможностью образования зацикливания сильных ссылок.</p>
<p>Взаимоотношения между <span class="inline-pre">Customer</span> и <span class="inline-pre">CreditCard</span> немного отличаются от предыдущего примера с <span class="inline-pre">Apartment</span> и <span class="inline-pre">Person</span>. В этом случае клиент может иметь или не иметь кредитной карты, но кредитная карта всегда имеет владельца. Чтобы это отобразить, класс <span class="inline-pre">Customer</span> имеет опциональное свойство <span class="inline-pre">card</span>, а <span class="inline-pre">CreditCard</span> имеет неопциональное свойство <span class="inline-pre">customer</span>.</p>
<p>Более того, новый экземпляр <span class="inline-pre">CreditCard</span> может быть создан только путем передачи значения <span class="inline-pre">number</span> и экземпляра <span class="inline-pre">customer</span> в инициализатор класса <span class="inline-pre">CreditCard</span>. Это гарантирует, что экземпляр <span class="inline-pre">CreditCard</span> всегда будет иметь экземпляр <span class="inline-pre">customer</span>, который будет связан с ним, когда экземпляр <span class="inline-pre">CreditCard</span> будет создан.</p>
<p>Так как кредитная карта всегда будет иметь своего хозяина, вы определяете свойство <span class="inline-pre">customer</span> как бесхозное, для избежания цикла сильных ссылок:</p>
<pre><code class="swift language-swift">class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print("\(name) деинициализируется") }
}
 
class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print("Карта #\(number) деинициализируется") }
}</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Свойство <span class="inline-pre">number</span> класса <span class="inline-pre">CreditCard</span> определено как значение типа <span class="inline-pre">UInt64</span>, а не <span class="inline-pre">Int</span>, для того, чтобы оно было достаточно большим, чтобы хранить числа с 16 цифрами и на 32, и на 64 разрядных системах.</p>
</div>
<p>Следующий кусок кода определяет опциональную переменную типа <span class="inline-pre">Customer?</span> с именем <span class="inline-pre">john</span>, которая будет использоваться для хранения ссылки на определенного клиента. Эта переменная имеет начальное значение <span class="inline-pre">nil</span>, в силу того, что это опциональный тип:</p>
<pre><code class="swift language-swift">var john: Customer?</code></pre>
<p>Вы можете создать экземпляр <span class="inline-pre">Customer</span> и использовать его для инициализации и присваивания нового экземпляра <span class="inline-pre">CreditCard</span>, как свойство клиентской <span class="inline-pre">card</span>:</p>
<pre><code class="swift language-swift">john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234567890123456, customer: john!)</code></pre>
<p>Вот как выглядят ссылки, после того как вы связали эти два экземпляра:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/unownedReference01_2x.png" alt="" /></p>
<p>Экземпляр <span class="inline-pre">Customer</span> имеет сильную ссылку на экземпляр <span class="inline-pre">CreditCard</span>, а экземпляр <span class="inline-pre">CreditCard</span> имеет бесхозную ссылку на экземпляр <span class="inline-pre">Customer</span>.</p>
<p>Из-за того, что ссылка <span class="inline-pre">customer</span> является бесхозной, то при разрушении сильной ссылки, которая находится в переменной <span class="inline-pre">john</span>, больше сильных ссылок, указывающих на экземпляр <span class="inline-pre">Customer</span> не остается:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/unownedReference02_2x.png" alt="" /></p>
<p>Из-за того, что более сильных ссылок, ссылающихся на экземпляр <span class="inline-pre">Customer</span> нет, то этот экземпляр освобождается. После того, как это происходит, у нас не остается больше сильных ссылок, указывающих на экземпляр <span class="inline-pre">CreditCard</span>, так что он тоже освобождается:</p>
<pre><code class="swift language-swift">john = nil
// Выведет "John Appleseed деинициализируется"
// Выведет "Карта #1234567890123456 деинициализируется"</code></pre>
<p>Последний кусок кода показывает нам, что инициализаторы экземпляров <span class="inline-pre">Customer</span> и <span class="inline-pre">CreditCard</span> напечатали свои сообщения деинициализации, после того, как переменной <span class="inline-pre">john</span> был присвоен <span class="inline-pre">nil</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Примеры выше показывают как использовать <span class="inline-pre">safe unowned</span> связи. Swift так же предоставляет <span class="inline-pre">unsafe unowned</span> связи для случаев, где вам нужно отключить проверку безопасности во время исполнения, например в случае, когда вы хотите увеличить производительность. Как и со всеми небезопасными операциями, всю ответственность за проверку кода на безопасность вы берете на себя.</p>
<p>Чтобы показать, что вы будете использовать <span class="inline-pre">unsafe unowned</span> связь, вам нужно написать <span class="inline-pre">unowned(unsafe). </span>Если вы попытаетесь получить доступ к <span class="inline-pre">unsafe unowned</span> ссылке после того, как экземпляр был освобожден, ваша программа попытается получить доступ к памяти, где этот объект хранился ранее, что само по себе является небезопасной операцией.</p>
</div>
<h2>Бесхозные опциональные ссылки</h2>
<p>Вы можете обозначить опциональные ссылки на класс как "<span class="inline-pre">unowned</span>". С точки зрения модели ARC опциональная бесхозная ссылка и слабая ссылка могут быть использованы в одних и тех же контекстах. Разница лишь в том, что когда вы используете опциональную бесхозную ссылку, вы ответственны за то, чтобы она ссылалась на валидный объект или была бы установлена на <span class="inline-pre">nil</span>.</p>
<p>Ниже приведен пример, который показывает курсы, которые в свою очередь может предложить департамент в школе:</p>
<pre><code class="language-swift">class Department {
    var name: String
    var courses: [Course]
    init(name: String) {
        self.name = name
        self.courses = []
    }
}
class Course {
    var name: String
    unowned var department: Department
    unowned var nextCourse: Course?
    init(name: String, in department: Department) {
        self.name = name
        self.department = department
        self.nextCourse = nil
    }
}</code></pre>
<p>Department держит сильную ссылку на каждый курс, который предлагает департамент. В модели владения ARC департамент владеет всеми курсами, что предлагает для прохождения. Сам тип <span class="inline-pre">Course</span> имеет две бесхозные ссылки: одна на департамент, другая - на следующий курс, но сам курс не владеет ни одним из этих объектов. Каждый курс является частью департамента, так что свойство <span class="inline-pre">departament</span> не является опциональным. Однако, некоторые курсы не имеют следующего курса, так что свойство <span class="inline-pre">nextCourse</span> является опциональным.</p>
<p>Вот пример использования этих классов:</p>
<pre><code class="language-swift">let department = Department(name: "Horticulture")
let intro = Course(name: "Survey of Plants", in: department)
let intermediate = Course(name: "Growing Common Herbs", in: department)
let advanced = Course(name: "Caring for Tropical Plants", in: department)
intro.nextCourse = intermediate
intermediate.nextCourse = advanced
department.courses = [intro, intermediate, advanced]</code></pre>
<p>Код выше создает департамент и его три курса. intro, <span class="inline-pre">intermediate</span> курсы имеют последующий курс <span class="inline-pre">nextCourse</span>, что поддерживает бесхозную опциональную ссылку на курс, который должен пройти студент после окончания текущего курса.</p>
<p><img class="aligncenter" src="https://swiftbook.ru/wp-content/uploads/sites/2/2020/07/Screenshot-2020-07-18-at-8.06.42-PM.png" alt="" width="408" height="275" /></p>
<p>Бесхозная опциональная ссылка не имеет сильной связи с экземпляром класса, который она удерживает, так что она не удерживает ARC от освобождения экземпляра класса. Она ведет себя точно так же как бесхозная ссылка в ARC за исключением того, что бесхозная опциональная ссылка может быть <span class="inline-pre">nil</span>.</p>
<p>Как и в случае с неопциональными бесхозными ссылками, вы ответственны за то, чтобы <span class="inline-pre">nextCourse</span> всегда ссылался на объект еще не освобожденный из памяти. В этом случае, например, когда вы удалите курс из <span class="inline-pre">department.courses</span>, вам так же нужно удалить все ссылки, которые могут указывать на курс, который вы удалили.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Лежащий в основе опционального значения тип - <span class="inline-pre">Optional</span>, который является по своей сути просто перечислением в стандартной библиотеке Swift. Однако, опционалы являются исключением из правил, так как типы значений не могут быть маркированы как <span class="inline-pre">unowned</span>.</p>
<p>Опционал, который является оберткой для класса не использует подсчет ссылок, так что вам не нужно поддерживать сильную ссылку на опционал.</p>
</div>
<h2><a id="resolving-strong-reference-cycles-between-class-instances"></a>Бесхозные ссылки и неявно извлеченные опциональные свойства</h2>
<p>Примеры, приведенные выше, для слабых и бесхозных ссылок, описывают два из самых распространенных сценариев, где существует необходимость разрушения цикла сильных ссылок.</p>
<p>Пример с <span class="inline-pre">Person</span>, <span class="inline-pre">Apartment</span> показывает ситуацию, где два свойства, оба из которых могут иметь значение <span class="inline-pre">nil</span>, имеют потенциальную возможность образования цикла сильных связей. Этот случай лучше всего решается с помощью слабой связи.</p>
<p>Пример с <span class="inline-pre">Customer</span>, <span class="inline-pre">CreditCard</span> демонстрирует ситуацию, где одному свойству разрешено иметь значение <span class="inline-pre">nil</span>, другому - нет. Однако здесь так же существует потенциальная возможность образования цикла сильных ссылок. Такой случай лучше всего разрешается с помощью бесхозных ссылок.</p>
<p>Однако есть и третий вариант, в котором оба свойства должны всегда иметь значение, и ни одному из них нельзя иметь <span class="inline-pre">nil</span>, после завершения инициализации. В этом случае лучше всего скомбинировать бесхозное свойство одного класса с неявно извлеченным опциональным свойством другого класса.</p>
<p>Это позволяет получить доступ к обоим свойствам напрямую (без опционального извлечения) после завершения инициализации, так же позволяя избегать взаимных сильных ссылок. В этой секции вы узнаете как создать такие взаимоотношения:</p>
<p>Пример внизу определяет два класса <span class="inline-pre">Country</span>, <span class="inline-pre">City</span>, каждый из которых хранит экземпляр другого класса в качестве свойства. В такой модели каждая страна должна иметь столицу, а каждый город, должен иметь страну. Для того, чтобы это отобразить, класс <span class="inline-pre">Country</span> имеет свойство <span class="inline-pre">capitalCity</span>, а класс <span class="inline-pre">City</span> имеет свойство <span class="inline-pre">country</span>:</p>
<pre><code class="swift language-swift">class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}
 
class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}</code></pre>
<p>Для создания такой внутренней зависимости между этими двумя классами, инициализатор <span class="inline-pre">City</span> берет экземпляр <span class="inline-pre">Country</span> и сохраняет его в свойство <span class="inline-pre">country</span>.</p>
<p>Инициализатор <span class="inline-pre">City</span>, вызывается из инициализатора <span class="inline-pre">Country</span>. Однако инициализатор <span class="inline-pre">Country</span> не может передавать <span class="inline-pre">self</span> в инициализатор <span class="inline-pre">City</span> до тех пор, пока новый экземпляр <span class="inline-pre">Country</span> не будет полностью инициализирован, что описано в разделе “<a href="https://swiftbook.ru/content/languageguide/initialization/#two-phase-initialization">Двухфазная инициализация</a>”.</p>
<p>Объединив все с этим требованием, вы объявляете свойство <span class="inline-pre">capitalCity</span> класса <span class="inline-pre">Country</span> как неявно извлеченное опциональное свойство, отображаемое восклицательным знаком в конце аннотации типа (<span class="inline-pre">City!</span>). Это значит, что свойство <span class="inline-pre">capitalCity</span> имеет начальное значение равное <span class="inline-pre">nil</span>, как и в случае с другими опционалами, но к которому можно обратиться без предварительного развертывания значения, что описано в главе <a href="https://swiftbook.ru/content/languageguide/basics/#implicitly-unwrapped-optionals">Неявно извлеченные опционалы</a>.</p>
<p>Так как свойство <span class="inline-pre">capitalCity</span> имеет значение по умолчанию <span class="inline-pre">nil</span>, то новый экземпляр <span class="inline-pre">Country</span> считается полностью инициализированным, как только экземпляр <span class="inline-pre">Country</span> устанавливает свойство <span class="inline-pre">name</span> с помощью своего инициализатора. Это значит, что инициализатор <span class="inline-pre">Country</span> может ссылаться на неявное свойство <span class="inline-pre">self</span> и раздавать его, как только свойство <span class="inline-pre">name</span> получит корректное значение. Инициализатор <span class="inline-pre">Country</span> может таким образом передать <span class="inline-pre">self</span> в качестве одного из параметров для инициализатора <span class="inline-pre">City</span>, когда инициализатор <span class="inline-pre">Country</span> устанавливает свое собственное свойство <span class="inline-pre">capitalCity</span>.</p>
<p>Из всего этого можно сделать вывод, что вы можете создать экземпляры <span class="inline-pre">Country</span> и <span class="inline-pre">City</span> единственным выражением, без создания цикла сильных ссылок друг на друга. Получить значение свойства <span class="inline-pre">capitalCity</span> можно напрямую без использования восклицательного знака для извлечения опционального значения:</p>
<pre><code class="swift language-swift">var country = Country(name: "Россия", capitalName: "Москва")
print("Столицей страны \(country.name) является \(country.capitalCity.name)")
// Выведет "Столицей страны Россия является Москва"</code></pre>
<p>В примере выше использование неявно извлеченного опционала означает, что все требования двухфазного инициализатора класса выполнены. Свойство <span class="inline-pre">capitalCity</span> может быть использовано как неопциональное значение, после того как инициализация закончена, все так же избегая цикла сильных ссылок.</p>
<h1><a id="strong-reference-cycles-for-closures"></a>Циклы сильных ссылок в замыканиях</h1>
<p>Как вы видели ранее, циклы сильных ссылок могут быть созданы двумя экземплярами классов, когда они поддерживают друг на друга сильные ссылки. Вы так же видели как использовать слабые (<span class="inline-pre">weak</span>) или бесхозные (<span class="inline-pre">unowned</span>) ссылки для того, чтобы заменить ими сильные (<span class="inline-pre">strong</span>).</p>
<p>Сильные ссылки так же могут образовываться, когда вы присваиваете замыкание свойству экземпляра класса, и тело замыкания захватывает экземпляр. Этот захват может случиться из-за того, что тело замыкания получает доступ к свойству экземпляра, например <span class="inline-pre">self.someProperty</span>, или из-за того, что замыкание вызывает метод типа <span class="inline-pre">self.someMethod()</span>. В обоих случаях эти доступы и вызывают тот самый “захват” <span class="inline-pre">self</span>, при этом создавая цикл сильных ссылок.</p>
<p>Этот цикл возникает из-за того, что замыкания, как и классы, являются ссылочными типами. Когда вы присваиваете замыкание свойству, вы присваиваете ссылку на это замыкание. В общем, проблема та же, что и ранее: две сильные ссылки, которые не дают друг другу освободиться. Однако в отличии от предыдущих примеров здесь не два экземпляра классов, а замыкание и один экземпляр класса, которые поддерживают существование друг друга.</p>
<p>Swift предлагает элегантное решение этой проблемы, которые известно как <em>список захвата</em> замыкания (closure capture list). Однако до того, как вы узнаете, как разрушить такой цикл с помощью этого решения, давайте разберемся, что этот цикл может вызвать.</p>
<p>Пример ниже отображает, как вы можете создать цикл сильных ссылок, когда мы используем замыкание, которое ссылается на <span class="inline-pre">self</span>. В этом примере определяем класс <span class="inline-pre">HTMLElement</span>, который представляет модель простого элемента внутри HTML документа:</p>
<pre><code class="swift language-swift">class HTMLElement {
 
    let name: String
    let text: String?
 
    lazy var asHTML: () -&gt; String = {
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }
 
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
 
    deinit {
        print("\(name) деинициализируется")
    }
}</code></pre>
<p>Класс <span class="inline-pre">HTMLElement</span> определяет свойство name, которое отображает имя элемента, например "p" тег для отображения параграфа или “<span class="inline-pre">br</span>” для тэга перехода на следующую строку. Класс <span class="inline-pre">HTMLElement</span> также определяет опциональное свойство <span class="inline-pre">text</span>, которому может быть присвоена строка, которая отображает текст, который может быть внутри HTML элемента.</p>
<p>В дополнение к этим двум простым свойствам класс <span class="inline-pre">HTMLElement</span> определяет ленивое свойство <span class="inline-pre">asHTML</span>. Это свойство ссылается на замыкание, которое комбинирует <span class="inline-pre">name</span>, <span class="inline-pre">text</span> во фрагмент HTML строки. Свойство <span class="inline-pre">asHTML</span> имеет тип <span class="inline-pre">() -&gt; String</span>, или другими словами функция, которая не принимает параметров и возвращает строку.</p>
<p>По умолчанию свойству <span class="inline-pre">asHTML</span> присвоено замыкание, которое возвращает строку, отображающую тэг HTML. Этот тэг содержит опциональный <span class="inline-pre">text</span>, если таковой есть или не содержит его, если <span class="inline-pre">text</span>, соответственно, отсутствует. Для элемента параграфа замыкание вернет “<span class="inline-pre">&lt;p&gt;some text&lt;/p&gt;</span>” или просто “<span class="inline-pre">&lt;p /&gt;</span>”, в зависимости от того, имеет ли свойство <span class="inline-pre">text</span> какое либо значение или <span class="inline-pre">nil</span>.</p>
<p>Свойство <span class="inline-pre">asHTML</span> называется и используется несколько схоже с методом экземпляра. Однако из-за того что <span class="inline-pre">asHTML</span> является свойством-замыканием, а не методом экземпляра, то вы можете заменить значение по умолчанию свойства <span class="inline-pre">asHTML</span> на пользовательское замыкание, если вы хотите сменить отображение конкретного HTML элемента.</p>
<p>Например, свойству <span class="inline-pre">asHTML</span> может быть присвоено замыкание, которое имеет дефолтный текст на случай если свойство text равно nil, для предотвращения отображения пустого HTML тега:</p>
<pre><code class="language-swift">let heading = HTMLElement(name: "h1")
let defaultText = "some default text"
heading.asHTML = {
   return "&lt;\(heading.name)&gt;\(heading.text ?? defaultText)&lt;/\(heading.name)&gt;"
}
print(heading.asHTML())
// Выведет "&lt;h1&gt;some default text&lt;/h1&gt;"</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Свойство <span class="inline-pre">asHTML</span> объявлено как ленивое свойство, потому что оно нам нужно только тогда, когда элемент должен быть отображен в виде строкового значения для какого-либо HTML элемента выходного значения. Факт того, что свойство <span class="inline-pre">asHTML</span> является ленивым, означает, что вы можете ссылаться на <span class="inline-pre">self</span> внутри дефолтного замыкания, потому что обращение к ленивому свойству невозможно до тех пор, пока инициализация полностью не закончится и не будет известно, что <span class="inline-pre">self</span> уже существует.</p>
</div>
<p>Класс <span class="inline-pre">HTMLElement</span> предоставляет единственный инициализатор, который принимает аргумент <span class="inline-pre">name</span> и (если хочется) аргумент <span class="inline-pre">text</span> для инициализации нового элемента. Класс также определяет деинициализатор, который выводит сообщение, для отображения момента когда экземпляр <span class="inline-pre">HTMLElement</span> освобождается.</p>
<p>Вот как вы используете класс <span class="inline-pre">HTMLElement</span> для создания и вывода нового экземпляра:</p>
<pre><code class="swift language-swift">var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// Выведет "&lt;p&gt;hello, world&lt;/p&gt;"</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Переменная <span class="inline-pre">paragraph</span> определена как опциональный <span class="inline-pre">HTMLElement</span>, так что он может быть и <span class="inline-pre">nil</span> для демонстрации цикла сильных ссылок.</p>
</div>
<p>К сожалению класс <span class="inline-pre">HTMLElement</span>, который описан выше, создает цикл сильных ссылок между экземпляром <span class="inline-pre">HTMLElement</span> и замыканием, использованным для его исходного значения <span class="inline-pre">asHTML</span>. Вот как выглядит этот цикл:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/closureReferenceCycle01_2x.png" alt="" /></p>
<p>Свойство <span class="inline-pre">asHTML</span> экземпляра держит сильную ссылку на его замыкание. Однако из-за того, что замыкание ссылается на <span class="inline-pre">self</span> внутри своего тела (<span class="inline-pre">self.name</span>, <span class="inline-pre">self.text</span>), оно захватывает <span class="inline-pre">self</span>, что означает, что замыкание держит сильную ссылку обратно на экземпляр <span class="inline-pre">HTMLElement</span>. Между ними двумя образуется цикл сильных ссылок. (Для более подробной информации по захвату значений в замыканиях читайте соответствующий раздел <a href="https://swiftbook.ru/content/languageguide/closures/#capturing-values">Захват значений</a>.)</p>
<div class="tip">
<h4>Заметка</h4>
<p>Даже несмотря на то, что замыкание ссылается на <span class="inline-pre">self</span> несколько раз, оно захватывает лишь одну сильную ссылку на экземпляр <span class="inline-pre">HTMLElement</span>.</p>
</div>
<p>Если вы установите значение paragraph на <span class="inline-pre">nil</span>, чем разрушите сильную ссылку на экземпляр <span class="inline-pre">HTMLElement</span>, то ни экземпляр <span class="inline-pre">HTMLElement</span>, ни его замыкание не будут освобождены из-за цикла сильных ссылок:</p>
<pre><code class="swift language-swift">paragraph = nil</code></pre>
<p>Обратите внимание, что сообщение деинициализатора <span class="inline-pre">HTMLElement</span> не выводится на экран, что и есть факт того, что этот экземпляр не освобожден.</p>
<h1><a id="resolving-strong-reference-cycles-for-closures"></a>Замена циклов сильных ссылок в замыканиях</h1>
<p>Заменить цикл сильных ссылок между замыканием и экземпляром класса можно путем определения <em>списка захвата</em> в качестве части определения замыкания. Список захвата определяет правила, которые нужно использовать при захвате одного или более ссылочного типа в теле замыкания. Что же касательно циклов сильных связей между двумя экземплярами классов, то вы объявляете каждую захваченную ссылку как слабую или бесхозную (<span class="inline-pre">weak</span> или <span class="inline-pre">unowned</span>), вместо того, чтобы оставлять ее сильной (<span class="inline-pre">strong</span>). Правильный выбор между слабой или бесхозной ссылками зависит от взаимоотношений между различными частями вашего кода.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Swift требует от вас написания <span class="inline-pre">self.someProperty</span> или <span class="inline-pre">self.someMethod()</span> (вместо <span class="inline-pre">someProperty</span>, <span class="inline-pre">someMethod()</span>), каждый раз, когда вы обращаетесь к члену свойства <span class="inline-pre">self</span> внутри замыкания. Это помогает вам не забыть, что возможен случай случайного захвата <span class="inline-pre">self</span>.</p>
</div>
<h2>Определение списка захвата</h2>
<p>Каждый элемент в списке захвата является парой ключевого слова <span class="inline-pre">weak</span> или <span class="inline-pre">unowned</span> и ссылки на экземпляр класса (например, <span class="inline-pre">self</span>) или переменную, инициализированную с помощью какого-либо значения (например, <span class="inline-pre">delegate = self.delegate!</span>). Эти пары вписываются в квадратные скобки и разделяются между собой запятыми.</p>
<p>Размещайте список захвата перед списком параметров замыкания и его возвращаемым типом:</p>
<pre><code class="swift language-swift">lazy var someClosure: (Int, String) -&gt; String = {
      [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
   // тело замыкания
}</code></pre>
<p>Если у замыкания нет списка параметров или возвращаемого типа, так как они могут быть выведены из контекста, то разместите список захвата в самом начале замыкания, перед словом <span class="inline-pre">in</span>:</p>
<pre><code class="swift language-swift">lazy var someClosure: () -&gt; String = {
      [unowned self, weak delegate = self.delegate!] in
    // тело замыкания
}</code></pre>
<h2>Слабые (weak) или бесхозные (unowned) ссылки</h2>
<p>Определите список захвата в замыкании как бесхозную ссылку в том случае, когда замыкание и экземпляр, который оно захватывает, всегда будут ссылаться друг на друга, тогда они всегда будут освобождаться в одно и то же время.</p>
<p>Наоборот, определите список захвата в качестве слабой ссылки, когда захваченная ссылка может стать <span class="inline-pre">nil</span> в какой-либо момент в будущем. Слабые ссылки всегда опционального типа и автоматически становятся <span class="inline-pre">nil</span>, когда экземпляр, на который они ссылаются, освобождается. Это позволяет вам проверять их существование внутри тела замыкания.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Если захваченная ссылка никогда не будет <span class="inline-pre">nil</span>, то она должна быть всегда захвачена как unowned ссылка, а не <span class="inline-pre">weak</span> ссылка.</p>
</div>
<p>Бесхозная ссылка является подходящим методом захвата для предотвращения существования цикла сильных ссылок в нашем примере с <span class="inline-pre">HTMLElement</span>. Вот как можно записать класс <span class="inline-pre">HTMLElement</span>, чтобы избежать цикла:</p>
<pre><code class="swift language-swift">class HTMLElement {
    
    let name: String
    let text: String?
    
    lazy var asHTML: () -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }
    
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    
    deinit {
        print("\(name) освобождается")
    }
}</code></pre>
<p>Эта реализация <span class="inline-pre">HTMLElement</span> идентична предыдущей реализации, кроме дополнения списка захвата внутри замыкания <span class="inline-pre">asHTML</span>. В этом случае список захвата <span class="inline-pre">[unowned self]</span>, который означает: “захватить <span class="inline-pre">self</span> как <span class="inline-pre">unowned</span> ссылку, вместо <span class="inline-pre">strong</span>”.</p>
<p>Вы можете создать и вывести экземпляр <span class="inline-pre">HTMLElement</span> как и раньше:</p>
<pre><code class="swift language-swift">var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// Выведет "&lt;p&gt;hello, world&lt;/p&gt;"</code></pre>
<p>Вот как теперь выглядят связи:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/closureReferenceCycle02_2x.png" alt="" /></p>
<p>В этот раз захват <span class="inline-pre">self</span> является бесхозной ссылкой и уже не поддерживает сильной связи с экземпляром <span class="inline-pre">HTMLElement</span>, которого он захватил. Если вы установите сильную ссылку от переменной paragraph на значение <span class="inline-pre">nil</span>, то экземпляр <span class="inline-pre">HTMLElement</span> будет освобожден, что можно определить по выводимому сообщению в примере ниже:</p>
<pre><code class="swift language-swift">paragraph = nil
// Выведет "p освобождается"</code></pre>
<p>Более подробную информацию можно найти в разделе "<a href="https://swiftbook.ru/content/language-reference/expressions/#capturing-values">Список захвата</a>".</p>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/generics-in-swift" rel="8816">Универсальные шаблоны</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/memory-safety" rel="8818">Безопасность хранения</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/automatic-reference-counting/">Автоматический подсчет ссылок (ARC)</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Универсальные шаблоны
https://swiftbook.ru/content/languageguide/generics-in-swift/
				Wed, 25 Jul 2018 20:07:41 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=6998
<p>Универсальные шаблоны Универсальный код позволяет вам писать гибкие, общего назначения функции и типы, которые могут работать с любыми другими типами, с учетом требований, которые вы определили. Вы можете написать код, который не повторяется и выражает свой контент в ясной абстрактной форме. Универсальные шаблоны одна из самых мощных особенностей Swift, и большая часть всех библиотек Swift [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/generics-in-swift/">Универсальные шаблоны</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p><a name="generics"></a></p>
<h1>Универсальные шаблоны</h1>
<p><em>Универсальный код</em> позволяет вам писать гибкие, общего назначения функции и типы, которые могут работать с любыми другими типами, с учетом требований, которые вы определили. Вы можете написать код, который не повторяется и выражает свой контент в ясной абстрактной форме.</p>
<p>Универсальные шаблоны одна из самых мощных особенностей Swift, и большая часть всех библиотек Swift построена на основе универсального кода. На самом деле вы используете универсальный код все время, даже если вы этого не осознаете. Например, коллекции Swift <span class="inline-pre">Array</span> или <span class="inline-pre">Dictionary</span> являются универсальными. Вы можете создать массив, который содержит значения типа <span class="inline-pre">Int</span> или массив, который содержит значения <span class="inline-pre">String</span>, или на самом деле любой другой массив, который может содержать любой другой тип. Аналогично вы создаете словарь, который может содержать значения разных типов, и нет никакого ограничения по типу хранящихся значений.</p>
<h1>Проблема, которую решают универсальные шаблоны</h1>
<p>Приведем обычную, стандартную, неуниверсальную функцию <span class="inline-pre">swapTwoInts(_:_:)</span>, которая меняет два <span class="inline-pre">Int</span> местами:</p>
<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}</code></pre>
<p>Эта функция использует сквозные параметры для замещения значения a и b, что описано в <a href="https://swiftbook.ru/content/languageguide/functions/#in-out-parameters">Сквозные параметры</a>.</p>
<p>Функция <span class="inline-pre">swapTwoInts(_:_:)</span> обменивает начальные значения переменных <span class="inline-pre">a</span> и <span class="inline-pre">b</span> местами. Вы можете использовать эту функцию для замещения двух значений типа <span class="inline-pre">Int</span>:</p>
<pre><code class="language-swift">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// Выведет "someInt is now 107, and anotherInt is now 3"</code></pre>
<p>Функция <span class="inline-pre">swapTwoInts(_:_:)</span> полезная, но она применима только для значений типа <span class="inline-pre">Int</span>. Если вы хотите поменять местами два значения типа <span class="inline-pre">String</span> или два значения <span class="inline-pre">Double</span>, то вам придется написать больше функций, к примеру, <span class="inline-pre">swapTwoStrings(_:_:)</span> или <span class="inline-pre">swapTwoDoubles(_:_:)</span>, которые показаны ниже:</p>
<pre><code class="language-swift">func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
 
func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}</code></pre>
<p>Вы может быть заметили, что тела функций <span class="inline-pre">swapTwoInts(_:_:)</span>, <span class="inline-pre">swapTwoStrings(_:_:)</span>, и <span class="inline-pre">swapTwoDouble(_:_:)</span> идентичны. Единственное отличие в том, что они поддерживают значения различных типов (<span class="inline-pre">Int</span>, <span class="inline-pre">String</span>, и <span class="inline-pre">Double</span>).</p>
<p>Было бы намного удобнее написать одну более гибкую функцию, которая бы могла заменить значения двух переменных любого типа. Универсальный код позволяет вам написать такую функцию. (Универсальная версия этой функции приведена ниже.)</p>
<div class="tip">
<h4>Заметка</h4>
<p>Во всех трех функциях есть важный момент того, что типы <span class="inline-pre">a</span> и <span class="inline-pre">b</span> должны быть одинаковыми по отношению друг к другу. Если <span class="inline-pre">a</span> и <span class="inline-pre">b</span> не являются значениями одного типа, то будет невозможно поменять их значения местами. Swift является типо-безопасным языком и не позволяет (например) переменным с типом <span class="inline-pre">String</span> меняться значениями с типом <span class="inline-pre">Double</span>. Попытка сделать это приведет к ошибке компиляции.</p>
</div>
<h1>Универсальные функции</h1>
<p><em>Универсальные функции</em> могут работать с любыми типами. Ниже приведена универсальная версия функции <span class="inline-pre">swapTwoInts(_:_:)</span>, которая теперь называется <span class="inline-pre">swapTwoValues(_:_:)</span>:</p>
<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}</code></pre>
<p>Тело функции <span class="inline-pre">swapTwoValues(_:_:)</span> идентично телу функции <span class="inline-pre">swapTwoInts(_:_:)</span>. Однако первая строка функции <span class="inline-pre">swapTwoValues(_:_:)</span> немного отличается от аналогичной строки функции <span class="inline-pre">swapTwoInts(_:_:)</span>. Вот как можно сравнить первые строки этих функций:</p>
<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)</code></pre>
<p>Универсальная версия использует заполнитель имени типа (называется <span class="inline-pre">T</span> в нашем случае) вместо текущего имени типа (<span class="inline-pre">Int</span>, <span class="inline-pre">String</span>, <span class="inline-pre">Double</span>…). Заполнитель имени типа ничего не говорит о том, чем должно являться <span class="inline-pre">T</span>, но он говорит о том, что и <span class="inline-pre">a</span> и <span class="inline-pre">b</span> должны быть одного типа <span class="inline-pre">T</span>, независимо от того, что такое <span class="inline-pre">T.</span> Текущий тип <span class="inline-pre">T</span> будет определяться каждый раз, как вызывается функция <span class="inline-pre">swapTwoValues(_:_:)</span>.</p>
<p>Другое отличие в том, что за именем универсальной функции (<span class="inline-pre">swapTwoValues(_:_:)</span>) идет заполнитель имени типа (<span class="inline-pre">Т</span>) в угловых скобках (<span class="inline-pre">&lt;T&gt;</span>). Угловые скобки говорят Swift, что <span class="inline-pre">T</span> является заполнителем имени типа внутри определения функции <span class="inline-pre">swapTwoValues(_:_:)</span>. Так как <span class="inline-pre">T</span> является заполнителем, то Swift не смотрит на текущее значение <span class="inline-pre">T</span>.</p>
<p>Функция <span class="inline-pre">swapTwoValues(_:_:)</span> теперь может быть вызвана точно так же как и функция <span class="inline-pre">swapTwoInts</span>, за исключением того, что в нее можно передавать значения любого типа, до тех пор пока они одного типа. Каждый раз при вызове функции <span class="inline-pre">swapTwoValues(_:_:)</span>, тип <span class="inline-pre">Т</span> выводится из типов, которые передаются в эту функцию.</p>
<p>В двух примерах ниже <span class="inline-pre">T</span> имеет значение типа <span class="inline-pre">Int</span> и <span class="inline-pre">String</span> соответственно:</p>
<pre><code class="language-swift">var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt равен 107, а anotherInt равен 3
 
var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString равна "world", а anotherString равна "hello"</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Указанная выше функция <span class="inline-pre">swapTwoValues(_:_:)</span> появилась под влиянием функции, называемой <span class="inline-pre">swap</span>, которая является частью стандартной бибилиотеки Swift и предоставляется для использования в ваших приложениях. Если вам требуется поведение функции <span class="inline-pre">swapTwoValues(_:_:)</span> в вашем коде, вы можете использовать существующую в Swift функцию <span class="inline-pre">swap(_:_:)</span>, а не писать свою собственную реализацию.</p>
</div>
<h1>Параметры типа</h1>
<p>В примере выше в функции <span class="inline-pre">swapTwoValues(_:_:)</span> заполнитель имени типа <span class="inline-pre">T</span> пример <em>параметра типа</em>. Параметры типа определяют и называют тип наполнителя, и пишутся сразу после имени функции, между угловыми скобками (например, <span class="inline-pre">&lt;T&gt;</span>).</p>
<p>Как только вы определили параметр типа, то вы можете использовать его в качестве типа параметра функции (как например, параметры <span class="inline-pre">a</span> и <span class="inline-pre">b</span> в функции <span class="inline-pre">swapTwoValues(_:_:)</span>) или как возвращаемый функциональный тип, или как аннотация типа внутри тела функции. В каждом случае заполнитель типа отображается параметром типа, который заменяется на актуальное значение типа при вызове функции. (В <span class="inline-pre">swapTwoValues(_:_:)</span> в нашем примере выше произошло замещение <span class="inline-pre">Т</span> на <span class="inline-pre">Int</span> в момент, когда функция была вызвана в первый раз, и на <span class="inline-pre">String</span> при повторном вызове.)</p>
<p>Вы можете использовать несколько параметров типа, просто вписав их в угловых скобках через запятую.</p>
<h1>Именование параметров типа</h1>
<p>В большинстве случаев параметры типа имеют описательные имена, такие как <span class="inline-pre">Key</span> и <span class="inline-pre">Value</span> в <span class="inline-pre">Dictionary&lt;Key, Value&gt;</span> и <span class="inline-pre">Element</span> в <span class="inline-pre">Array&lt;Element&gt;</span>, которые помогут читающему код определить взаимосвязь между параметром типа и универсальным типом или функцией, в которых он используется. Тем не менее, когда между ними нет значимых отношений, то по традиции именами становятся отдельные буквы, такие как <span class="inline-pre">T</span>, <span class="inline-pre">U</span>, <span class="inline-pre">V</span>, как например <span class="inline-pre">T</span> в функции <span class="inline-pre">swapTwoValues(_:_:)</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Всегда давайте параметрам типа имена "горбатого" верхнего регистра (например, <span class="inline-pre">T</span> и <span class="inline-pre">MyTypeParameter</span>), чтобы указать, что они являются заполнителем для типа, а не значением.</p>
</div>
<h2>Универсальные типы</h2>
<p>В дополнение к универсальным функциям, Swift позволяет вам определять ваши <em>универсальные типы</em>. Это к примеру универсальные классы, структуры и перечисления, которые могут работать с любыми типами, наподобие тому, как работают <span class="inline-pre">Array</span> или <span class="inline-pre">Dictionary</span>.</p>
<p>Эта секция покажет вам как создать вашу универсальную коллекцию типа <span class="inline-pre">Stack</span>. <span class="inline-pre">Stack</span> - упорядоченная коллекция значений, аналогичная массиву, но с более строгим набором операций, чем имеет тип <span class="inline-pre">Array</span> языка Swift. Массив позволяет вам вставлять и удалять элементы с любой позиции массива. Однако, <span class="inline-pre">Stack</span> позволяет добавлять новые элементы только в конец коллекции (известно как <em>заталкивание</em> (или <span class="inline-pre">pushing</span> на англ) нового значения в стек). Аналогично стек позволяет удалять элементы только с конца коллекции (известно как выстреливать значение из стека (или popping по англ).</p>
<div class="tip">
<h4>Заметка</h4>
<p>Концепция стека используется классом <span class="inline-pre">UINavigationController</span> для моделирования контроллеров видов в его иерархии навигации. Вы вызываете метод <span class="inline-pre">pushViewController(_:animated:)</span> класса <span class="inline-pre">UINavigationController</span> для добавления контроллера вида на стек навигации, а метод <span class="inline-pre">popViewControllerAnimated(_:)</span> для удаления контроллера вида из стека навигации. Стек - полезная модель коллекции, когда вам нужен строгий принцип “последний на вход - первый на выход”.</p>
</div>
<p>Ниже приведена иллюстрация поведения добавления и удаления элемента из стека:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/stackPushPop_2x.png" alt="" /></p>
<ol>
<li>На данный момент у нас три значения в стеке.</li>
<li>Четвертое значение “затолкнули” на самый верх стека.</li>
<li>На этот момент в стеке находится четыре значения, самое свежее значение находится наверху.</li>
<li>Последнее значение удалено или “выстреляно” из стека.</li>
<li>После удаления значения, стек снова имеет три значения.</li>
</ol>
<p>Вот как написать неуниверсальную версию стека, в этом случае мы используем стек для хранения <span class="inline-pre">Int</span> значений:</p>
<pre><code class="language-swift">struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}</code></pre>
<p>Эта структура использует свойство <span class="inline-pre">items</span> типа <span class="inline-pre">Array</span> для хранения значений в стеке. <span class="inline-pre">Stack</span> предоставляет нам два метода, <span class="inline-pre">push</span> и <span class="inline-pre">pop</span> для добавления последнего элемента в стек и для удаления последнего элемента из стека. Эти методы отмечены как <span class="inline-pre">mutating</span>, потому как они вынуждены менять массив <span class="inline-pre">items</span>.</p>
<p>Тип <span class="inline-pre">IntStack</span>, показанный выше, может быть использован только со значениями <span class="inline-pre">Int</span>. Но он будет куда полезнее, если мы определим его как универсальный класс <span class="inline-pre">Stack</span>, который может управлять стеком любого типа.</p>
<p>Вот универсальная версия структуры:</p>
<pre><code class="language-swift">struct Stack&lt;Element&gt; {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}</code></pre>
<p>Обратите внимание как универсальная версия <span class="inline-pre">Stack</span> похожа на не универсальную, вообще отличаясь только тем, что мы используем заполнитель типа, вместо указания конкретного типа <span class="inline-pre">Int</span>. Этот параметр типа написан внутри угловых скобок ( <span class="inline-pre">&lt;Element&gt;</span>), сразу после имени структуры.</p>
<p><span class="inline-pre">Element</span> определяет заполнитель имени типа для “какого-то типа <span class="inline-pre">Element</span>”, который будет предоставлен позже. Этот будущий тип может ссылаться на <span class="inline-pre">Element</span> в любом месте определения структуры. В этом случае наш некоторый тип <span class="inline-pre">Element</span> используется в трех местах:</p>
<ul>
<li>Для создания свойства <span class="inline-pre">items</span>, которое инициализируется пустым массивом типа <span class="inline-pre">Element</span>.</li>
<li>Для указания того, что метод <span class="inline-pre">push(_:)</span> имеет единственный параметр <span class="inline-pre">item</span>, который должен быть типа <span class="inline-pre">Element</span>.</li>
<li>Для указания типа возвращаемого значения методом <span class="inline-pre">pop()</span>, которое должно быть типом <span class="inline-pre">Element</span>.</li>
</ul>
<p>Из-за того, что это является универсальным типом, то <span class="inline-pre">Stack</span> может быть использован для создания стека любых корректных типов в Swift, аналогичным образом как это осуществляют типы <span class="inline-pre">Array</span> или <span class="inline-pre">Dictionary</span>.</p>
<p>Вы создаете новый экземпляр <span class="inline-pre">Stack</span>, вписав тип хранимых значений стека в угловые скобки. Например, создадим новый стек строк, вы напишите <span class="inline-pre">Stack&lt;String&gt;()</span>:</p>
<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// stack содержит 4 строки</code></pre>
<p>Теперь <span class="inline-pre">stackOfStrings</span> выглядит вот так после добавления последних четырех значений:</p>
<p style="text-align: center;"><img style="width: 625px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/stackPushedFourStrings_2x.png" alt="" /></p>
<p>Удаляя последнее значение, он возвращает его и удаляет его из стека “<span class="inline-pre">cuatro</span>”:</p>
<pre><code class="language-swift">let fromTheTop = stackOfStrings.pop()
// fromTheTop равен "cuatro", а stack содержит 3 строки</code></pre>
<p>После удаления верхней величины, стек выглядит так:</p>
<p style="text-align: center;"><img style="width: 400px;" src="http://swiftbook.ru/wp-content/uploads/img_from_drupal_swiftbook/files/images/stackPoppedOneString_2x.png" alt="" /></p>
<h1><a id="extending-a-generic-type"></a>Расширяем универсальный тип</h1>
<p>Когда вы расширяете универсальный тип, вы не обеспечиваете список параметров в качестве определения расширения. Вместо этого, список параметров типа, из <em>исходного </em>определения типа, доступен внутри тела расширения, а имена исходных параметров типа используются для ссылки на параметры типа из исходного определения.</p>
<p>Следующий пример расширяет универсальный тип <span class="inline-pre">Stack</span>, для добавления вычисляемого свойства только для чтения <span class="inline-pre">topItem</span>, которое возвращает верхний элемент стека, без “выстреливания” его из этого стека:</p>
<pre><code class="language-swift">extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}</code></pre>
<p>Свойство <span class="inline-pre">topItem</span> возвращает опциональное значение типа Element. Если стек пустой, то <span class="inline-pre">topItem</span> возвращает <span class="inline-pre">nil</span>. Если стек не пустой, то <span class="inline-pre">topItem</span> возвращает последний элемент массива <span class="inline-pre">items</span>.</p>
<p>Обратите внимание, что расширение не определяет списка параметров типа. Вместо этого, имя существующего параметра типа <span class="inline-pre">Stack - </span><span class="inline-pre">Element</span>, используется внутри расширения для отображения опционального типа вычисляемого свойства <span class="inline-pre">topItem</span>.</p>
<p>Вычисляемое свойство <span class="inline-pre">topItem</span> теперь может быть использовано внутри экземпляра <span class="inline-pre">Stack</span> для доступа к значению и для запроса к последнему элемента стека, без дальнейшего его удаления:</p>
<pre><code class="language-swift">if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// Выведет "The top item on the stack is tres."</code></pre>
<p>Расширения общего типа могут также включать требования, которые должны удовлетворять экземпляры расширенного типа, чтобы получить новые функциональные возможности, как описано в пункте <a href="https://swiftbook.ru/content/languageguide/generics-in-swift/#extensions-with-a-generic-where-clause">Расширения с оговоркой where</a>.</p>
<h1><a id="type-constraints"></a>Ограничения типа</h1>
<p>Функция <span class="inline-pre">swapTwoValues(_:_:)</span> и тип <span class="inline-pre">Stack</span> могут работать с любыми типами. Однако иногда бывает нужно внедрить определенные ограничения типа на типы, которые могут быть использованы вместе с универсальными функциями или универсальными типами. Ограничения типа указывают на то, что параметры типа должны наследовать от определенного класса или соответствовать определенному протоколу или композиции протоколов.</p>
<p>Для примера возьмем тип <span class="inline-pre">Dictionary</span>, который имеет некоторые ограничения типов, которые могут быть использованы в качестве ключей. Как было описано в главе <a href="https://swiftbook.ru/content/languageguide/collection-types/#dictionaries">Словари</a>, тип ключа словаря должен быть хешируемым. Таким образом он должен предоставить способ представить себя уникальным. <span class="inline-pre">Dictionary</span> нужно, чтобы его ключи были хешируемыми, таким образом он может проверить, содержит ли конкретный ключ какое-либо значение. Без этого требования, <span class="inline-pre">Dictionary</span> не в состоянии понять, должен ли он заменить или вставить значение для конкретного ключа, и не в состоянии найти значение для конкретного ключа, которое уже есть в словаре.</p>
<p>Такое требование внедряется ограничениями типа для типа ключа словаря, которое определяет, что каждый ключ должен соответствовать протоколу <span class="inline-pre">Hashable</span>, специальному протоколу, который определен в стандартной библиотеке Swift. Все базовые типы в Swift (<span class="inline-pre">String</span>, <span class="inline-pre">Int</span>, <span class="inline-pre">Double</span>, <span class="inline-pre">Bool</span>) по умолчанию являются хешируемыми типами.</p>
<p>Вы можете определить свои собственные ограничения типа, когда создаете пользовательские универсальные классы, и эти ограничения предоставляют еще больше возможностей универсальному программированию. Абстрактные понятия, как <span class="inline-pre">Hashable</span>, характеризуют типы с точки зрения их концептуальных характеристик, а не их явного типа.</p>
<h2>Синтаксис ограничения типа</h2>
<p>Вы пишете ограничения типа, поместив ограничение единственного класса или протокола после имени параметра типа, и разделив их между собой запятыми, обозначая их в качестве части списка параметров. Базовый синтаксис для ограничений типа универсальной функции показан ниже (хотя синтаксис для универсальных типов такой же):</p>
<pre><code class="swift language-swift">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // тело функции…
}</code></pre>
<p>Выше описанная гипотетическая функция имеет два параметра типа. Первый параметр типа - <span class="inline-pre">T</span>, имеет ограничение типа, которое требует чтобы <span class="inline-pre">T</span>, было подклассом класса <span class="inline-pre">SomeClass</span>. Второй параметр типа - <span class="inline-pre">U</span>, имеет ограничение типа, которое требует чтобы <span class="inline-pre">U</span> соответствовал протоколу <span class="inline-pre">SomeProtocol</span>.</p>
<h2>Ограничение типа в действии</h2>
<p>Ниже приведена неуниверсальная функция <span class="inline-pre">findIndex(ofString:in:)</span>, которая получает значение типа <span class="inline-pre">String</span> для того, чтобы его найти, и массив значений типа <span class="inline-pre">String</span>, внутри которого и будет происходить поиск. Функция <span class="inline-pre">findIndex(ofString:in:)</span> возвращает опциональное значение <span class="inline-pre">Int</span>, которое является индексом первого совпадения строки с элементом внутри массива или <span class="inline-pre">nil</span>, которое означает отсутствие совпадения строки с каким-либо элементом массива:</p>
<pre><code class="language-swift">func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}</code></pre>
<p>Функция <span class="inline-pre">findIndex(ofString:in:)</span> может быть использована для поиска строкового значения в массиве строк:</p>
<pre><code class="language-swift">let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
    print("The index of llama is \(foundIndex)")
}
// Выведет "The index of llama is 2"</code></pre>
<p>Однако нахождение индекса совпадения значения в массиве бывает полезным не только для строк. Вы можете написать ту же функцию, но только в универсальной форме. Давайте напишем такую функцию и назовем ее <span class="inline-pre">findIndex</span>, а все упоминания типа <span class="inline-pre">String</span> заменим на тип <span class="inline-pre">T</span>.</p>
<p>Вот как будет выглядеть версия функции <span class="inline-pre">findIndex(ofString:in:)</span> в универсальной форме <span class="inline-pre">findIndex(of:in:)</span>. Обратите внимание, что возвращаемый функцией тип все еще равен <span class="inline-pre">Int?</span>, потому что функция возвращает опциональное значение индекса, а не опциональное значение элемента массива. Но будьте осторожны, так как эта функция не компилируется, по причинам, указанным после примера:</p>
<pre><code class="language-swift">func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}</code></pre>
<p>Как мы и сказали, эта функция не компилируется. Проблема находится в строке “<span class="inline-pre">if value == valueToFind</span>”. Не каждый тип в Swift может быть сравнен оператором равенства (<span class="inline-pre">==</span>). Если вы создаете свой класс или структуру для отображения сложной модели данных, например, то смысл выражения “равен чему-то” для этого класса или структуры Swift не может додумать за вас. Из-за этого нет никакой гарантии того, что этот код будет работать для любого возможного класса <span class="inline-pre">T</span>, и соответствующая ошибка компиляции выскакивает, когда вы пытаетесь скомпилировать код.</p>
<p>Но не все еще потеряно. Стандартная библиотека Swift определяет протокол <span class="inline-pre">Equatable</span>, который требует любой соответствующий ей тип реализовывать равенство оператору равенства (<span class="inline-pre">==</span>) и реализовывать неравенство оператору неравенства (<span class="inline-pre">!=</span>), для того, чтобы значения этих типов можно было сравнивать между собой. Все стандартные типы Swift автоматически поддерживают протокол <span class="inline-pre">Equatable</span>.</p>
<p>Любой тип, который удовлетворяет протоколу <span class="inline-pre">Equatable</span>, может быть безопасно использован в функции <span class="inline-pre">findIndex(of:in:)</span>, потому что гарантирована поддержка оператора равенства и неравенства. Для отображения этого факта, вы пишете ограничение типа <span class="inline-pre">Equatable</span>, как часть определения параметра типа, когда вы определяете функцию:</p>
<pre><code class="language-swift">func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}</code></pre>
<p>Единственный параметр типа для функции <span class="inline-pre">findIndex(of:in:)</span> записывается как <span class="inline-pre">T: Equatable</span>, что означает “любой тип <span class="inline-pre">T</span>, который соответствует протоколу <span class="inline-pre">Equatable</span>”.</p>
<p>Теперь функция <span class="inline-pre">findIndex(of:in:)</span> благополучно компилируется и может быть использована с любыми типами <span class="inline-pre">Equatable</span>, например, <span class="inline-pre">String</span>, <span class="inline-pre">Double</span>:</p>
<pre><code class="language-swift">let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex опциональный Int не имеющий значения, потому что значения 9.3 нет в массиве
let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])
// stringIndex опциональный Int равный 2</code></pre>
<h1><a id="associated-types"></a>Связанные типы</h1>
<p>При определении протокола бывает нужно определить еще один или более <em>связанных типов</em> в качестве части определения протокола. Связанный тип дает плейсхолдер имени типу, который используется как часть протокола. Фактический тип, который будет использоваться связанным типом не указывается до тех пор, пока не будет принят протокол. Связанные типы указываются при помощи ключевого слова <span class="inline-pre">associatedtype</span>.</p>
<h2>Связанные типы в действии</h2>
<p>Ниже приведен пример протокола <span class="inline-pre">Container</span>, который объявляет связанный тип <span class="inline-pre">Item</span>:</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}</code></pre>
<p>Протокол <span class="inline-pre">Container</span> определяет три требуемых возможности, которые должен иметь любой контейнер:</p>
<ul>
<li>Должна быть возможность добавлять новый элемент в контейнер при помощи метода <span class="inline-pre">append(_:)</span>.</li>
<li>Должна быть возможность получить доступ к количеству элементов в контейнере через свойство <span class="inline-pre">count</span>, которое возвращает значение типа <span class="inline-pre">Int</span>.</li>
<li>Должна быть возможность получить значение через индекс элемента, который принимает значение типа <span class="inline-pre">Int</span>.</li>
</ul>
<p>Этот протокол не указывает количество и способ хранения элементов в контейнере или какого типа они должны быть. Протокол только лишь указывает три “кусочка” функциональности, которые должны быть предоставлены контейнером, чтобы он считался <span class="inline-pre">Container</span>. Соответствующий тип может предоставлять дополнительную функциональность, пока он удовлетворяет этим трем требованиям.</p>
<p>Любой тип, который удовлетворяет протоколу <span class="inline-pre">Equatable</span> должен иметь возможность указывать на тип хранящихся элементов. Конкретно, он должен гарантировать, что только элементы правильного типа будут добавлены в контейнер, и должно быть ясно какой тип элементов будет возвращаться сабскриптом.</p>
<p>Для определения этих требований, протокол <span class="inline-pre">Container</span> должен иметь способ ссылаться на тип элементов, которые он будет хранить, без указания типа элементов, которые может хранить конкретный контейнер. Протокол <span class="inline-pre">Container</span> должен указать, что любое значение переданное в метод <span class="inline-pre">append(_:)</span> должно иметь тот же тип, что и тип элементов контейнера, и что значение, возвращаемое сабскриптом контейнера, должно быть того же типа, что и элементы контейнера.</p>
<p>Чтобы добиться этого, протокол <span class="inline-pre">Container</span> объявляет связанный тип <span class="inline-pre">Item</span>, который записывается как <span class="inline-pre">associatedtype</span> <span class="inline-pre">Item</span>. Протокол не определяет для чего конкретно нужен алиас <span class="inline-pre">Item</span>, потому что эта информация остается для любого соответствующего класса протоколу. Тем не менее, алиас <span class="inline-pre">Item</span> предоставляет способ сослаться на тип элементов в <span class="inline-pre">Container</span> и определить тип для использования метода <span class="inline-pre">append(_:)</span> и сабскрипта, для того, чтобы гарантировать, что желаемое поведение любого <span class="inline-pre">Container</span> имеет силу.</p>
<p>Ниже приведена версия неуниверсального типа <span class="inline-pre">IntStack</span>, который адаптирован под протокол <span class="inline-pre">Container</span>:</p>
<pre><code class="language-swift">struct IntStack: Container {
    // исходная реализация IntStack
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // удовлетворение требований протокола Container
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>
<p>Тип <span class="inline-pre">IntStack</span> реализует все три требования протокола Container, и в каждом случае оборачивает часть существующей функциональности типа <span class="inline-pre">IntStack</span> для удовлетворения этих требований.</p>
<p>Более того, <span class="inline-pre">IntStack</span> указывает, что для этой реализации контейнера, подходящий тип <span class="inline-pre">Item</span> будет <span class="inline-pre">Int</span>. Определение <span class="inline-pre">typealias Item = Int</span> преобразует абстрактный тип <span class="inline-pre">Item</span> в конкретный тип <span class="inline-pre">Int</span> для этой реализации протокола <span class="inline-pre">Container</span>.</p>
<p>Благодаря выводу типов Swift, вам фактически не нужно указывать конкретный тип <span class="inline-pre">Int</span> для <span class="inline-pre">Item</span> как часть определения <span class="inline-pre">IntStack</span>. Так как <span class="inline-pre">IntStack</span> соответствует протоколу <span class="inline-pre">Container</span>, Swift может вывести соответствующий тип для <span class="inline-pre">Item</span>, просто посмотрев на тип параметра <span class="inline-pre">item</span> метода <span class="inline-pre">append(_:)</span> и на тип возвращаемого значения сабскрипта. И на самом деле, если удалить строку кода <span class="inline-pre">typealias Item = Int</span>, все будет продолжать работать, потому что все еще ясно какой тип должен быть использован для <span class="inline-pre">Item</span>.</p>
<p>Вы так же можете создать универсальный тип <span class="inline-pre">Stack</span>, который соответствует протоколу <span class="inline-pre">Container</span>:</p>
<pre><code class="language-swift">struct Stack&lt;Element&gt;: Container {
    // исходная реализация Stack&lt;Element&gt;
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
    // удовлетворение требований протокола Container
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Element {
        return items[i]
    }
}</code></pre>
<p>В этот раз тип параметра <span class="inline-pre">Element</span> использован в качестве параметра <span class="inline-pre">item</span> метода <span class="inline-pre">append(_:)</span> и в качестве возвращаемого типа сабскрипта. Таким образом Swift может вывести, что <span class="inline-pre">Element</span> подходящий тип для использования его в качестве типа <span class="inline-pre">Item</span> для этого конкретного контейнера.</p>
<h2>Расширение существующего типа для указания связанного типа</h2>
<p>Вы можете расширить существующий тип для того, чтобы добавить соответствие протоколу, как описано в <a href="https://swiftbook.ru/content/languageguide/protocols/#adding-protocol-conformance-with-an-extension">Добавление реализации протокола через расширение</a>. Это включает в себя протокол со связанным типом.</p>
<p>Тип <span class="inline-pre">Array</span> уже предоставляет нам метод <span class="inline-pre">append(_:)</span>, свойство <span class="inline-pre">count</span> и сабскрипт со значением индекса типа <span class="inline-pre">Int</span> для получения его элементов. Эти три возможности удовлетворяют и совпадают с требованиями протокола <span class="inline-pre">Container</span>. Это означает, что вы можете расширить тип <span class="inline-pre">Array</span>, чтобы он соответствовал протоколу <span class="inline-pre">Container</span>, просто указав, что <span class="inline-pre">Array</span> принимает протокол <span class="inline-pre">Container</span>. Вы можете сделать это при помощи пустого расширения, которое подробнее описано в подразделе главы <a href="https://swiftbook.ru/content/languageguide/protocols/#declaring-protocol-adoption-with-an-extension">Принятие протокола через расширение</a>:</p>
<pre><code class="swift language-swift">extension Array: Container {}</code></pre>
<p>Существующий метод <span class="inline-pre">append(_:)</span> типа <span class="inline-pre">Array</span> и сабскрипт позволяют Swift выводить соответствующий тип для <span class="inline-pre">Item</span>, точно так же как и для универсального типа <span class="inline-pre">Stack</span>, который был приведен ранее. После определения расширения вы можете использовать <span class="inline-pre">Array</span> как <span class="inline-pre">Container</span>.</p>
<h2>Добавление ограничений в связанный тип</h2>
<p>Вы можете добавить ограничение к связанному типу в протоколе, чтобы требовать, чтобы соответствующие типы удовлетворяли этим ограничениям. Например, следующий код определяет версию <span class="inline-pre">Container</span>, который требует, чтобы его элементы реализовывали протокол <span class="inline-pre">Equatable</span>.</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}</code></pre>
<p>Для соответствия данной версии <span class="inline-pre">Container</span>, каждому элементу <span class="inline-pre">Container</span> нужно соответствовать/реализовывать протокол <span class="inline-pre">Equatable</span>.</p>
<h1>Использование протокола в ограничениях связанного типа</h1>
<p>Протокол может выступать как часть собственных требований. Например, ниже в примере, есть протокол, который уточняет протокол <span class="inline-pre">Container</span>, добавляя метод <span class="inline-pre">suffix(_:)</span>. Метод <span class="inline-pre">suffix(_:)</span> возвращает заданное количество элементов из конца контейнера, сохраняя их в экземпляре типа <span class="inline-pre">Suffix</span>.</p>
<pre><code class="language-swift">protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -&gt; Suffix
}</code></pre>
<p>В этом протоколе <span class="inline-pre">Suffix</span> является ассоциированным типом, подобным типу <span class="inline-pre">Item</span> в приведенном выше примере. <span class="inline-pre">Suffix</span> имеет два ограничения: он должен соответствовать протоколу <span class="inline-pre">SuffixableContainer</span> (протокол, который в настоящее время определяется), а его тип <span class="inline-pre">Item</span> должен быть таким же, как тип <span class="inline-pre">Item</span> контейнера. Ограничение на <span class="inline-pre">Item</span> является общей оговоркой <span class="inline-pre">where</span>, которое обсуждается ниже.</p>
<p>Ниже расширение типа Stack, которое добавляет соответствие протоколу <span class="inline-pre">SuffixableContainer</span>:</p>
<pre><code class="language-swift">extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack {
        var result = Stack()
        for index in (count-size)..<count {
            result.append(self[index])
        }
        return result
    }
    // Определено, что Suffix является Stack.
}
var stackOfInts = Stack<Int>()
stackOfInts.append(10)
stackOfInts.append(20)
stackOfInts.append(30)
let suffix = stackOfInts.suffix(2)
// suffix содержит 20 и 30</code></pre>
<p>В примере выше, ассоциативный тип <span class="inline-pre">Suffix</span> для <span class="inline-pre">Stack</span> является тем же <span class="inline-pre">Stack</span>, так что операция <span class="inline-pre">suffix</span> в <span class="inline-pre">Stack</span> вернет другой <span class="inline-pre">Stack</span>. Альтернативно, тип который соответствует требованиям протокола <span class="inline-pre">SuffixableContainer</span> может иметь тип <span class="inline-pre">Suffix</span>, который отличается от самого себя, что означает, что операция suffix может вернуть другой тип. Например, ниже расширение для <span class="inline-pre">IntStack</span>, который добавляет соответствие протоколу <span class="inline-pre">SuffixableContainer</span>, используя <span class="inline-pre">Stack</span> в качестве суффиксного типа, вместо <span class="inline-pre">IntStack</span>.</p>
<pre><code class="language-swift">extension IntStack: SuffixableContainer {
    func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; {
        var result = Stack&lt;Int&gt;()
        for index in (count-size)..&lt;count {
            result.append(self[index])
        }
        return result
    }
    // Определено, что Suffix является Stack&lt;Int&gt;.
}</code></pre>
<h1><a id="where-clause"></a>Оговорка where</h1>
<p>Ограничения типа, как описано в главе <a href="https://swiftbook.ru/content/languageguide/generics-in-swift/#type-constraints">Ограничения типа</a>, позволяют вам определять требования параметров типа связанных с универсальными функциями или типами.</p>
<p>Так же бывает полезно определять требования для связанных типов. Чтобы сделать это, вы определяете оговорку <span class="inline-pre">where</span>, как часть списка параметров типа. Оговорка <span class="inline-pre">where</span> позволяет вам требовать, чтобы связанный тип, соответствовал определенному протоколу, и/или чтобы конкретные параметры типа и связанные типы были одними и теми же. Вы пишете оговорку <span class="inline-pre">where</span>, поместив ключевое слово <span class="inline-pre">where</span> сразу после списка параметров типа, за которым следует одно или более ограничений для связанных типов, и/или один или более отношений равенства между типами и связанными типами.</p>
<p>В примере ниже определяем универсальную функцию <span class="inline-pre">allItemsMatch</span>, которая проверяет, чтобы увидеть содержат ли два экземпляра <span class="inline-pre">Container</span> одни и те же элементы в одной и той же последовательности. Функция возвращает значение типа <span class="inline-pre">Bool</span>, то есть, если у нас все элементы и их последовательность совпадает, то функция возвращает <span class="inline-pre">true</span>, если нет - <span class="inline-pre">false</span>.</p>
<p>Контейнеры не должны быть одного типа для того чтобы их проверить, хотя они и могут, но они должны содержать элементы одного и того же типа. Это требование выражается через комбинацию ограничений типа и оговоркой <span class="inline-pre">where</span>:</p>
<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.Item == C2.Item, C1.Item: Equatable {
        
        // Проверяем одинаковое ли количество элементов находится в контейнерах.
        if someContainer.count != anotherContainer.count {
            return false
        }
        
        // Проверяем все ли значения попарно равны.
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }
        
        // Все элементы совпадают, так что возвращаем true.
        return true
}</code></pre>
<p>Эта функция принимает два аргумента <span class="inline-pre">someContainer</span> и <span class="inline-pre">anotherContainer</span>. Аргумент <span class="inline-pre">someContainer</span> имеет тип <span class="inline-pre">C1</span>, аргумент <span class="inline-pre">anotherContainer</span> имеет тип <span class="inline-pre">C2</span>. И <span class="inline-pre">C1</span> и <span class="inline-pre">C2</span> являются заполнителями имен типов для двух контейнеров, которые будут определены, когда будет вызвана функция.</p>
<p>Список типов параметров функции размещает следующие требования на два параметров типа:</p>
<ul>
<li><span class="inline-pre">C1</span> должен соответствовать протоколу <span class="inline-pre">Container</span> (<span class="inline-pre">C1: Container</span>)</li>
<li><span class="inline-pre">C2</span> должен соответствовать протоколу <span class="inline-pre">Container</span> (<span class="inline-pre">C2: Container</span>)</li>
<li><span class="inline-pre">Item</span> для <span class="inline-pre">C1</span> должен быть тем же, что и <span class="inline-pre">Item</span> для <span class="inline-pre">C2</span> (<span class="inline-pre">C1.Item == C2.Item</span>)</li>
<li><span class="inline-pre">Item</span> для <span class="inline-pre">C1</span> должен соответствовать протоколу <span class="inline-pre">Equatable</span> (<span class="inline-pre">C1.Item: Equatable</span>)</li>
</ul>
<p>Третье и четвертое требования определены как часть оговорки <span class="inline-pre">where</span>, и записаны после ключевого слова <span class="inline-pre">where</span>, в качестве части списка типов параметров функции.</p>
<p>Эти требования означают:</p>
<ul>
<li><span class="inline-pre">someContainer</span> является контейнером типа <span class="inline-pre">C1</span>.</li>
<li><span class="inline-pre">anotherContainer</span> является контейнером типа <span class="inline-pre">C2</span>.</li>
<li><span class="inline-pre">someContainer</span> и <span class="inline-pre">anotherContainer</span> содержат значения одного типа</li>
<li>Элементы в <span class="inline-pre">someContainer</span> могут быть проверены при помощи оператора неравенства (<span class="inline-pre">!=</span>), чтобы увидеть, что они отличаются друг от друга.</li>
</ul>
<p>Третье и четвертое требование комбинируются так, чтобы элементы в <span class="inline-pre">anotherContainer</span> так же могли бы быть проверены оператором <span class="inline-pre">!=</span>, потому что они в точности одного и того же типа, что и в <span class="inline-pre">someContainer</span>.</p>
<p>Эти требования позволяют функции <span class="inline-pre">allItemsMatch(_:_:)</span> сравнивать два контейнера, даже если они являются контейнерами разного типа.</p>
<p>Функция <span class="inline-pre">allItemsMatch(_:_:)</span> начинается с проверки количества элементов в этих контейнерах. Если они содержат разное количество элементов, то эти контейнеры уже не могут быть одинаковыми, функция возвращает <span class="inline-pre">false</span>.</p>
<p>После проведения этой проверки, функция перебирает все элементы в <span class="inline-pre">someContainer</span> при помощи <span class="inline-pre">for-in</span> цикла и полуоткрытого оператора диапазона (<span class="inline-pre">..&lt;</span>). Для каждого элемента <span class="inline-pre">someContainer</span> функция проверяет равенство элемента соответствующему элементу в контейнере <span class="inline-pre">anotherContainer</span>. Если два элемента не равны друг другу, то эти два контейнера не считаются одинаковыми, функция возвращает <span class="inline-pre">false</span>.</p>
<p>Если цикл закончился без каких-либо несоответствий элементов, то два контейнера считаются одинаковыми, и функция возвращает <span class="inline-pre">true</span>.</p>
<p>Вот как выглядит функция <span class="inline-pre">allItemsMatch(_:_:)</span> в действии:</p>
<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
 
var arrayOfStrings = ["uno", "dos", "tres"]
 
if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("All items match.")
} else {
    print("Not all items match.")
}
// Выведет "All items match."</code></pre>
<p>Пример выше создает экземпляр <span class="inline-pre">Stack</span> для хранения значений типа <span class="inline-pre">String</span> и добавляет три значения в стек. Так пример создает экземпляр <span class="inline-pre">Array</span>, который инициализируется литералом массива, содержащего три одинаковые строки в стеке. Даже тогда стек и массив имеют разные типы, но оба они соответствуют протоколу <span class="inline-pre">Container</span>, и оба они содержат одинаковый тип значений. Тем не менее вы можете вызвать функцию <span class="inline-pre">allItemsMatch(_:_:)</span> с этими двумя контейнерами в качестве своих аргументов. В примере выше функция <span class="inline-pre">allItemsMatch(_:_:)</span> корректно извещает нас, что все элементы этих двух контейнеров одинаковые.</p>
<h2><a id="extensions-with-a-generic-where-clause"></a>Расширения с оговоркой where</h2>
<p>Вы так же можете использовать оговорку  <span class="inline-pre">where</span> в расширениях. В примере ниже у нас есть расширение для структуры <span class="inline-pre">Stack</span> из прошлого примера, где мы добавляем метод  <span class="inline-pre">isTop(_:)</span>.</p>
<pre><code class="language-swift">extension Stack where Element: Equatable {
    func isTop(_ item: Element) -&gt; Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}</code></pre>
<p>Новый метод <span class="inline-pre">isTop(_:)</span> сначала проверяет, что наш стек не пустой, а затем сравнивает верхний элемент стека с данным нам <span class="inline-pre">item</span>. Если вы попытаетесь сделать то же самое без универсальной <span class="inline-pre">where</span>, то у вас будут проблемы. Реализация  <span class="inline-pre">isTop(_:)</span> использует оператор <span class="inline-pre">==</span>, но определение <span class="inline-pre">Stack</span> не требует того, чтобы элементы могли сравниваться, так что написание оператора  <span class="inline-pre">==</span> вызовет ошибку компиляции. Использование универсальной  <span class="inline-pre">where</span> позволяет вам добавить новое требование к расширению, так что расширение добавляет метод <span class="inline-pre">isTop(_:)</span> только в том случае, если элементы в <span class="inline-pre">Stack</span> реализуют <span class="inline-pre">Equatable</span>.</p>
<p>Вот как будет выглядеть наш метод <span class="inline-pre">isTop(_:)</span> в действии:</p>
<pre><code class="language-swift">if stackOfStrings.isTop("tres") {
    print("Top element is tres.")
} else {
    print("Top element is something else.")
}
// Выведет "Top element is tres."</code></pre>
<p>Если вы попытаетесь вызвать метод <span class="inline-pre">isTop(_:)</span> в стеке, то те, элементы, которые не реализуют протокол <span class="inline-pre">Equatable </span>вызовут ошибку компиляции:</p>
<pre><code class="language-swift">struct NotEquatable { }
var notEquatableStack = Stack&lt;NotEquatable&gt;()
let notEquatableValue = NotEquatable()
notEquatableStack.push(notEquatableValue)
notEquatableStack.isTop(notEquatableValue)  // Error</code></pre>
<p>Вы можете использовать универсальную <span class="inline-pre">where</span> с расширениями протоколов. Пример ниже расширяет протокол <span class="inline-pre">Container </span>из прошлого примера, добавляя ему новый метод <span class="inline-pre">startsWith(_:)</span>.</p>
<pre><code class="language-swift">extension Container where Item: Equatable {
    func startsWith(_ item: Item) -&gt; Bool {
        return count &gt;= 1 &amp;&amp; self[0] == item
    }
}</code></pre>
<p>Метод <span class="inline-pre">startsWith(_:)</span> сначала проверяет на наличие элементов в контейнере, а затем проверяет не равен ли данный элемент первому элементу контейнера. Новый метод <span class="inline-pre">startsWith(_:) </span>может быть использован с любым типом, который реализует протокол <span class="inline-pre">Container</span>, включая стеки, массивы, использованные ранее, элементы контейнера соответствуют протоколу <span class="inline-pre">Equatable</span>.</p>
<pre><code class="language-swift">if [9, 9, 9].startsWith(42) {
    print("Starts with 42.")
} else {
    print("Starts with something else.")
}
// Выведет "Starts with something else."</code></pre>
<p>Универсальная оговорка <span class="inline-pre">where</span> в примере выше требует, чтобы <span class="inline-pre">Item</span> соответствовал протоколу <span class="inline-pre">Container, но вы так же можете использовать </span><span class="inline-pre">where</span> для указания конкретного типа для <span class="inline-pre">Item</span>. Например:</p>
<pre><code class="language-swift">extension Container where Item == Double {
    func average() -&gt; Double {
        var sum = 0.0
        for index in 0..&lt;count {
            sum += self[index]
        }
        return sum / Double(count)
    }
}
print([1260.0, 1200.0, 98.6, 37.0].average())
// Выведет "648.9"</code></pre>
<p>Этот пример добавляет контейнерам метод <span class="inline-pre">average()</span>, у которых <span class="inline-pre">Item</span> имеет тип <span class="inline-pre">Double</span>. Он итерирует по элементам контейнера, суммируя их, и делит сумму на их общее количество. Он явно преобразует <span class="inline-pre">count</span> из <span class="inline-pre">Int</span> в <span class="inline-pre">Double </span>что позволяет нам проводить деление чисел с плавающей точкой.</p>
<p>Вы можете включать несколько требований в универсальную <span class="inline-pre">where</span>, которая будет являться частью расширения. Все требования просто записываются через запятую.</p>
<h2>Контекстуальная оговорка Where</h2>
<p>Вы можете написать универсальную оговорку where во время объявления, которая не будет иметь своих собственных универсальных ограничений по типу, когда вы уже работаете в контексте универсального типа. Например, вы можете написать универсальную оговорку where сабскрипту универсального типа или методу внутри расширения универсального типа. Структура Container является универсальной, и оговорка where в примере ниже определяет какого типа ограничения должны быть выполнены, чтобы эти новые методы были доступны контейнеру.</p>
<pre><code class="language-swift">extension Container {
    func average() -&gt; Double where Item == Int {
        var sum = 0.0
        for index in 0..&lt;count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
    func endsWith(_ item: Item) -&gt; Bool where Item: Equatable {
        return count &gt;= 1 &amp;&amp; self[count-1] == item
    }
}
let numbers = [1260, 1200, 98, 37]
print(numbers.average())
// Выведет "648.75"
print(numbers.endsWith(37))
// Выведет "true"</code></pre>
<p>В этом примере мы добавляем методы <span class="inline-pre">average()</span> в структуру <span class="inline-pre">Container</span>, когда элементы имеют целочисленный тип, а так же мы добавляем метод <span class="inline-pre">endsWith(_:)</span>, если элементы соответствуют протоколу <span class="inline-pre">Equatable</span>. Оба метода включают в себя оговорку where, которая добавляет ограничения по типу для <span class="inline-pre">Item</span> из оригинального объявления структуры <span class="inline-pre">Container</span>.</p>
<p>Если вы хотите написать этот код без контекстуальной оговорки <span class="inline-pre">where</span>, вам нужно написать два расширения, по одному для каждой оговорки <span class="inline-pre">where</span>. Пример выше и пример ниже имеют полностью идентичное поведение.</p>
<pre><code class="language-swift">extension Container where Item == Int {
    func average() -&gt; Double {
        var sum = 0.0
        for index in 0.. Bool {
        return count &gt;= 1 &amp;&amp; self[count-1] == item
    }
}</code></pre>
<p>В ранее приведенном примере, который использует контекстуальную оговорку <span class="inline-pre">where</span>, реализация методов <span class="inline-pre">average()</span> и <span class="inline-pre">endsWith(_:)</span>  размещена в одном расширении структуры, потому что в каждом случае универсальная оговорка where определяет требования, которые нужно удовлетворить, чтобы методы были доступными. Перемещая эти требования выше, в требования расширения, мы делаем эти же самые методы доступными в тех же случаях, но мы разделяем наши расширения между собой по самим этим требованиям.</p>
<h2>Связанные типы с универсальной оговоркой where</h2>
<p>Вы можете включать универсальную оговорку <span class="inline-pre">where</span> в связанный тип. Например, предположим, что вы хотите создать версию своего <span class="inline-pre">Container</span>, которая включает в себя итератор, точно так же как и протокол <span class="inline-pre">Sequence</span> использует стандартную библиотеку. Вот как вы можете это записать:</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
    
    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -&gt; Iterator
}</code></pre>
<p>Универсальная оговорка <span class="inline-pre">where</span> в <span class="inline-pre">Iterator</span> требует, чтобы итератор должен поддерживать тот же самый тип элементов, что и тип элементов контейнера, не смотря на тип самого итератора. Метод <span class="inline-pre">makeIterator()</span> предоставляет доступ к итератору контейнера.</p>
<p>Для протокола, который наследуется от другого протокола, вы можете добавить ограничение в унаследованный связанный тип, путем включения универсальной оговорки <span class="inline-pre">where</span> в объявление протокола. Например следующий код объявляет протокол <span class="inline-pre">ComparableContainer</span>, который требует, чтобы <span class="inline-pre">Item</span> соответствовал протоколу <span class="inline-pre">Comparable</span>:</p>
<pre><code class="language-swift">protocol ComparableContainer: Container where Item: Comparable { }</code></pre>
<h2>Универсальные сабскрипты</h2>
<p>Сабскрипты могут быть универсальными, и они могут включать в себя универсальную оговорку <span class="inline-pre">where</span>. Вы можете написать имя-плейсхолдер внутри угловых скобок после ключевого слова <span class="inline-pre">subscript</span>, и вы пишете универсальную оговорку <span class="inline-pre">where</span> прямо до открывающей фигурной скобки тела сабскрипта. Например:</p>
<pre><code class="language-swift">extension Container {
    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]
        where Indices.Iterator.Element == Int {
            var result = [Item]()
            for index in indices {
                result.append(self[index])
            }
            return result
    }
}</code></pre>
<p>Расширения протоколу <span class="inline-pre">Container</span> добавляет сабскрипт, который принимает последовательность индексов и возвращает массив, содержащий элементы указанных индексов. Универсальный сабскрипт имеет следующие ограничения:</p>
<ul>
<li>Универсальный параметр <span class="inline-pre">Indices</span> в угловых скобках, должен быть типа, который реализует протокол <span class="inline-pre">Sequence</span> из стандартной библиотеки.</li>
<li>Сабскрипт принимает один параметр, <span class="inline-pre">indices</span>, который является экземпляром типа <span class="inline-pre">Indices</span>.</li>
<li>Универсальная оговорка <span class="inline-pre">where</span> требует, чтобы итератор последовательности мог перемещаться по элементам типа <span class="inline-pre">Int</span>. Это гарантирует, что индексы последовательности того же самого типа, что и индексы, которые использовались в контейнере.</li>
</ul>
<p>Беря все это во внимание, ограничения, которые описаны выше означают, что значения, передаваемые для параметра <span class="inline-pre">indices</span>, должны быть последовательностью элементов типа <span class="inline-pre">Int</span>.</p>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/protocols" rel="8815">Протоколы</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/automatic-reference-counting" rel="8817">Автоматический подсчет ссылок (ARC)</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/generics-in-swift/">Универсальные шаблоны</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
Протоколы
https://swiftbook.ru/content/languageguide/protocols/
				Tue, 24 Jul 2018 13:11:51 +0000
swiftbook
http://testing.swiftbook.ru/?post_type=manual_documentation&p=6990
<p>Протоколы Протокол определяет образец методов, свойств или другие требования, которые соответствуют определенному конкретному заданию или какой-то функциональности. Протокол фактически не предоставляет реализацию для любого из этих требований, он только описывает как реализация должна выглядеть. Протокол может быть принят классом, структурой или перечислением для обеспечения фактической реализации этих требований. Любой тип, который удовлетворяет требованиям протокола, имеет [&#8230;]</p>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/protocols/">Протоколы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>
<p><a name="top"></a></p>
<h1>Протоколы</h1>
<p><em>Протокол</em> определяет образец методов, свойств или другие требования, которые соответствуют определенному конкретному заданию или какой-то функциональности. Протокол фактически не предоставляет реализацию для любого из этих требований, он только описывает как реализация должна выглядеть. Протокол может быть <em>принят</em> классом, структурой или перечислением для обеспечения фактической реализации этих требований. Любой тип, который удовлетворяет требованиям протокола, имеет указание <em>соответствовать</em> этому протоколу или другими словами <em>реализовать</em> данный протокол.</p>
<p>В дополнение к определенным требованиям, которые должны быть реализованы подписанными под протокол типами, вы можете расширить протокол, чтобы реализовать некоторые из этих требований или для того, чтобы реализовать дополнительную функциональность, которую смогут использовать подписанные под протокол типы.</p>
<h1>Синтаксис протокола</h1>
<p>Определение протокола очень похоже на то, как вы определяете классы, структуры и перечисления:</p>
<pre><code class="swift language-swift">protocol SomeProtocol {
    // определение протокола…
}</code></pre>
<p>Пользовательские типы утверждают, что они принимают протокол, когда они помещают имя протокола после имени типа и разделяются с этим именем двоеточием, то есть указывают эти протоколы как часть их определения. После двоеточия вы можете указывать множество протоколов, перечисляя их имена через запятую:</p>
<pre><code class="swift language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // определение структуры…
}</code></pre>
<p>Если у класса есть суперкласс, то вписывайте имя суперкласса до списка протоколов, которые он принимает, также разделите имя суперкласса и имя протокола запятой:</p>
<pre><code class="swift language-swift">class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // определение класса…
}</code></pre>
<h1><a id="property-requirements"></a>Требование свойств</h1>
<p>Протокол требует у соответствующего ему типа предоставить свойство экземпляра или свойство типа, и это свойство должно иметь конкретное имя и тип. Протокол не уточняет какое должно быть свойство, хранимое или вычисляемое, только лишь указывает на требование имени свойства и типа. Протокол уточняет должно ли свойство быть доступным, или оно должно быть доступным <em>и</em> устанавливаемым.</p>
<p>Если протокол требует от свойства быть доступным и устанавливаемым, то это требование не может полностью быть удовлетворено константой или вычисляемым свойством только для чтения (read only). Если протокол только требует от свойства читаемости (get), то такое требование может быть удовлетворено любым свойством, и это так же справедливо для устанавливаемого свойства, если это необходимо в вашем коде.</p>
<p>Требуемые свойства всегда объявляются как переменные свойства, с префиксом <span class="inline-pre">var</span>. Свойства, значения которых вы можете получить или изменить маркируются <span class="inline-pre">{ get set }</span> после объявления типа свойства, а свойства, значения которых мы можем только получить, но не изменить <span class="inline-pre">{ get }</span>.</p>
<pre><code class="swift language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}</code></pre>
<p>Перед требуемыми свойствами типов пишете префикс <span class="inline-pre">static</span>, когда вы определяете их в протоколе. Это правило распространяется даже тогда, когда требование свойств может иметь как префикс <span class="inline-pre">static</span> так и префикс <span class="inline-pre">class</span>, когда мы реализуем их в классах:</p>
<pre><code class="swift language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}</code></pre>
<p>Пример протокола с единственным требуемым свойством экземпляра:</p>
<pre><code class="swift language-swift">protocol FullyNamed {
    var fullName: String { get }
}</code></pre>
<p>Протокол <span class="inline-pre">FullyNamed</span> требует у соответствующего ему типа предоставить полное имя. Протокол больше не уточняет ничего, кроме того, что тип этого свойства должен быть в состоянии предоставить свое полное имя. Протокол утверждает, что любой тип <span class="inline-pre">FullyNamed</span> должен иметь свойство <span class="inline-pre">fullName</span>, значение которого может быть получено, и это значение должно быть типа <span class="inline-pre">String</span>.</p>
<p>Ниже приведен пример структуры, которая принимает и полностью соответствует протоколу <span class="inline-pre">FullyNamed</span>:</p>
<pre><code class="swift language-swift">struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName равен "John Appleseed"</code></pre>
<p>Этот пример определяет структуру <span class="inline-pre">Person</span>, которая отображает персону с конкретным именем. Она утверждает, что она принимает протокол <span class="inline-pre">FullyNamed</span> в качестве первой строки собственного определения.</p>
<p>Каждый экземпляр <span class="inline-pre">Person</span> имеет единственное свойство <span class="inline-pre">fullName</span> типа <span class="inline-pre">String</span>. Это удовлетворяет единственному требованию протокола <span class="inline-pre">FullyNamed</span>, и это значит, что Person корректно соответствует протоколу. (Swift сообщает об ошибке во время компиляции, если требования протокола выполняются не полностью.)</p>
<p>Ниже представлен более сложный класс, который так же принимает и соответствует протоколу <span class="inline-pre">FullyNamed</span>:</p>
<pre><code class="swift language-swift">class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName равен "USS Enterprise"</code></pre>
<p>Класс реализует требуемое свойство <span class="inline-pre">fullName</span>, в качестве вычисляемого свойства только для чтения (для космического корабля). Каждый экземпляр класса <span class="inline-pre">Starship</span> хранит обязательный <span class="inline-pre">name</span> и опциональный <span class="inline-pre">prefix</span>. Свойство <span class="inline-pre">fullName</span> использует значение <span class="inline-pre">prefix</span>, если оно существует и устанавливает его в начало <span class="inline-pre">name</span>, чтобы получилось целое имя для космического корабля.</p>
<h1><a id="method-requirements"></a>Требование методов</h1>
<p>Протоколы могут требовать реализацию определенных методов экземпляра и методов типа, соответствующими типами протоколу. Эти методы написаны как часть определения протокола в точности в такой же форме как и методы экземпляра или типа, но только в них отсутствуют фигурные скобки или тело метода целиком. Вариативные параметры допускаются точно так же как и в обычных методах. Дефолтные значения, однако, не могут быть указаны для параметров метода внутри определения протокола.</p>
<p>Как и в случае с требованиями свойств типа, вы всегда указываете префикс <span class="inline-pre">static</span> для метода типа. И это верно даже тогда, когда требования к методу типа имеет префикс <span class="inline-pre">static</span> или <span class="inline-pre">class</span>, когда реализуется классом:</p>
<pre><code class="swift language-swift">protocol SomeProtocol {
    static func someTypeMethod()
}</code></pre>
<p>Следующий пример определяет протокол с единственным требуемым методом экземпляра:</p>
<pre><code class="swift language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}</code></pre>
<p>Этот протокол <span class="inline-pre">RandomNumberGenerator</span> требует любой соответствующий ему тип иметь метод экземпляра <span class="inline-pre">random</span>, который при вызове возвращает значение типа <span class="inline-pre">Double</span>. Хотя это и не указано как часть протокола, но предполагается, что значение будет числом от <span class="inline-pre">0.0</span> и до <span class="inline-pre">1.0</span> (не включительно).</p>
<p>Протокол <span class="inline-pre">RandomNumberGenerator</span> не делает никаких предположений по поводу того, как будет находиться это случайное число, он просто требует генератор предоставить стандартный способ генерации нового рандомного числа.</p>
<p>Ниже приведена реализация класса, который принимает и соответствует протоколу <span class="inline-pre">RandomNumberGenerator</span>. Этот класс реализует алгоритм генератора псевдослучайных чисел, известный как алгоритм <em>линейного конгруэнтного генератора</em>:</p>
<pre><code class="swift language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// Выведет "Случайное число: 0.37464991998171"
print("And another one: \(generator.random())")
// Выведет "Другое случайное число: 0.729023776863283"</code></pre>
<h1>Требования изменяющих методов</h1>
<p>Иногда необходимо для метода изменить (или <em>мутировать</em>) экземпляр, которому он принадлежит. Для методов экземпляра типа значения (структура, перечисление) вы располагаете ключевое слово <span class="inline-pre">mutating</span> до слова метода <span class="inline-pre">func</span>, для индикации того, что этому методу разрешено менять экземпляр, которому он принадлежит, и/или любое свойство этого экземпляра. Этот процесс описан в главе <a href="https://swiftbook.ru/content/languageguide/methods/#mutating-method-requirements">Изменение типов значений методами экземпляра</a>.</p>
<p>Если вы определяете требуемый протоколом метод экземпляра, который предназначен менять экземпляры любого типа, которые принимают протокол, то поставьте ключевое слово <span class="inline-pre">mutating</span> перед именем метода, как часть определения протокола. Это позволяет структурам и перечислениями принимать протокол и удовлетворять требованию метода.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Если вы поставили ключевое слово <span class="inline-pre">mutating</span> перед методом требуемым протоколом экземпляра, то вам не нужно писать слово <span class="inline-pre">mutating</span> при реализации этого метода для класса. Слово <span class="inline-pre">mutating</span> используется только структурами или перечислениями.</p>
</div>
<p>Пример ниже определяет протокол <span class="inline-pre">Togglable</span>, который определяет единственный требуемый метод экземпляра <span class="inline-pre">toggle()</span>. Как и предполагает имя метода, он переключает или инвертирует состояние любого типа, обычно меняя свойство этого типа.</p>
<p>Метод <span class="inline-pre">toggle()</span> имеет слово <span class="inline-pre">mutating</span> как часть определения протокола <span class="inline-pre">Togglable</span>, для отображения того, что этот метод меняет состояние соответствующего протоколу экземпляра при своем вызове:</p>
<pre><code class="swift language-swift">protocol Togglable {
    mutating func toggle()
}</code></pre>
<p>Если вы реализуете протокол <span class="inline-pre">Togglable</span> для структур или перечислений, то эта структура или перечисление может соответствовать протоколу предоставляя реализацию метода <span class="inline-pre">toggle()</span>, который так же будет отмечен словом <span class="inline-pre">mutating</span>.</p>
<p>Пример ниже определяет перечисление <span class="inline-pre">OnOffSwitch</span>. Это перечисление переключается между двумя состояниями, отмеченными двумя случаями перечислениям <span class="inline-pre">.on</span> и <span class="inline-pre">.off</span>. Реализация метода <span class="inline-pre">toggle</span> перечисления отмечена словом <span class="inline-pre">mutating</span>, чтобы соответствовать требованию протокола:</p>
<pre><code class="swift language-swift">enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch теперь равен .on</code></pre>
<h1>Требование инициализатора</h1>
<p>Иногда протоколы могут требовать реализацию конкретного инициализатора типами соответствующими протоколу. Вы пишете эти инициализаторы как часть определения протокола, точно так же как и обычные инициализаторы, но только без фигурных скобок или без тела инициализатора:</p>
<pre><code class="swift language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}</code></pre>
<h2>Реализация класса соответствующего протоколу с требованием инициализатора</h2>
<p>Вы можете реализовать требуемый инициализатор в классе, соответствующем протоколу, в качестве назначенного инициализатора или вспомогательного. В любом случае вам нужно отметить этот инициализатор ключевым словом <span class="inline-pre">required</span>:</p>
<pre><code class="swift language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // реализация инициализатора…
    }
}</code></pre>
<p>Использование модификатора <span class="inline-pre">required</span> гарантирует, что вы проведете явную или унаследованную реализацию требуемого инициализатора на всех подклассах соответствующего класса протоколу, так, чтобы они тоже соответствовали протоколу. Подробнее вы можете прочитать в главе <a href="https://swiftbook.ru/content/languageguide/initialization/#required-initializers">Требуемые инициализаторы</a>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Вам не нужно обозначать реализацию инициализаторов протокола модификатором <span class="inline-pre">required</span> в классах, где стоит модификатор <span class="inline-pre">final</span>, потому что конечные классы не могут иметь подклассы. Для более полной информации по модификатору <span class="inline-pre">final</span> читайте главу <a href="https://swiftbook.ru/content/languageguide/inheritance/#preventing-overrides">Предотвращение переопределения</a>.</p>
</div>
<p>Если подкласс переопределяет назначенный инициализатор суперкласса и так же реализует соответствующий протоколу инициализатор, то обозначьте реализацию инициализатора сразу двумя модификаторами <span class="inline-pre">required</span> и <span class="inline-pre">override</span>:</p>
<pre><code class="swift language-swift">protocol SomeProtocol {
    init()
}
 
class SomeSuperClass {
    init() {
        // реализация инициализатора…
    }
}
 
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" от соответствия протоколу SomeProtocol; "override" от суперкласса SomeSuperClass
    required override init() {
        // реализация инициализатора…
    }
}</code></pre>
<h2>Требуемые проваливающиеся инициализаторы</h2>
<p>Протоколы могут определять требования проваливающихся инициализаторов для соответствуемых протоколу типов, что определено в главе <a href="https://swiftbook.ru/content/languageguide/initialization/#failable-initializers">Проваливающиеся инициализаторы</a>.</p>
<p>Требование проваливающегося инициализатора может быть удовлетворено проваливающимся инициализатором или непроваливающимся инициализатором соответствующего протоколу типа. Требование непроваливающегося инициализатора может быть удовлетворено непроваливающимся инициализатором или неявно развернутым проваливающимся инициализатором.</p>
<h1><a id="protocols-as-types"></a>Протоколы как типы</h1>
<p>Протоколы сами по себе не несут какой-то новой функциональности. Тем не менее любой протокол, который вы создаете становится полноправным типом, который вы можете использовать в вашем коде.</p>
<p>Так как это тип, то вы можете использовать протокол во многих местах, где можно использовать другие типы:</p>
<ul>
<li>Как тип параметра или возвращаемый тип в функции, методе, инициализаторе</li>
<li>Как тип константы, переменной или свойства</li>
<li>Как тип элементов массива, словаря или другого контейнера</li>
</ul>
<div class="tip">
<h4>Заметка</h4>
<p>Из-за того что протоколы являются типами, то их имена начинаются с заглавной буквы (как в случае <span class="inline-pre">FullyNamed</span> или <span class="inline-pre">RandomNumberGenerator</span>) для соответствия имен с другими типами Swift (<span class="inline-pre">Int</span>, <span class="inline-pre">String</span>, <span class="inline-pre">Bool</span>, <span class="inline-pre">Double</span>…)</p>
</div>
<p>Вот пример использования протокола в качестве типа:</p>
<pre><code class="swift language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}</code></pre>
<p>Этот пример определяет новый класс <span class="inline-pre">Dice</span>, который отображает игральную кость с n количеством сторон для настольной игры. Экземпляры <span class="inline-pre">Dice</span> имеют свойство <span class="inline-pre">sides</span>, которое отображает количество сторон, которое они имеют, так же кубики имеют свойство <span class="inline-pre">generator</span>, которое предоставляет генератор случайных чисел, из которого и берутся значения броска игрального кубика.</p>
<p>Свойство <span class="inline-pre">generator</span> имеет тип <span class="inline-pre">RandomNumberGenerator</span>, таким образом вы можете использовать в этом свойстве экземпляр любого типа, соответствующий протоколу <span class="inline-pre">RandomNumberGenerator</span>. Больше ничего не требуется от экземпляра, присваемого этому свойству, кроме того, что этот экземпляр должен принимать протокол <span class="inline-pre">RandomNumberGenerator</span>.</p>
<p><span class="inline-pre">Dice</span> так же имеет инициализатор для установки начальных значений. Этот инициализатор имеет параметр <span class="inline-pre">generator</span>, который так же является типом <span class="inline-pre">RandomNumberGenerator</span>. Вы можете передать значение любого соответствующего протоколу типа в этот параметр, когда инициализируете новый экземпляр <span class="inline-pre">Dice</span>.</p>
<p><span class="inline-pre">Dice</span> предоставляет один метод экземпляра - <span class="inline-pre">roll</span>, который возвращает целое значение от <span class="inline-pre">1</span> и до количества сторон на игральной кости. Этот метод вызывает генератор метода <span class="inline-pre">random()</span>, для создания нового случайного числа от <span class="inline-pre">0.0</span> и до <span class="inline-pre">1.0</span>, а затем использует это случайное число для создания значения броска игральной кости в соответствующем диапазоне (<span class="inline-pre">1…n</span>). Так как мы знаем, что <span class="inline-pre">generator</span> принимает <span class="inline-pre">RandomNumberGenerator</span>, то это гарантирует нам, что у нас будет метод <span class="inline-pre">random()</span>.</p>
<p>Вот как используется класс <span class="inline-pre">Dice</span> для создания шестигранной игральной кости с экземпляром <span class="inline-pre">LinearCongruentialGenerator</span> в качестве генератора случайных чисел:</p>
<pre><code class="swift language-swift">var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Бросок игральной кости равен \(d6.roll())")
}
// Бросок игральной кости равен 3
// Бросок игральной кости равен 5
// Бросок игральной кости равен 4
// Бросок игральной кости равен 5
// Бросок игральной кости равен 4</code></pre>
<div class="bottom-page-nav">
<p class="bottom-page-nav-right">
</div>
<h1><a id="delegation"></a>Делегирование</h1>
<p><em>Делегирование</em> - это шаблон, который позволяет классу или структуре передавать (или делегировать) некоторую ответственность экземпляру другого типа. Этот шаблон реализуется определением протокола, который инкапсулирует делегируемые полномочия, таким образом, что соответствующий протоколу тип (делегат) гарантировано получит функциональность, которая была ему делегирована. Делегирование может быть использовано для ответа на конкретное действие или для получения данных из внешнего источника без необходимости знания типа источника.</p>
<p>Пример ниже определяет два протокола для использования в играх, основанных на бросках игральных костей:</p>
<pre><code class="swift language-swift">protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate: AnyObject {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}</code></pre>
<p>Протокол <span class="inline-pre">DiceGame</span> является протоколом, который может быть принят любой игрой, которая включает игральную кость.</p>
<p>Протокол <span class="inline-pre">DiceGameDelegate</span> может быть принят любым типом для отслеживания прогресса <span class="inline-pre">DiceGame</span>. Для предотвращения цикла сильных ссылок, делегаты определены как <span class="inline-pre">weak</span> ссылки. Для дополнительной информации смотрите раздел <a href="https://swiftbook.ru/content/languageguide/automatic-reference-counting/#strong-reference-cycles-between-class-instances">Циклы сильных ссылок между экземплярами классов</a>. Маркировка протокола "только для классов" позволяет классу <span class="inline-pre">SnakesAndLadders </span>далее в этой главе объявить, что его делегат должен использовать слабую ссылку. Классовые протоколы наследуют протокол <span class="inline-pre">AnyObject</span>, о чем подробнее говорится в <a href="https://swiftbook.ru/content/languageguide/protocols/#class-only-protocols">Классовых протоколах</a>.</p>
<p>Вот версия игры “Змеи и лестницы”, которая первоначально была представлена в разделе <a href="https://swiftbook.ru/content/languageguide/control-flow/#top">Управление потоком</a>. Эта версия адаптирована под использование экземпляра Dice для своих бросков кости, для соответствия протоколу <span class="inline-pre">DiceGame</span> и для уведомления <span class="inline-pre">DiceGameDelegate</span> о прогрессе:</p>
<pre><code class="swift language-swift">class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    weak var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare &gt; finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}</code></pre>
<p>Для описания процесса игры “Змеи и лестницы”, посмотрите раздел инструкции <a href="https://swiftbook.ru/content/languageguide/control-flow/#break-statement">Break</a>.</p>
<p>Эта версия игры обернута в класс <span class="inline-pre">SnakesAndLadders</span>, который принимает протокол <span class="inline-pre">DiceGame</span>. Он предоставляет свойство <span class="inline-pre">dice</span> и метод <span class="inline-pre">play()</span> для соответствия протоколу. (Свойство <span class="inline-pre">dice</span> объявлено как константное свойство, потому что оно не нуждается в изменении значения после инициализации, а протокол требует только чтобы оно было доступным.)</p>
<p>Настройка игры “<em>Змеи и лестницы</em>” происходит в инициализаторе класса <span class="inline-pre">init()</span>. Вся логика игры перемещается в метод <span class="inline-pre">play</span> протокола, который использует требуемое свойство протокола для предоставления значений броска игральной кости.</p>
<p>Обратите внимание, что свойство <span class="inline-pre">delegate</span> определено как <em>опциональное </em><span class="inline-pre">DiceGameDelegate</span>, потому что делегат не требуется для игры. Так как оно является опциональным типом, свойство <span class="inline-pre">delegate</span> автоматически устанавливает начальное значение равное <span class="inline-pre">nil</span>. Таким образом, у каждого экземпляра игры есть установки свойства подходящему делегату. Так как <span class="inline-pre">DiceGameDelegate</span> является протоколом только для классов, то мы должны установить модификатор <span class="inline-pre">weak</span> у делегата, чтобы избежать цикла сильных ссылок.</p>
<p><span class="inline-pre">DiceGameDelegate</span> предоставляет три метода для отслеживания прогресса игры. Эти три метода были включены в логику игры внутри метода <span class="inline-pre"><span class="inline-pre">play()</span></span>, и вызываются когда начинается новая игра, начинается новый ход или игра кончается.</p>
<p>Так как свойство <span class="inline-pre">delegate</span> является опциональным <span class="inline-pre">DiceGameDelegate</span>, метод <span class="inline-pre">play()</span> использует опциональную последовательность каждый раз, как вызывается этот метод у делегата. Если свойство <span class="inline-pre">delegate</span> равно <span class="inline-pre">nil</span>, то этот вызов этого метода делегатом проваливается без возникновения ошибки. Если свойство <span class="inline-pre">delegate</span> не <span class="inline-pre">nil</span>, вызываются методы делегата, которые передаются в экземпляр <span class="inline-pre">SnakesAndLadders</span> в качестве параметра.</p>
<p>Следующий пример показывает класс <span class="inline-pre">DiceGameTracker</span>, который принимает протокол <span class="inline-pre">DiceGameDelegate</span>:</p>
<pre><code class="swift language-swift">class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Начали новую игру Змеи и лестницы")
        }
        print("У игральной кости \(game.dice.sides) граней")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Выкинули \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("Длительность игры \(numberOfTurns) хода")
    }
}</code></pre>
<p><span class="inline-pre">DiceGameTracker</span> реализует все три метода, которые требует <span class="inline-pre">DiceGameDelegate</span>. Он использует эти методы для отслеживания количества ходов, которые были сделаны в игре. Он сбрасывает значение свойства <span class="inline-pre">numberOfTurns</span> на ноль, когда начинается игра и увеличивает каждый раз, как начинается новый ход и выводит общее число ходов, как только кончается игра.</p>
<p>Реализация <span class="inline-pre">gameDidStart(_:)</span>, показанная ранее, использует параметр <span class="inline-pre">game</span> для отображения вступительной информации об игре, в которую будут играть. Параметр <span class="inline-pre">game</span> имеет тип <span class="inline-pre">DiceGame</span>, но не <span class="inline-pre">SnakesAndLadders</span>, так что <span class="inline-pre">gameDidStart(_:)</span> может получить и использовать только те методы и свойства, которые реализованы как часть протокола <span class="inline-pre">DiceGame</span>. Однако метод все еще может использовать приведение типов для обращения к типу основного (исходного) экземпляра. В этом примере, он проверяет действительно ли <span class="inline-pre">game</span> является экземпляром <span class="inline-pre">SnakesAndLadders</span> или нет, а потом выводит соответствующее сообщение.</p>
<p><span class="inline-pre">gameDidStart(_:)</span> так же получает доступ к свойству <span class="inline-pre">dice</span>, передаваемого параметра <span class="inline-pre">game</span>. Так как известно, что <span class="inline-pre">game</span> соответствует протоколу <span class="inline-pre">DiceGame</span>, то это гарантирует наличие свойства <span class="inline-pre">dice</span>, таким образом метод <span class="inline-pre">gameDidStart(_:)</span> может получить доступ и вывести сообщение о свойстве кости <span class="inline-pre">sides</span>, независимо от типа игры, в которую играют.</p>
<p>Теперь давайте взглянем на то, как выглядит <span class="inline-pre">DiceGameTracker</span> в действии:</p>
<pre><code class="swift language-swift">let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Начали новую игру Змеи и лестницы
// У игральной кости 6 граней
// Выкинули 3
// Выкинули 5
// Выкинули 4
// Выкинули 5
// Длительность игры 4 хода</code></pre>
<h1><a id="adding-protocol-conformance-with-an-extension"></a>Добавление реализации протокола через расширение</h1>
<p>Вы можете расширить существующий тип для того, чтобы он соответствовал протоколу, даже если у вас нет доступа к источнику кода для существующего типа. Расширения могут добавлять новые свойства, методы и сабскрипты существующему типу, что таким образом может удовлетворить любым требованиями протокола. Для более полной информации читайте <a href="https://swiftbook.ru/content/languageguide/extensions/#top">Расширения</a>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Существующие экземпляры типа автоматически принимают и отвечают требованиям протокола, когда опции, необходимые для соответствия добавляются через расширение типа.</p>
</div>
<p>К примеру, этот протокол <span class="inline-pre">TextRepresentable</span> может быть реализован любым типом, который может отображать текст. Это может быть собственное описание или текстовая версия текущего состояния:</p>
<pre><code class="swift language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}</code></pre>
<p>Класс <span class="inline-pre">Dice</span>, о котором мы говорили ранее, может быть расширен для принятия и соответствия протоколу <span class="inline-pre">TextRepresentable</span>:</p>
<pre><code class="swift language-swift">extension Dice: TextRepresentable {
    var textualDescription: String {
        return "Игральная кость с \(sides) гранями"
    }
}</code></pre>
<p>Это расширение принимает новый протокол в точности так же, как если бы <span class="inline-pre">Dice</span> был представлен внутри его первоначальной реализации. Имя протокола предоставляется после имени типа и отделяется от имени двоеточием, и реализация всех требований протокола обеспечивается внутри фигурных скобок расширения.</p>
<p>Теперь экземпляр <span class="inline-pre">Dice</span> может быть использован как <span class="inline-pre">TextRepresentable</span>:</p>
<pre><code class="swift language-swift">let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
print(d12.textualDescription)
// Выведет "Игральная кость с 12 гранями"</code></pre>
<p>Аналогично игровой класс <span class="inline-pre">SnakesAndLadders</span> может быть расширен для того, чтобы смог принять и соответствовать протоколу <span class="inline-pre">TextRepresentable</span>:</p>
<pre><code class="swift language-swift">extension SnakesAndLadders: TextRepresentable {
    var textualDescription: String {
        return "Игра Змеи и Лестницы с полем в \(finalSquare) клеток"
    }
}
print(game.textualDescription)
// Выведет "Игра Змеи и Лестницы с полем в 25 клеток"</code></pre>
<p><strong><span style="font-size: 18pt;">Условное соответствие протоколу</span></strong></p>
<p>Шаблонный тип может удовлетворять требованиям протокола только при определенных условиях, например, когда общий параметр типа соответствует протоколу. Вы можете сделать общий тип условно соответствующим протоколу, указав ограничения при расширении типа. Напишите эти ограничения после имени протокола, который вы используете, написав оговорку where. Дополнительные сведения о оговорках where см. В разделе <a href="https://swiftbook.ru/content/languageguide/generics-in-swift/#where-clause">Оговорки where</a>.</p>
<p>Следующее расширение делает экземпляры Array совместимыми с TextRepresentable протоколом всякий раз, когда они хранят элементы типа, которые соответствуют TextRepresentable:</p>
<pre><code class="swift language-swift">extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
// Prints "[A 6-sided dice, A 12-sided dice]"
</code></pre>
<h2><a id="declaring-protocol-adoption-with-an-extension"></a>Принятие протокола через расширение</h2>
<p>Если тип уже соответствует всем требованиям протокола, но еще не заявил, что он принимает этот протокол, то вы можете сделать это через пустое расширение:</p>
<pre><code class="swift language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return "Хомяка назвали \(name)"
    }
}
extension Hamster: TextRepresentable {}</code></pre>
<p>Экземпляры <span class="inline-pre">Hamster</span> теперь могут быть использованы в тех случаях, когда нужен тип <span class="inline-pre">TextRepresentable</span>:</p>
<pre><code class="swift language-swift">let simonTheHamster = Hamster(name: "Фруша")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// Выведет "Хомяка назвали Фруша"</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Типы не принимают протоколы автоматически, если они удовлетворяют их требованиям. Принятие протокола должно быть объявлено в явной форме.</p>
</div>
<h1>Принятие протокола через синтезированную реализацию</h1>
<p>Swift может автоматически предоставлять соответствие таких протоколов как <span class="inline-pre">Equatable</span>, <span class="inline-pre">Hashable</span> и <span class="inline-pre">Comparable</span> в большинстве простых случаев. Использование синтезированной реализации означает для нас, что мы не должны будем писать повторяющийся шаблонный код, для того, чтобы реализовать требования протокола.</p>
<p>Swift предоставляет синтезированную реализацию протокола <span class="inline-pre">Equatable</span> для следующих кастомных типов:</p>
<ul>
<li>Cтруктуры, которые имеют только свойства хранения и соответствуют протоколу <span class="inline-pre">Equatable</span></li>
<li>Перечисления, которые имеют только ассоциативные типы и соответствуют протоколу <span class="inline-pre">Equatable</span></li>
<li>Перечисления, которые не имеют ассоциативных типов</li>
</ul>
<p>Чтобы получить синтезированную реализацию оператора <span class="inline-pre">==</span>, вам нужно объявить о соответствии протоколу <span class="inline-pre">Equatable</span> в файле, который содержит оригинальное объявление без реализации оператора <span class="inline-pre">==</span>. По умолчанию <span class="inline-pre">Equatable</span> предоставит свою дефолтную реализацию оператора <span class="inline-pre">!=</span>.</p>
<p>В примере ниже представлена структура <span class="inline-pre">Vector3D</span> для позиционирования вектора в 3D пространстве, то есть с координатами <span class="inline-pre">x</span>, <span class="inline-pre">y</span>, <span class="inline-pre">z</span>, аналогично тому как это было представлено в структуре <span class="inline-pre">Vector2D</span>. Так как все три свойства <span class="inline-pre">x</span>, <span class="inline-pre">y</span>, <span class="inline-pre">z</span> соответствуют протоколу <span class="inline-pre">Equatable</span>, то  <span class="inline-pre">Vector3D</span> получает синтезированную реализацию оператора равенства.</p>
<pre><code class="language-swift">struct Vector3D: Equatable {
    var x = 0.0, y = 0.0, z = 0.0
}
let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
if twoThreeFour == anotherTwoThreeFour {
    print("Эти два вектора эквивалентны.")
}
// Выведет "Эти два вектора эквивалентны."</code></pre>
<p>Swift предоставляет синтезированную реализацию протокола <span class="inline-pre">Hashable</span> для следующих кастомных типов:</p>
<ul>
<li>Структуры имеют только свойства хранения, которые соответствуют протоколу <span class="inline-pre">Hashable</span></li>
<li>Перечисления, которые имеют только ассоциативные типы, которые соответствуют протоколу <span class="inline-pre">Hashable</span></li>
<li>Перечисления, которые не имеют ассоциативных типов</li>
</ul>
<p>Для получения синтезированной реализации метода <span class="inline-pre">hash(into:)</span>, нужно объявить о соответсвии протоколу <span class="inline-pre">Hashable</span> в файле, который содержит оригинальное объявление  без реализации метода <span class="inline-pre">hash(into:)</span>.</p>
<p>Swift предоставляет синтезированную реализацию <span class="inline-pre">Comparable</span> для перечислений, у которых нет сырого значения (<span class="inline-pre">rawValue</span>). Если перечисление имеет ассоциативные типы, то они все должны соответствовать протоколу <span class="inline-pre">Comparable</span>. Для получения синтезированной реализации оператора <span class="inline-pre">&lt;</span>, объявите о соответствии протоколу <span class="inline-pre">Comparable</span> в файле, который содержит оригинальное объявление перечисления, без реализации оператора <span class="inline-pre">&lt;</span>. Дефолтная реализация операторов протокола <span class="inline-pre">Comparable</span> <span class="inline-pre">&lt;=</span>, <span class="inline-pre">&gt;</span> и <span class="inline-pre">&gt;=</span> предоставляет реализацию остальных операторов сравнения.</p>
<p>Пример ниже определяет перечисление <span class="inline-pre">SkillLevel</span> с кейсами <span class="inline-pre">beginner</span>, <span class="inline-pre">intermediate</span>, <span class="inline-pre">expert</span>. Кейс <span class="inline-pre">expert</span> дополнительно ранжируется по количеству звезд.</p>
<pre><code class="language-swift">enum SkillLevel: Comparable {
    case beginner
    case intermediate
    case expert(stars: Int)
}
var levels = [SkillLevel.intermediate, SkillLevel.beginner,
              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]
for level in levels.sorted() {
    print(level)
}
// Выведет "beginner"
// Выведет "intermediate"
// Выведет "expert(stars: 3)"
// Выведет "expert(stars: 5)"</code></pre>
<h1>Коллекции типов протокола</h1>
<p>Протоколы могут использоваться в качестве типов, которые хранятся в таких коллекциях как массивы или словари, что упоминалось ранее в<a href="https://swiftbook.ru/content/languageguide/protocols/#protocols-as-types"> Протоколы как типы</a>.</p>
<p>Пример ниже создает массив из элементов типа <span class="inline-pre">TextRepresentable</span>:</p>
<pre><code class="swift language-swift">let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></pre>
<p>Теперь мы можем перебирать элементы массива и выводить текстовое отображение каждого из них:</p>
<pre><code class="swift language-swift">for thing in things {
    print(thing.textualDescription)
}
// Игра Змеи и Лестницы с полем в 25 клеток
// Игральная кость с 12 гранями
// Хомяка назвали Фруша</code></pre>
<p>Обратите внимание, что константа <span class="inline-pre">things</span> является типом <span class="inline-pre">TextRepresentable</span>. Она не является типом <span class="inline-pre">Dice</span>, или <span class="inline-pre">DiceGame</span>, или <span class="inline-pre">Hamster</span>, даже в том случае, если базовый тип является одним из них. Тем не менее из-за того, что она типа <span class="inline-pre">TextRepresentable</span>, а все что имеет тип <span class="inline-pre">TextRepresentable</span>, имеет метод <span class="inline-pre">textualDescription</span>, что значит, что можно безопасно вызывать <span class="inline-pre">thing.textualDescription</span> каждую итерацию цикла.</p>
<h1><a id="protocol-inheritance"></a>Наследование протокола</h1>
<p>Протокол может наследовать один или более других протоколов и может добавлять требования поверх тех требований протоколов, которые он наследует. Синтаксис наследования протокола аналогичен синтаксису наследования класса, но с возможностью наследовать сразу несколько протоколов, которые разделяются между собой запятыми:</p>
<pre><code class="swift language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // определение протокола…
}</code></pre>
<p>Ниже приведен пример протокола, который наследует протокол <span class="inline-pre">TextRepresentable</span>, о котором мы говорили ранее:</p>
<pre><code class="swift language-swift">protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}</code></pre>
<p>Этот пример определяет новый протокол <span class="inline-pre">PrettyTextRepresentable</span>, который наследует из <span class="inline-pre">TextRepresentable</span>. Все, что соответствует протоколу <span class="inline-pre">PrettyTextRepresentable</span>, должно удовлетворять всем требованиям <span class="inline-pre">TextRepresentable</span>, плюс дополнительные требования введенные от протокола <span class="inline-pre">PrettyTextRepresentable</span>. В этом примере <span class="inline-pre">PrettyTextRepresentable</span> добавляет единственное требование обеспечить read-only свойство экземпляра <span class="inline-pre">prettyTextualDescription</span>, которое возвращает <span class="inline-pre">String</span>.</p>
<p>Класс <span class="inline-pre">SnakesAndLadders</span> может быть расширен, чтобы иметь возможность принять и соответствовать <span class="inline-pre">PrettyTextRepresentable</span>:</p>
<pre><code class="swift language-swift">extension SnakesAndLadders: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder &gt; 0:
                output += "▲ "
            case let snake where snake &lt; 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}</code></pre>
<p>Это расширение утверждает, что оно принимает протокол <span class="inline-pre">PrettyTextRepresentable</span> и реализует свойство <span class="inline-pre">prettyTextualDescription</span> для типа <span class="inline-pre">SnakesAndLadders</span>. Все, что является типом <span class="inline-pre">PrettyTextRepresentable</span>, так же должно быть и <span class="inline-pre">TextRepresentable</span>, таким образом, реализация <span class="inline-pre">prettyTextualDescription</span> начинается с обращения к свойству <span class="inline-pre">textualDescription</span> из протокола <span class="inline-pre">TextRepresentable</span> для начала вывода строки. Затем он добавляет двоеточие и символ разрыва строки для начала текстового отображения. Затем он проводит перебор элементов массива (клеток доски) и добавляет их геометрические формы для отображения контента:</p>
<ul>
<li>Если значение клетки больше нуля, то это является началом лестницы, и это отображается символом ▲.</li>
<li>Если значение клетки меньше нуля, то это голова змеи, и эта ячейка имеет символ ▼.</li>
<li>И наоборот, если значение клетки равно нулю, то это “свободная” клетка, которая отображается символом ○.</li>
</ul>
<p>Эта реализация метода может быть использована для вывода текстового описания любого экземпляра <span class="inline-pre">SnakesAndLadders</span>:</p>
<pre><code class="swift language-swift">print(game.prettyTextualDescription)
// Игра Змеи и Лестницы с полем в 25 клеток:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</code></pre>
<h1><a id="class-only-protocols"></a>Классовые протоколы</h1>
<p>Вы можете ограничить протокол так, чтобы его могли принимать только классы (но не структуры или перечисления), добавив <span class="inline-pre">AnyObject</span> протокол к списку реализации протоколов.</p>
<pre><code class="swift language-swift">protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // определение протокола типа class-only
}</code></pre>
<p>В примере выше <span class="inline-pre">SomeClassOnlyProtocol</span> может быть принят только классом. Если вы попытаетесь принять протокол <span class="inline-pre">SomeClassOnlyProtocol</span> структурой или перечислением, то получите ошибку компиляции.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Используйте протоколы class-only, когда поведение, определяемое протоколом, предполагает или требует, что соответствующий протоколу тип должен быть ссылочного типа, а не типом значения. Для более детального исследования с вашей стороны прочитайте главы: <a href="https://swiftbook.ru/content/languageguide/classes-and-structures/#structures-and-enumerations-are-value-types">Структуры и перечисления - типы значения</a> и <a href="https://swiftbook.ru/content/languageguide/classes-and-structures/#classes-are-reference-types">Классы - ссылочный тип</a>.</p>
</div>
<h1><a id="protocol-composition"></a>Композиция протоколов</h1>
<p>Иногда бывает удобно требовать тип, который будет соответствовать сразу нескольким протоколам. Вы можете скомбинировать несколько протоколов в одно единственное требование при помощи <em>композиции протоколов</em>. Композиции протоколов ведут себя так, как будто вы определили временный локальный протокол, который имеет комбинированные требования ко всем протоколам в композиции. Композиции протоколов не определяют новых типов протоколов.</p>
<p>Композиции протоколов имеют форму <span class="inline-pre">SomeProtocol &amp; AnotherProtocol</span>. Вы можете перечислить столько протоколов, сколько нужно, разделяя их между собой знаком амперсанда (<span class="inline-pre">&amp;</span>). В дополнение к списку протоколов, композиция протокола также может содержать один тип класса, который можно использовать для указания требуемого суперкласса.</p>
<p>Ниже приведен пример, который комбинирует два протокола <span class="inline-pre">Named</span> и <span class="inline-pre">Aged</span> в одно единственное требование композиции протоколов в качестве параметра функции:</p>
<pre><code class="swift language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print("С Днем Рождения, \(celebrator.name)! Тебе уже \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Сашка", age: 21)
wishHappyBirthday(to: birthdayPerson)
// Выведет "С Днем Рождения, Сашка! Тебе уже 21!"</code></pre>
<p>В этом примере мы определяем протокол <span class="inline-pre">Named</span> с единственным требованием свойства name типа <span class="inline-pre">String</span>, значение которого мы можем получить. Так же мы определяем протокол <span class="inline-pre">Aged</span> с единственным требованием свойства age типа <span class="inline-pre">Int</span>, значение которого мы так же должны иметь возможность получить. Оба этих протокола принимаются структурой <span class="inline-pre">Person</span>.</p>
<p>Этот пример определяет функцию <span class="inline-pre">wishHappyBirthday(to:)</span>, которая принимает единственный параметр <span class="inline-pre">celebrator</span>. Тип этого параметра <span class="inline-pre">Named &amp; Aged</span>, что означает “любой тип, который соответствует сразу двум протоколам <span class="inline-pre">Aged</span> и <span class="inline-pre">Named</span>”. Не важно какой тип передается в качестве параметра функции до тех пор, пока он соответствует этим протоколам.</p>
<p>Далее в примере мы создаем экземпляр <span class="inline-pre">birthdayPerson</span> класса <span class="inline-pre">Person</span> и передаем этот новый экземпляр в функцию <span class="inline-pre">wishHappyBirthday(to:)</span>. Из-за того что <span class="inline-pre">Person</span> соответствует двум протоколам, то функция <span class="inline-pre">wishHappyBirthday(to:)</span> может вывести поздравление с днем рождения.</p>
<p>Следующий пример показывает как вы можете объединить протокол <span class="inline-pre">Named</span> с классом <span class="inline-pre">Location</span>:</p>
<pre><code class="language-swift">class Location {
    var latitude: Double
    var longitude: Double
    init(latitude: Double, longitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
    }
}
class City: Location, Named {
    var name: String
    init(name: String, latitude: Double, longitude: Double) {
        self.name = name
        super.init(latitude: latitude, longitude: longitude)
    }
}
func beginConcert(in location: Location &amp; Named) {
    print("Hello, \(location.name)!")
}
 
let seattle = City(name: "Seattle", latitude: 47.6, longitude: -122.3)
beginConcert(in: seattle)
// Выведет "Hello, Seattle!"</code></pre>
<p>Функция <span class="inline-pre">beginConcert(in:)</span> принимает параметр типа <span class="inline-pre">Location</span> и <span class="inline-pre">Named</span>, что означает любой тип, который является подклассом <span class="inline-pre">Location</span>, и который будет реализовывать протокол <span class="inline-pre">Named</span>. В этом случае <span class="inline-pre">City</span> удовлетворяем обоим требованиям.</p>
<p>Передавать <span class="inline-pre">birthdayPerson</span> в функцию <span class="inline-pre">beginConcert(in:)</span> некорректно, так как <span class="inline-pre">Person</span> не является подклассом <span class="inline-pre">Location</span>. И наоборот, если вы создали подкласс <span class="inline-pre">Location</span>, который не реализует протокол <span class="inline-pre">Named</span>, то вызов метода <span class="inline-pre">beginConcert(in:)</span> с этим экземпляром так же является некорректным.</p>
<h1><a id="checking-protocol-conformance"></a>Проверка соответствия протоколу</h1>
<p>Вы можете использовать операторы <span class="inline-pre">is</span> и <span class="inline-pre">as</span>, которые описаны в главе <a href="https://swiftbook.ru/content/languageguide/type-casting/#top">Приведение типов</a>, для проверки соответствия протоколу и приведению к определенному протоколу. Приведение к протоколу проходит точно так же как и приведение к типу:</p>
<ul>
<li>Оператор <span class="inline-pre">is</span> возвращает значение <span class="inline-pre">true</span>, если экземпляр соответствует протоколу и возвращает <span class="inline-pre">false</span>, если нет.</li>
<li>Опциональная версия оператора понижающего приведения <span class="inline-pre">as?</span> возвращает опциональное значение типа протокола, и это значение равно <span class="inline-pre">nil</span>, если оно не соответствует протоколу.</li>
<li>Принудительная версия оператора понижающего приведения <span class="inline-pre">as</span> осуществляет принудительное понижающее приведение, и если оно не завершается успешно, то выскакивает runtime ошибка.</li>
</ul>
<p>Этот пример определяет протокол <span class="inline-pre">HasArea</span> с единственным требованием свойства <span class="inline-pre">area</span> типа <span class="inline-pre">Double</span> (доступное свойство):</p>
<pre><code class="swift language-swift">protocol HasArea {
    var area: Double { get }
}</code></pre>
<p>Ниже представлены два класса <span class="inline-pre">Circle</span>, <span class="inline-pre">Country</span>, оба из которых соответствуют протоколу <span class="inline-pre">HasArea</span>:</p>
<pre><code class="swift language-swift">class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}</code></pre>
<p>Класс <span class="inline-pre">Circle</span> реализует требование свойства <span class="inline-pre">area</span> в качестве вычисляемого свойства, основываясь на хранимом свойстве <span class="inline-pre">radius</span>. Класс <span class="inline-pre">Country</span> реализует требование <span class="inline-pre">area</span> напрямую в качестве хранимого свойства. Оба класса корректно соответствуют протоколу <span class="inline-pre">HasArea</span>.</p>
<p>Ниже приведен класс <span class="inline-pre">Animal</span>, который не соответствует протоколу <span class="inline-pre">HasArea</span>:</p>
<pre><code class="swift language-swift">class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}</code></pre>
<p>Классы <span class="inline-pre">Circle</span>, <span class="inline-pre">Country</span>, <span class="inline-pre">Animal</span> не имеют общего базового класса. Тем не менее они все являются классами, и их экземпляры могут быть использованы для инициализации массива, который хранит значения типов <span class="inline-pre">AnyObject</span>:</p>
<pre><code class="swift language-swift">let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]</code></pre>
<p>Массив <span class="inline-pre">objects</span> инициализирован при помощи литерала, содержащего экземпляры <span class="inline-pre">Circle</span>, который имеет <span class="inline-pre">radius</span> равный <span class="inline-pre">2</span>, экземпляр типа <span class="inline-pre">Country</span>, который инициализирован площадью Великобритании в квадратных километрах, и экземпляром класса <span class="inline-pre">Animal</span>, который инициализирован количеством ног.</p>
<p>Массив <span class="inline-pre">objects</span> может быть перебран, и каждый элемент массива может быть проверен на соответствие протоколу <span class="inline-pre">HasArea</span>:</p>
<pre><code class="swift language-swift">for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Площадь равна \(objectWithArea.area)")
    } else {
        print("Что-то такое, что не имеет площади")
    }
}
// Площадь равна 12.5663708
// Площадь равна 243610.0
// Что-то такое, что не имеет площади</code></pre>
<p>Каждый раз, когда объект массива соответствует протоколу <span class="inline-pre">HasArea</span>, возвращается опциональное значение при помощи оператора <span class="inline-pre">as?</span>, которое разворачивается при помощи опциональной связки в константу <span class="inline-pre">objectWithArea</span>. Константа <span class="inline-pre">objectWithArea</span> является типом <span class="inline-pre">HasArea</span>, таким образом, свойство <span class="inline-pre">area</span> может быть доступно и выведено на экран способом вывода через сам тип.</p>
<p>Обратите внимание, что базовые объекты не меняются в процессе приведения типа. Они остаются <span class="inline-pre">Circle</span>, <span class="inline-pre">Country</span> и <span class="inline-pre">Animal</span>. Однако в момент, когда они хранятся в константе <span class="inline-pre">objectWithArea</span>, известно лишь то, что они являются типом <span class="inline-pre">HasArea</span>, так что мы можем получить доступ только к свойству <span class="inline-pre">area</span>.</p>
<h1><a id="optional-protocol-requirements"></a>Опциональные требования протокола</h1>
<p>Вы можете определить опциональные требования для протокола. Эти требования не обязательно должны быть реализованы для соответствия протоколу. Опциональные требования должны иметь префиксный модификатор <span class="inline-pre">optional</span> в качестве части определения протокола. Таким образом вы можете писать код, который взаимодействует с кодом на Objective-C. Имеется в виду, что без <span class="inline-pre">@objc</span> код не будет компилироваться, и при этом наличие <span class="inline-pre">@objc</span> позволяет коду Swift взаимодействовать с кодом Objective-C. И протокол, и опциональное требование должны иметь атрибут <span class="inline-pre">@objc</span>. Обратите внимание, что протоколы с маркировкой <span class="inline-pre">@objc</span> могут приниматься только классами, но не структурами или перечислениями.</p>
<p>Когда вы используете опциональное требование свойства или метода, то их тип автоматически становится опциональным. Например, тип метода <span class="inline-pre">(Int) -&gt; String</span> становится <span class="inline-pre">((Int) -&gt; String)?</span>. Обратите внимание, что весь тип функции обернут в опциональное значение, а не только возвращаемое значение функции.</p>
<p>Опциональное требование протокола может быть вызвано при помощи опциональной цепочки, чтобы учесть возможность того, что требование не будет реализовано типом, который соответствует протоколу. Вы проверяете реализацию опционального метода, написав вопросительный знак после имени метода, когда он вызывается, например <span class="inline-pre">someOptionalMethod?(someArgument)</span>. Для более полной информации о опциональной последовательности читайте <a href="https://swiftbook.ru/content/languageguide/optional-chaininig/#top">Опциональная последовательность</a>.</p>
<p>Следующий пример определяет класс <span class="inline-pre">Counter</span>, который использует источник внешних данных для предоставления значение их инкремента. Этот источник внешних данных определен протоколом <span class="inline-pre">CounterDataSource</span>, который имеет два опциональных требования:</p>
<pre><code class="swift language-swift">@objc protocol CounterDataSource {
    @objc optional func increment(forCount count: Int) -&gt; Int
    @objc optional var fixedIncrement: Int { get }
}</code></pre>
<p>Протокол <span class="inline-pre">CounterDataSource</span> определяет опциональное требование метода <span class="inline-pre">increment(forCount:)</span> и опциональное требование свойства <span class="inline-pre">fixedIncrement</span>. Эти требования определяют два разных способа для источника данных для предоставления подходящего значения инкремента для экземпляра <span class="inline-pre">Counter</span>.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Строго говоря, вы можете написать пользовательский класс, который соответствует протоколу <span class="inline-pre">CounterDataSource</span> без реализации какого-либо требования этого протокола. Они оба опциональные, в конце концов. Хотя технически это допускается, но это не будет реализовываться для хорошего источника данных.</p>
</div>
<p>Класс <span class="inline-pre">Counter</span>, определенный ниже, имеет опциональное свойство <span class="inline-pre">dataSource</span> типа <span class="inline-pre">CounterDataSource?</span>:</p>
<pre><code class="swift language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.increment?(forCount: count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}</code></pre>
<p>Класс <span class="inline-pre">Counter</span> хранит свое текущее значение в переменном свойстве <span class="inline-pre">count</span>. Класс <span class="inline-pre">Counter</span> так же определяет метод <span class="inline-pre">increment</span>, который увеличивает свойство <span class="inline-pre">count</span>, каждый раз, когда вызывается этот метод.</p>
<p>Метод <span class="inline-pre">increment</span> сначала пытается получить значение инкремента, заглядывая в реализацию метода <span class="inline-pre">increment(forCount:)</span> в его источнике данных. Метод <span class="inline-pre">increment</span> использует опциональную последовательность для попытки вызвать <span class="inline-pre">increment(forCount:)</span> и передает текущее значение <span class="inline-pre">count</span> как единственный аргумент метода.</p>
<p>Обратите внимание, что здесь всего <em>два </em>уровня опциональной последовательности. Первый - возможный источник данных <span class="inline-pre">dataSource</span>, который может быть <span class="inline-pre">nil</span>, так что <span class="inline-pre">dataSource</span> имеет вопросительный знак после имени для индикации того, что метод <span class="inline-pre">increment(forCount:)</span> может быть вызван только в том случае, если <span class="inline-pre">dataSource</span> не <span class="inline-pre">nil</span>. Второй уровень говорит нам о том, что даже если <span class="inline-pre">dataSource</span> существует, у нас все равно нет гарантии того, что он реализует метод <span class="inline-pre">increment(forCount:)</span>, потому что это опциональное требование. Есть вероятность, что <span class="inline-pre">increment(forCount:)</span> так же не реализован из-за опциональной цепочки. Вызов <span class="inline-pre">increment(forCount:)</span> происходит только, если <span class="inline-pre">increment(forCount:)</span> существует и не равен <span class="inline-pre">nil</span>.  Именно по этой причине <span class="inline-pre">increment(forCount:)</span> записан с вопросительным знаком после своего имени.</p>
<p>Так как вызов <span class="inline-pre">increment(forCount:)</span> может провалиться по одной из этих двух причин, вызов возвращает нам значение типа опционального <span class="inline-pre">Int</span>. Это верно даже если <span class="inline-pre">increment(forCount:)</span> определено как возвращающее неопциональное значение <span class="inline-pre">Int</span> в определении <span class="inline-pre">CounterDataSource</span>.  Даже если подряд идут две опциональные операции, одна сразу после другой, то результат все равно будет иметь единственный завернутый опционал. Подробнее читайте <a href="https://swiftbook.ru/content/languageguide/optional-chaininig/#linking-multiple-levels-of-chaining">Соединение нескольких уровней опциональных последовательностей</a>.</p>
<p>После вызова <span class="inline-pre">increment(forCount:)</span> опциональный <span class="inline-pre">Int</span>, который он возвращает, разворачивается в константу <span class="inline-pre">amount</span>, при помощи опциональной связки. Если опциональный <span class="inline-pre">Int</span> содержит значения, то есть, если делегат и метод существуют, и метод вернул значение, то неразвернутое значение <span class="inline-pre">amount</span> прибавляется в свойство <span class="inline-pre">count</span>, и на этом реализация завершается.</p>
<p>Если же нет возможности получить значение из метода <span class="inline-pre">increment(forCount:)</span> по причине <span class="inline-pre">dataSource</span> равен <span class="inline-pre">nil</span> или из-за того что у источника данных нет реализации метода <span class="inline-pre">increment(forCount:)</span>, а следовательно вместо этого метод <span class="inline-pre">increment</span> пытается получить значение от источника данных <span class="inline-pre">fixedIncrement</span>. Свойство <span class="inline-pre">fixedIncrement</span> является опциональным требованием, так что его имя так же написано в опциональной последовательности с вопросительным знаком, что служит индикатором того, что попытка получить значение этого свойства может привести к провалу. Как и раньше, возвращаемое значение является опциональной <span class="inline-pre">Int</span>, даже тогда <span class="inline-pre">fixedIncrement</span> определен как свойство типа неопционального Int, в качестве части определения протокола <span class="inline-pre">CounterDataSource</span>.</p>
<p>Ниже приведена простая реализация <span class="inline-pre">CounterDataSource</span>, где источник данных возвращает постоянное значение <span class="inline-pre">3</span>, каждый раз, как получает запрос. Это осуществляется благодаря тому, что реализуется опциональное требование свойства <span class="inline-pre">fixedIncrement</span>:</p>
<pre><code class="swift language-swift">class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}</code></pre>
<p>Вы можете использовать экземпляр <span class="inline-pre">ThreeSource</span> в качестве источника данных для новых экземпляров <span class="inline-pre">Counter</span>:</p>
<pre><code class="swift language-swift">var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    print(counter.count)
}
// 3
// 6
// 9
// 12</code></pre>
<p>Код, приведенный выше, создает новый экземпляр <span class="inline-pre">Counter</span>, устанавливает его источник данных как экземпляр <span class="inline-pre">ThreeSource</span> и вызывает метод счетчика <span class="inline-pre">increment</span> четыре раза. Как и ожидалось, свойство счетчика увеличивается на три каждый раз, когда вызывается <span class="inline-pre">increment</span>.</p>
<p>Ниже приведен более сложный источник данных <span class="inline-pre">TowardsZeroSource</span>, который заставляет экземпляр <span class="inline-pre">Counter</span> считать в сторону увеличения или уменьшения по направлению к нулю от текущего значения <span class="inline-pre">count</span>:</p>
<pre><code class="swift language-swift">class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}</code></pre>
<p>Класс <span class="inline-pre">TowardsZeroSource</span> реализует опциональный метод <span class="inline-pre">increment(forCount:)</span> из протокола <span class="inline-pre">CounterDataSource</span> и использует значение аргумента <span class="inline-pre">count</span> для определения направления следующего счета. Если <span class="inline-pre">count</span> уже ноль, то метод возвращает <span class="inline-pre">0</span>, для отображения того, что дальнейших вычислений не требуется.</p>
<p>Вы можете использовать экземпляр <span class="inline-pre">TowardsZeroSource</span> с уже существующим экземпляром <span class="inline-pre">Counter</span> для отсчета от -<span class="inline-pre">4</span> и до <span class="inline-pre">0.</span> Как только счетчик достигает <span class="inline-pre">0</span>, вычисления прекращаются:</p>
<pre><code class="swift language-swift">counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    print(counter.count)
}
// -3
// -2
// -1
// 0
// 0</code></pre>
<h1><a id="protocol-extensions"></a>Расширения протоколов</h1>
<p>Протоколы могут быть расширены для обеспечения метода и реализации свойства соответствующими типами. Это позволяет вам самостоятельно определить поведение по протоколам, а не по индивидуальному соответствию каждого типа или глобальной функции.</p>
<p>Например, <span class="inline-pre">RandomNumberGenerator</span> протокол может быть расширен для обеспечения <span class="inline-pre">randomBool()</span> метода, который использует результат вызванного <span class="inline-pre">random()</span> метода для возврата <span class="inline-pre">random</span> (случайного) значения <span class="inline-pre">Bool</span>:</p>
<pre><code class="swift language-swift">extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>
<p>Создавая расширение по протоколу, все соответствующие типы автоматически получают эту реализацию метода без каких-либо дополнительных изменений.</p>
<pre><code class="swift language-swift">let generator = LinearCongruentialGenerator()
print("Рандомное число: \(generator.random())")
// Выведет "Рандомное число: 0.37464991998171"
print("Рандомное логическое значение: \(generator.randomBool())")
// Выведет "Рандомное логическое значение: true"</code></pre>
<p>Расширения протоколов могут добавлять реализацию к соответствующим типам данных, но не могут расширить протокол или унаследовать от другого протокола. Наследование протокола всегда указывается в самом объявлении протокола.</p>
<h2>Обеспечение реализации по умолчанию (дефолтной реализации)</h2>
<p>Вы можете использовать расширение протокола, чтобы обеспечить реализацию по умолчанию для любого метода или требования свойства этого протокола. Если соответствующий тип предоставляет свою собственную реализацию требуемого метода или свойства, то реализация будет использоваться вместо той, которая предоставляется расширением.</p>
<div class="tip">
<h4>Заметка</h4>
<p>Требования протокола с реализацией по умолчанию, предоставляемой расширениями, отличаются от опциональных требований протокола. Хотя соответствующие типы не должны предоставлять свою собственную реализацию, требования с реализацией по умолчанию могут быть вызваны без опциональных последовательностей.</p>
</div>
<p>Например, протокол <span class="inline-pre">PrettyTextRepresentable</span>, который наследует от протокола <span class="inline-pre">TextRepresentable</span> может предоставлять дефолтную реализацию требуемого свойства <span class="inline-pre">prettyTextualDescription</span>, просто возвращая результат обращения к свойству <span class="inline-pre">textualDescription</span>:</p>
<pre><code class="swift language-swift">extension PrettyTextRepresentable  {
    var prettyTextualDescription: String {
        return textualDescription
    }
}
</code></pre>
<h2>Добавление ограничений к расширениям протоколов</h2>
<p>Когда вы определяете расширение протокола, вы можете указать ограничения для принимающих типов, которые они должны удовлетворить до того, как будут доступны методы и свойства расширения. Вы записываете эти ограничения сразу после имени протокола, при помощи оговорки <span class="inline-pre">where</span>. Более подробно об оговорках <span class="inline-pre">where</span>, читайте в разделе <a href="https://swiftbook.ru/content/languageguide/generics-in-swift/#where-clause">"Оговорка Where".</a></p>
<p>Например, вы можете определить расширение протокола <span class="inline-pre">Collection</span>, которое применимо ко всем коллекциям, чьи элементы соответствуют протоколу <span class="inline-pre"> Equatable</span>. Ограничивая элементы <span class="inline-pre">Collection</span> протоколом <span class="inline-pre"> Equatable</span>, частью стандартной библиотеки, вы можете использовать операторы <span class="inline-pre">==</span> и <span class="inline-pre">!=</span> для проверки равенства и неравенства между двумя элементами.</p>
<pre><code class="swift language-swift">extension Collection where Element: Equatable {
    func allEqual() -&gt; Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}</code></pre>
<p><span class="inline-pre">Метод allEqual()</span> возвращает true, только если все элементы в <span class="inline-pre">Collection</span> равны.</p>
<p>Рассмотрим два целочисленных массива: один, где все элементы одинаковы, и другой, где элементы различны:</p>
<pre><code class="swift language-swift">let equalNumbers = [100, 100, 100, 100, 100]
let differentNumbers = [100, 100, 200, 100, 200]
</code></pre>
<p>Поскольку массивы соответствуют <span class="inline-pre">Collection</span> и целые числа соответствуют <span class="inline-pre">Equatable</span>, <span class="inline-pre">equalNumbers</span> и <span class="inline-pre">differentNumbers</span> могут использовать метод <span class="inline-pre">allEqual():</span></p>
<pre><code class="swift language-swift">
print(equalNumbers.allEqual())
// Prints "true"
print(differentNumbers.allEqual())
// Prints "false"
</code></pre>
<div class="tip">
<h4>Заметка</h4>
<p>Если подписанный тип удовлетворяет требованиям нескольких ограничивающих расширений, которые предоставляют реализации для одного и того же метода или свойства, то Swift будет использовать самое строгое ограничение.</p>
</div>
<div class="mistape_caption">
<p>Если вы нашли ошибку, пожалуйста, выделите фрагмент текста и нажмите <em>Ctrl+Enter</em>.</p>
</div>
<section id="next_previous" class="costom_pagination">
<p class="previous-link"><a href="https://swiftbook.ru/content/languageguide/opaque-types" rel="26999">Непрозрачные типы</a></p>
<p class="next-link"><a href="https://swiftbook.ru/content/languageguide/generics-in-swift" rel="8816">Универсальные шаблоны</a></p>
</section>
<p>Сообщение <a rel="nofollow" href="https://swiftbook.ru/content/languageguide/protocols/">Протоколы</a> появились сначала на <a rel="nofollow" href="https://swiftbook.ru">SwiftBook</a>.</p>