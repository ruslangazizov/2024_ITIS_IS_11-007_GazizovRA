tag:blogger.com,1999:blog-8520.post-81526799745409908312023-10-17T14:00:00.005-04:002023-10-17T15:06:56.084-04:00Security Developer-in-Residence 2023 Q3 Report<p>It’s been three months since I was first hired as the inaugural Security Developer-in-Residence. I’m quite proud of what I’ve accomplished so far and think it shows the value of investing into the security of Open Source through hiring folks to work full-time in roles like “Developer-in-Residence” programs. I’m thankful to the <a href="https://alpha-omega.dev/">Alpha-Omega project at OpenSSF</a> for funding this work. Let’s review all of the accomplishments in the first quarter of this role and what to look forward to in the next quarter.<br /><br />If you’d like to follow along with my work more closely you can subscribe to my <a href="https://sethmlarson.dev/blog#archive">personal blog</a> where I publish <a href="https://sethmlarson.dev/security-developer-in-residence-weekly-report-13">weekly updates</a> about the work I’m doing. If you have questions or thoughts about what I’m working on you can contact me via email: <a href="mailto:seth@python.org">seth@python.org</a>.<br /></p><h2 style="text-align: left;">The Python Software Foundation authorized as a CVE Numbering Authority (CNA)</h2><p>Back in late August the Python Software Foundation received notice that we’d successfully completed onboarding and had been <a href="https://pyfound.blogspot.com/2023/08/psf-authorized-as-cna.html">authorized by CVE as a CVE Numbering Authority</a> or “CNA”. The <a href="https://www.cve.org/PartnerInformation/ListofPartners/partner/PSF">Python Software Foundation CNA scope</a> covers Python and pip, two projects which are fundamental to the rest of the Python ecosystem.<br /><br />Being a CNA means that the PSF can offer staffing to improve the sustainability and responsiveness of coordination and vulnerability disclosure work for covered projects. The PSF CNA also provides <a href="https://osv.dev/vulnerability/PSF-2023-8">rich metadata for CVE records and advisories</a>, including remediation information, so upgrading or patching for vulnerabilities is as straightforward as possible for downstream users of Python.<br /><br /></p><h2 style="text-align: left;">CPython vulnerability advisories available in Open Source Vulnerability database</h2><p style="text-align: left;">The Python Software Foundation now hosts a <a href="https://github.com/psf/advisory-database">vulnerability database on GitHub</a> using the <a href="https://ossf.github.io/osv-schema/">Open Source Vulnerability format</a> (OSV). This database contains vulnerability information for CPython in addition to vulnerabilities getting published to the security-announce@python.org mailing list. The historical vulnerability information was sourced from Victor Stinner’s “<a href="https://python-security.readthedocs.io/">python-security</a>” project in order to provide a complete history of vulnerabilities in CPython.<br /><br />By using the OSV format the vulnerabilities can be ingested and processed by the Open Source Vulnerability database which can be searched or <a href="https://google.github.io/osv.dev/api/">queried using an API</a> for machine-consumable vulnerability information. <br /><br />Having vulnerability information in a machine-consumable format enables tools that scan software deployments for vulnerabilities to easily provide accurate and automatically updated reports for CPython. The Open Source Vulnerability database also is more discoverable compared to the CVE database, having a readily available public API to query for vulnerabilities, products, and versions.<br /><br /></p><h2 style="text-align: left;">Python Security Response Team</h2><p style="text-align: left;">I have been helping coordinate reports to the <a href="https://www.python.org/dev/security/">Python Security Response Team</a> (PSRT) since joining the role. This work includes reviewing all reports, gathering information from reporters, discussing timelines, and working with core developers to create and release fixes and advisories in a coordinated manner. I also worked with CVE to get CVE IDs assigned on behalf of reports before the PSF was designated as a CNA.<br /><br />I revitalized the <a href="https://mail.python.org/mailman3/lists/security-announce.python.org/">security-announce@python.org mailing list</a> to use for future advisory announcements so interested parties can be notified as soon as new vulnerabilities are published (subscribe to the linked list if you’d like to receive these). I coordinated the two recent vulnerabilities affecting CPython (<a href="https://osv.dev/vulnerability/PSF-2023-8">CVE-2023-40217</a> and <a href="https://osv.dev/vulnerability/PSF-2023-9">CVE-2023-41105</a>) end-to-end from report to published advisory.<br /><br />Doing this coordination work frees up volunteers on the PSRT to focus on determining whether a report is a vulnerability and working on fixes. I’m also working to further reduce the manual coordination work required by PSRT by moving the reporting and triage process to GitHub using GitHub Security Advisories.</p><h2 style="text-align: left;">OpenSSF Day Europe 2023</h2><p style="text-align: left;">I co-presented a talk titled “<a href="https://sched.co/1P6TW">We Make Python Safer than Ever</a>” at OpenSSF Day Europe 2023 with PSF Board Member and OpenSSF Community Manager Cheuk Ting-Ho. The <a href="https://static.sched.com/hosted_files/openssfdayeu2023/a3/Final%20-%20OpenSSF%20Day%20Europe%202023.pdf">slides are available for download</a> and the <a href="https://www.youtube.com/watch?v=jhzv5RU56V4">talk recording is available to watch on YouTube</a>.<br /><br />The talk introduced the Security Developer-in-Residence role, went over the challenges that are unique to securing Open Source and Python ecosystems, described completed and future projects to make the Python ecosystem more secure, and gave a list of items that viewers themselves could do right away to make their own usage of Python more secure.<br /><br /></p><h2 style="text-align: left;">Sigstore signatures for Python release artifacts</h2><p style="text-align: left;">Python releases include signatures from the Release Managers using the signing tool “<a href="https://www.sigstore.dev/">Sigstore</a>”. These signatures mean you can be sure that a given release artifact wasn’t tampered with and was created and vetted by the Release Manager for a given Python release.<br /><br />I did an audit of existing signatures and <a href="https://github.com/sigstore/sigstore-python/issues/600#issuecomment-1634961707">found some discrepancies</a> between the documented identities and providers and what was published for each release. I worked with Release Managers to fix the discrepancies and <a href="https://github.com/python/release-tools/pull/51">added extra safeguards</a> to release tooling to ensure signatures are verifiable as documented. I also was able to back-fill the <a href="https://github.com/python/pythondotorg/issues/2300">new Sigstore signature format</a> from existing verification materials to make verifying signatures even easier!<span style="font-family: courier;"></span></p><blockquote><span style="font-family: courier;">$ python -m sigstore verify identity \<br />&nbsp;&nbsp;&nbsp; --bundle Python-3.12.0.tgz.sigstore \<br />&nbsp;&nbsp;&nbsp; --cert-identity thomas@python.org \<br />&nbsp;&nbsp;&nbsp; --cert-oidc-issuer https://accounts.google.com \<br />&nbsp;&nbsp;&nbsp; Python-3.12.0.tgz</span></blockquote>Having consistent artifact signatures is important because any discrepancies while consuming these signatures should raise red flags for downstream users and redistributors. This also helps build confidence in the new signing method over existing methods like GPG.<br /><br /><p></p><h2 style="text-align: left;">Adoption of system trust stores via Truststore</h2><p style="text-align: left;">There are three packaging tools (pip, PDM, and Conda) that are important to the Python ecosystem that are at various stages of adopting “Truststore”, a library that I authored prior to joining the PSF to enable Python projects to use system trust stores for verifying HTTPS certificates instead of relying on certifi for certificates.<br /><br />PDM has started using Truststore by default starting in <a href="https://github.com/pdm-project/pdm/releases/tag/2.9.0">v2.9.0</a>, Conda plans to release <a href="https://github.com/conda/conda/milestone/63">optional support for Truststore in v23.9.0</a>, and pip already has <a href="https://pip.pypa.io/en/stable/topics/https-certificates/#using-system-certificate-stores">optional support for Truststore</a> since v22.2 but has recently bundled Truststore into pip to remove the need to “bootstrap” into Truststore by pre-installing the library.<br /><br />Using the system trust store is important because any removals to a trust store (<a href="https://osv.dev/vulnerability/PYSEC-2023-135">like for e-Tugra root certificates</a>) must be propagated to all end systems in order to avoid “monster-in-the-middle” attacks. Further challenging this propagation is that some tools like pip bundle certifi as a means of bootstrapping, which means that you need to upgrade both certifi and pip in order to completely propagate updates to certifi’s certificate bundle.<br /><br />This propagation is better suited to a centralized system like an OS package manager or an automatic centralized authority or IT department keeping the trust bundles up-to-date, which can only happen through using system trust stores.<br /><br />Recently the Python implementation PyPy added support for Python 3.10, thus enabling PyPy to also use Truststore. I <a href="https://github.com/sethmlarson/truststore/pull/113">subsequently added support and backwards compatibility tests for PyPy to Truststore</a> to ensure all compliant implementations of Python can take advantage of the benefits.</p><h2 style="text-align: left;">Future Projects and Challenges<br /> <br /></h2><h3 style="text-align: left;">Software Bills-of-Materials for CPython</h3><p style="text-align: left;">Software Bill-of-Materials (SBOMs) are a hot topic in the world of software security due to new government requirements and improved software and vulnerability management tooling. Many tools generate or consume SBOMs as a universal format for describing software and its components and then matching those components to known vulnerabilities.<br /><br />I've started working on an authoritative SBOM for the CPython project, you can follow along in <a href="https://github.com/sethmlarson/cpython-sbom">this GitHub repository</a> if you are interested. This project is early and this will not be the final product or place where this information is published, this is only a place to experiment and get feedback on the approach and outputs before putting the final infrastructure in place.<br /><br />I started with the most straightforward release artifact, the source tarball, and I am planning to tackle the binary installers later since they'll require more research into the release processes. There is a work-in-progress SBOM file for Python-3.12.0.tgz available in the <a href="https://github.com/sethmlarson/cpython-sbom/blob/main/sboms">sboms/ directory on the repository</a>.<br /><br />Using vulnerability scanning tools I was able to see not only vulnerabilities in CPython, but <b>crucially in the bundled subcomponents like expat and pip</b>. Without an SBOM the subcomponents to a project like CPython likely wouldn’t get detected properly and thus would be not covered by vulnerability management tooling.<br /><br />The challenges here will be integrating the creation and maintenance of the SBOMs into the CPython development and release processes while minimally disrupting other core developers workflows and avoiding the need to develop and maintain custom tooling for CPython’s specific use-case.<br /><br /></p><h3 style="text-align: left;">Tracking bundled dependencies in Python packages</h3><p style="text-align: left;">Python is the premier “glue” language, meaning that Python is often used alongside many other programming languages like C, C++, Rust, Go, and more thanks to Python C API. This benefit also means that Python packages can include projects and source code from sources both within and external to the Python ecosystem.<br /><br />Those projects and source code from outside the Python ecosystem present a problem for vulnerability scanners <b>which typically rely on explicit metadata about projects and dependencies in order to find vulnerabilities in software manifests</b>. Without a clear way to encode this information into packaging metadata it’s impossible to signal these dependencies even if a maintainer of a project wants to do so.<br /><br />C and C++ projects in particular pose additional issues due to their existence outside of a programming language packaging ecosystem like Python with PyPI or JavaScript and NPM. This makes tracking usage and vulnerabilities in these projects difficult and relies on other identification schemes like CPEs or redistributions in other packaging ecosystems like RPM/DEB. Without this information scanners today miss vulnerable components bundled in Python packages, meaning developers won’t know how or when their Python deployments are vulnerable.<br /><br />Solving this issue completely will be a multi-step process, starting with being able to encode information about bundled projects into Python distributions which will require a new packaging PEP. After the standard has been decided, next is getting bundled project metadata automatically captured to avoid needing an entire ecosystem to manually annotate every project. Concurrently to this I’ll collaborate with SBOM generation tooling to add support for consuming the new standard and adding that information to SBOMs generated from Python environments.<br /><br /></p><h3 style="text-align: left;">CPython and pip release process improvements</h3><p style="text-align: left;">CPython and pip are two of the most important projects in the Python ecosystem and each have non-trivial release processes. In an effort to increase the integrity of these projects’ releases I’ve <a href="https://sethmlarson.dev/security-developer-in-residence-weekly-report-9">researched and documented their release process</a> and with <a href="https://slsa.dev/spec/v1.0/threats-overview">SLSA’s list of historical supply chain attacks against software projects</a> have been making suggestions and implementing improvements.<br /><br />These improvements include reproducibility of built artifacts, extra guarantees on the integrity of inputs, automating the build processes to reduce attack surface area to only services like GitHub Actions and Azure Pipelines instead of individuals’ computers, and making it so that in the event of an attack that it would need to be publicly detectable and traceable.<br /><br />By improving the integrity of these processes I am hoping to prevent disaster scenarios such as malware being injected into Python or pip at the “last mile” before being published to python.org. <b>Injection of malware during build time has happened to multiple other Open Source projects with disastrous results for users</b>. This work means users can be even more confident in their usage of Python and upgrade early and often to take advantage of Python’s latest features.</p>Seth Michael Larsonhttps://www.blogger.com/profile/16555309043643874359noreply@blogger.com